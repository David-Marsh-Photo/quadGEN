// Auto-limit state management
// Centralizes the metadata generated by the auto white/black rolloff detector

import { registerDebugNamespace } from '../utils/debug-registry.js';
import { getLegacyScope, registerLegacyHelpers } from '../legacy/legacy-helpers.js';

const listeners = new Set();

const legacyScope = getLegacyScope();

const state = (() => {
  const existing = legacyScope._autoLimitState;
  if (existing && typeof existing === 'object') {
    return existing;
  }
  const initial = {};
  legacyScope._autoLimitState = initial;
  return initial;
})();

function syncLegacyReference() {
  legacyScope._autoLimitState = state;
}

syncLegacyReference();

function cloneSnapshot(source) {
  if (!source) return {};
  if (typeof structuredClone === 'function') {
    try {
      return structuredClone(source);
    } catch (err) {
      // Fall through to JSON fallback
    }
  }
  try {
    return JSON.parse(JSON.stringify(source));
  } catch (err) {
    return { ...source };
  }
}

function notify(prevState) {
  const snapshot = cloneSnapshot(state);
  listeners.forEach((callback) => {
    try {
      callback(snapshot, cloneSnapshot(prevState));
    } catch (err) {
      console.warn('[auto-limit-state] listener error', err);
    }
  });
}

export function getAutoLimitState() {
  return state;
}

export function setAutoLimitState(nextState) {
  const prevState = cloneSnapshot(state);
  Object.keys(state).forEach((key) => {
    delete state[key];
  });
  if (nextState && typeof nextState === 'object') {
    Object.keys(nextState).forEach((key) => {
      state[key] = nextState[key];
    });
  }
  syncLegacyReference();
  notify(prevState);
  return state;
}

export function setChannelAutoLimitMeta(channelName, meta) {
  if (!channelName) return null;
  const prevState = cloneSnapshot(state);
  if (meta && typeof meta === 'object' && Object.keys(meta).length > 0) {
    state[channelName] = meta;
  } else {
    delete state[channelName];
  }
  syncLegacyReference();
  notify(prevState);
  return state[channelName] || null;
}

export function clearChannelAutoLimitMeta(channelName) {
  if (!channelName || !state[channelName]) return;
  const prevState = cloneSnapshot(state);
  delete state[channelName];
  syncLegacyReference();
  notify(prevState);
}

export function resetAutoLimitState() {
  if (!Object.keys(state).length) return;
  const prevState = cloneSnapshot(state);
  Object.keys(state).forEach((key) => delete state[key]);
  syncLegacyReference();
  notify(prevState);
}

export function subscribeAutoLimitState(callback) {
  if (typeof callback !== 'function') return () => {};
  listeners.add(callback);
  return () => {
    listeners.delete(callback);
  };
}

registerLegacyHelpers({
  getAutoLimitState,
  setAutoLimitState,
  setChannelAutoLimitMeta,
  clearChannelAutoLimitMeta,
  resetAutoLimitState,
  subscribeAutoLimitState
});

registerDebugNamespace('autoLimitState', {
  getAutoLimitState,
  setAutoLimitState,
  setChannelAutoLimitMeta,
  clearChannelAutoLimitMeta,
  resetAutoLimitState,
  subscribeAutoLimitState
}, {
  exposeOnWindow: typeof window !== 'undefined',
  windowAliases: [
    'getAutoLimitState',
    'setAutoLimitState',
    'setChannelAutoLimitMeta',
    'clearChannelAutoLimitMeta',
    'resetAutoLimitState'
  ]
});
