<!DOCTYPE html>

<html lang="en">
<!--
MIT License

Copyright (c) 2025 David Marsh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Scope: This license applies to this HTML file (quadgen.html) only.
-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title id="pageTitle">quadGEN</title>
<meta content="quadGEN - Generate Epson P700-P900/P600-P800 QuadToneRIP .quad files with 256-step ramps per channel." name="description"/>
<!-- Version History notes guidance: keep entries concise, direct, factual, and short. See AGENTS.md and CLAUDE.md. -->
<script src="https://cdn.tailwindcss.com"></script>
  <script type="module" crossorigin>(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(i){if(i.ep)return;i.ep=!0;const a=n(i);fetch(i.href,a)}})();const wb="Beta",Cb="5.0.1",Sa=`${wb} ${Cb}`,Ab="quadgen.debugIntentTuning";function dE(e){localStorage.setItem(Ab,"true")}function pE(){return localStorage.getItem(Ab)==="true"}(()=>{const e=pE();return e&&dE(),e})();const ta=typeof globalThis<"u"?globalThis:{};function mf(){return typeof window<"u"?window:(ta&&typeof ta.window<"u"?ta.window:null)??null}function Mb(){if(ta&&typeof ta.matchMedia=="function")return ta.matchMedia.bind(ta);const e=mf();return e&&typeof e.matchMedia=="function"?e.matchMedia.bind(e):null}const Gd={};function $o(){return Gd}function Xe(e,t={},n={}){if(!e||typeof e!="string")throw new Error("registerDebugNamespace requires a string namespace");if(!t||typeof t!="object")throw new Error("registerDebugNamespace requires an object of helpers");const i={...Gd[e]||{},...t};Gd[e]=i;const{exposeOnWindow:a=!1,windowAliases:o=[]}=n;if(!a)return i;const s=mf();if(s){const l=s.__quadDebug=s.__quadDebug||{};l[e]=i,o.forEach(c=>{Object.prototype.hasOwnProperty.call(t,c)&&(typeof s[c]<"u"||(s[c]=t[c]))})}return i}const Mi=typeof globalThis<"u"?globalThis:{},fE={overrides:null,setOverrides(e){if(e&&typeof e=="object"){const t={},n=Number(e.K_NEIGHBORS);Number.isFinite(n)&&n>0&&(t.K_NEIGHBORS=Math.max(1,Math.round(n)));const r=Number(e.SIGMA_FLOOR);Number.isFinite(r)&&r>0&&(t.SIGMA_FLOOR=r);const i=Number(e.SIGMA_CEIL);Number.isFinite(i)&&i>0&&(t.SIGMA_CEIL=i);const a=Number(e.SIGMA_ALPHA);Number.isFinite(a)&&a>0&&(t.SIGMA_ALPHA=a),this.overrides=Object.keys(t).length?t:null}else this.overrides=null},get(e,t){const n=this.overrides&&this.overrides[e];return Number.isFinite(n)?n:t},exportOverrides(){return this.overrides?{...this.overrides}:null}};fE.setOverrides({K_NEIGHBORS:2,SIGMA_FLOOR:.036,SIGMA_CEIL:.15,SIGMA_ALPHA:2});const Rd="quadgen.debugIntentTuning";function hf(e){try{e?localStorage.setItem(Rd,"1"):localStorage.removeItem(Rd)}catch{}}function Lb(){try{return localStorage.getItem(Rd)==="1"}catch{return!1}}const Ib=typeof Mi.DEBUG_INTENT_TUNING=="boolean"?(hf(Mi.DEBUG_INTENT_TUNING),Mi.DEBUG_INTENT_TUNING):Lb();function mE(e){const t=!!e;if(hf(t),Mi.DEBUG_INTENT_TUNING=t,Mi.location&&typeof Mi.location.reload=="function")try{Mi.location.reload()}catch(n){console.warn("Intent debug reload failed:",n)}}Mi.DEBUG_INTENT_TUNING=Ib;function Wt(e){return Math.max(0,Math.min(1,e))}function Da(e,t){return Wt(Math.pow(Wt(e),t))}function hE(e,t){const n=Wt(t);return Wt(n===.5?e:n>.5?(Wt(e)-1)*(2*n-1)/(Wt(e)*(2*n-1)-n+1):Wt(e)*n/(1-Wt(e)+Wt(e)*n))}function gE(e,t,n){const r=hE(Wt(e),Wt(t)),i=1-Math.pow(1-r,1+Wt(n));return Wt(i)}function ll(e){try{const t=(e||[]).filter(n=>Array.isArray(n)&&n.length>=2).map(([n,r])=>[Wt(+n),Wt(+r)]);return t.length<2?n=>Wt(n):(t[0][0]!==0&&t.unshift([0,0]),t[t.length-1][0]!==1&&t.push([1,1]),t.sort((n,r)=>n[0]-r[0]),function(n){const r=Wt(n);if(r<=t[0][0])return t[0][1];if(r>=t[t.length-1][0])return t[t.length-1][1];for(let i=0;i<t.length-1;i++){const[a,o]=t[i],[s,l]=t[i+1];if(r>=a&&r<=s){const c=s===a?0:(r-a)/(s-a);return Wt(o+c*(l-o))}}return Wt(r)})}catch{return n=>Wt(n)}}Xe("intentDebug",{DEBUG_INTENT_TUNING:Ib,setIntentTuningDebug:mE,storeIntentTuningFlag:hf,loadIntentTuningFlag:Lb},{exposeOnWindow:typeof window<"u",windowAliases:["setIntentTuningDebug"]});const Do={linear:{id:"linear",label:"Linear",description:"Neutral contrast. No curve adjustment with 1:1 input-to-output mapping for unmodified tonal reproduction.",params:{},curveFunction:e=>Wt(e),displayOrder:1},soft:{id:"soft",label:"Gamma 0.85",description:"Lowers contrast. Gentle highlight compression that brightens shadows while preserving detail in bright areas. Ideal for maintaining shadow detail in high-contrast images.",params:{gamma:.85},curveFunction:e=>Da(e,.85),displayOrder:2},hard:{id:"hard",label:"Gamma 1.2",description:"Increases contrast. Mild shadow compression that darkens shadows while maintaining highlight detail. Useful for adding contrast to flat images.",params:{gamma:1.2},curveFunction:e=>Da(e,1.2),displayOrder:3},gamma16:{id:"gamma16",label:"Gamma 1.6",description:"Increases contrast. Moderate shadow compression providing balanced contrast enhancement between mild and strong gamma curves. Good for print workflows requiring moderate contrast.",params:{gamma:1.6},curveFunction:e=>Da(e,1.6),displayOrder:4},gamma18:{id:"gamma18",label:"Gamma 1.8",description:"Increases contrast. Strong shadow compression that darkens shadows significantly while preserving highlight detail. Useful for dramatic tonal effects.",params:{gamma:1.8},curveFunction:e=>Da(e,1.8),displayOrder:5},gamma20:{id:"gamma20",label:"Gamma 2.0",description:"Increases contrast. High contrast with pronounced shadow compression providing substantial tonal separation. Good for high-impact printing applications.",params:{gamma:2},curveFunction:e=>Da(e,2),displayOrder:6},gamma22:{id:"gamma22",label:"Gamma 2.2",description:"Increases contrast. Standard sRGB gamma correction providing traditional monitor-like contrast curve with substantial shadow compression. Common for display calibration.",params:{gamma:2.2},curveFunction:e=>Da(e,2.2),displayOrder:7},filmic:{id:"filmic",label:"Filmic (soft shoulder)",description:"Preserves contrast. Soft shoulder roll-off protects highlights from clipping while maintaining midtone contrast. Mimics film-like highlight handling for smooth tonal transitions.",params:{filmicGain:.55,shoulder:.35},curveFunction:e=>gE(e,.55,.35),displayOrder:8},popsgloss:{id:"popsgloss",label:"PoPS Gloss Curve",description:"Increases contrast. Prints on Paper Studios system gloss curve with gentle shadow compression and smooth highlight preservation. Optimized for photographic paper simulation.",params:{keyPoints:[{x:0,y:0},{x:10/255,y:4/255},{x:40/255,y:30/255},{x:125/255,y:123/255},{x:192/255,y:193/255},{x:223/255,y:223/255},{x:1,y:1}]},curveFunction:e=>ll([[0,0],[10/255,4/255],[40/255,30/255],[125/255,123/255],[192/255,193/255],[223/255,223/255],[1,1]])(e),displayOrder:9},popsmatte:{id:"popsmatte",label:"PoPS Matte Curve",description:"Increases contrast. Prints on Paper Studios system matte curve with more aggressive shadow compression than gloss variant. Designed for matte paper characteristics.",params:{keyPoints:[{x:0,y:0},{x:10/255,y:3/255},{x:28/255,y:14/255},{x:55/255,y:37/255},{x:90/255,y:79/255},{x:170/255,y:174/255},{x:1,y:1}]},curveFunction:e=>ll([[0,0],[10/255,3/255],[28/255,14/255],[55/255,37/255],[90/255,79/255],[170/255,174/255],[1,1]])(e),displayOrder:10},popsuncoated:{id:"popsuncoated",label:"PoPS Uncoated / Alt Process",description:"Increases contrast. Prints on Paper Studios system curve optimized for uncoated papers and alternative photographic processes. Features strong shadow compression with smooth highlight transitions.",params:{keyPoints:[{x:0,y:0},{x:28/255,y:9/255},{x:66/255,y:44/255},{x:112/255,y:100/255},{x:164/255,y:168/255},{x:221/255,y:223/255},{x:1,y:1}]},curveFunction:e=>ll([[0,0],[28/255,9/255],[66/255,44/255],[112/255,100/255],[164/255,168/255],[221/255,223/255],[1,1]])(e),displayOrder:11},popsuncoatedsofter:{id:"popsuncoatedsofter",label:"PoPS Uncoated / Alt Process (softer)",description:"Increases contrast. Prints on Paper Studios system softer variant for uncoated papers and alternative processes. Less aggressive shadow compression than the standard uncoated curve.",params:{keyPoints:[{x:0,y:0},{x:28/255,y:12/255},{x:66/255,y:47/255},{x:112/255,y:100/255},{x:164/255,y:168/255},{x:221/255,y:223/255},{x:1,y:1}]},curveFunction:e=>ll([[0,0],[28/255,12/255],[66/255,47/255],[112/255,100/255],[164/255,168/255],[221/255,223/255],[1,1]])(e),displayOrder:12}},ce=e=>Math.max(0,Math.min(1,e));function Vm(e,t){const n=1/Math.max(1e-6,t)-2;return e/(n*(1-e)+1)}function kb(e,t){return e<.5?.5*Vm(e*2,1-t):1-.5*Vm(2-2*e,1-t)}function bE(e,t,n){const r=kb(ce(e),ce(t)),i=1-Math.pow(1-r,1+ce(n));return ce(i)}function yE(e){const t=kb(ce(e),.55),r=1-Math.pow(1-t,1+.15);return ce(r)}function gf(e,t){const n=e.length;if(n<2||t<=e[0])return 0;if(t>=e[n-1])return n-2;let r=0,i=n-1;for(;i-r>1;){const a=r+i>>>1;e[a]<=t?r=a:i=a}return r}function Db(e,t){const n=e.length;if(n<2)return f=>t[0]||0;const r=new Array(n-1),i=new Array(n),a=new Array(n),o=new Array(n),s=new Array(n),l=new Array(n),c=new Array(n),u=new Array(n);for(let f=0;f<n-1;f++)r[f]=e[f+1]-e[f];const d=(t[1]-t[0])/r[0],p=(t[n-1]-t[n-2])/r[n-2];i[0]=3*((t[1]-t[0])/r[0]-d),i[n-1]=3*(p-(t[n-1]-t[n-2])/r[n-2]);for(let f=1;f<n-1;f++)i[f]=3/r[f]*(t[f+1]-t[f])-3/r[f-1]*(t[f]-t[f-1]);a[0]=2*r[0],o[0]=.5,s[0]=i[0]/a[0];for(let f=1;f<n-1;f++)a[f]=2*(e[f+1]-e[f-1])-r[f-1]*o[f-1],o[f]=r[f]/a[f],s[f]=(i[f]-r[f-1]*s[f-1])/a[f];a[n-1]=r[n-2]*(2-o[n-2]),s[n-1]=(i[n-1]-r[n-2]*s[n-2])/a[n-1],l[n-1]=s[n-1];for(let f=n-2;f>=0;f--)l[f]=s[f]-o[f]*l[f+1],c[f]=(t[f+1]-t[f])/r[f]-r[f]*(l[f+1]+2*l[f])/3,u[f]=(l[f+1]-l[f])/(3*r[f]);return f=>{if(f<=e[0])return t[0];if(f>=e[n-1])return t[n-1];const h=gf(e,f),g=f-e[h];return t[h]+c[h]*g+l[h]*g*g+u[h]*g*g*g}}function Pb(e,t,n=.5){const r=e.length;return r<2?i=>t[0]||0:i=>{if(i<=e[0])return t[0];if(i>=e[r-1])return t[r-1];const a=gf(e,i),o=t[Math.max(0,a-1)],s=t[a],l=t[Math.min(r-1,a+1)],c=t[Math.min(r-1,a+2)],u=(i-e[a])/(e[a+1]-e[a]),d=u*u,p=d*u,f=-n*p+2*n*d-n*u,h=(2-n)*p+(n-3)*d+1,g=(n-2)*p+(3-2*n)*d+n*u,b=n*p-n*d;return o*f+s*h+l*g+c*b}}function zr(e,t){const n=e.length;if(n<2)return o=>t[0]||0;const r=new Array(n),i=new Array(n-1),a=new Array(n-1);for(let o=0;o<n-1;o++)i[o]=e[o+1]-e[o],a[o]=(t[o+1]-t[o])/i[o];r[0]=a[0],r[n-1]=a[n-2];for(let o=1;o<n-1;o++)if(a[o-1]*a[o]<=0)r[o]=0;else{const s=2*i[o]+i[o-1],l=i[o]+2*i[o-1];r[o]=(s+l)/(s/a[o-1]+l/a[o])}return o=>{if(o<=e[0])return t[0];if(o>=e[n-1])return t[n-1];const s=gf(e,o),l=o-e[s],c=i[s],u=l/c,d=2*u*u*u-3*u*u+1,p=u*u*u-2*u*u+u,f=-2*u*u*u+3*u*u,h=u*u*u-u*u;return t[s]*d+c*r[s]*p+t[s+1]*f+c*r[s+1]*h}}function hi(e){const t=Number(e?.displayMax);return Number.isFinite(t)&&t>0?t:100}function SE(e,t){const n=hi(t);return Number.isFinite(e)?Math.max(0,Math.min(n,e)):0}function Qt(e,t){const n=hi(t);let r=Number(t?.chartHeight);const i=Number(t?.padding)||0,a=Number(t?.bottomPadding)||i,o=Number(t?.height)||0;(!Number.isFinite(r)||r<=0)&&(r=Math.max(0,o-i-a));const s=SE(e,t);return r<=0?o-a:o-a-r*(s/n)}function bf(e,t){const n=hi(t);let r=Number(t?.chartHeight);const i=Number(t?.padding)||0,a=Number(t?.bottomPadding)||i,o=Number(t?.height)||0;if((!Number.isFinite(r)||r<=0)&&(r=Math.max(0,o-i-a)),r<=0)return 0;const s=o-a-e;return Math.max(0,Math.min(n,s/r*n))}function nr(e,t){const n=Number(t?.leftPadding)||0,r=Number(t?.chartWidth)||0,i=Math.max(0,Math.min(100,e));return n+r*(i/100)}function xb(e,t){const n=Number(t?.leftPadding)||0,r=Number(t?.chartWidth)||0;if(r<=0)return 0;const i=e-n;return Math.max(0,Math.min(100,i/r*100))}function zd(e,t,n={}){const{points:r,geom:i,tolerance:a=10,values:o,maxValue:s=65535}=n||{};if(!Array.isArray(r)||!i)return null;const l=Number.isFinite(a)?Math.max(0,a):10,c=l*l,u=r.map((h,g)=>({point:h,ordinal:g+1})).sort((h,g)=>(h.point.input??0)-(g.point.input??0)),d=Array.isArray(o)&&o.length>0?o:null,p=Number.isFinite(s)&&s>0?s:65535,f=hi(i);for(let h=0;h<u.length;h++){const{point:g,ordinal:b}=u[h],S=Number(g?.input??0),E=nr(S,i);let y=Number(g?.output??0);if(d){const _=Math.max(0,Math.min(1,S/100))*(d.length-1),C=Math.floor(_),x=Math.min(d.length-1,C+1),P=_-C;y=((1-P)*d[C]+P*d[x])/p*100}const v=Math.max(0,Math.min(f,y)),A=Qt(v,i),w=e-E,M=t-A;if(w*w+M*M<=c)return{ordinal:b,point:g,canvasX:E,canvasY:A,percent:v}}return null}function vE(e={}){const{canvasX:t,canvasY:n,points:r,geom:i,tolerance:a,values:o,maxValue:s}=e||{};if(!Number.isFinite(t)||!Number.isFinite(n)||!Array.isArray(r)||r.length===0||!i)return null;const l=zd(t,n,{points:r,geom:i,tolerance:a,values:o,maxValue:s});return l?{ordinal:l.ordinal,point:l.point,canvasX:l.canvasX,canvasY:l.canvasY,percent:l.percent}:null}function EE(e,t,n={}){const{points:r,ordinal:i,geom:a,minGap:o=.01}=n||{},s=Math.max(0,Math.min(100,Number.isFinite(e)?e:0)),l=hi(a),c=Math.max(0,Math.min(l,Number.isFinite(t)?t:0));if(!Array.isArray(r)||!Number.isFinite(i)||i<1)return{inputPercent:s,outputPercent:c};const u=r.map(g=>({input:Number(g?.input??0)})).sort((g,b)=>g.input-b.input),d=Math.min(u.length-1,i-1);let p=0,f=100;return d>0&&(p=u[d-1].input+o),d<u.length-1&&(f=u[d+1].input-o),{inputPercent:Math.max(p,Math.min(f,s)),outputPercent:c}}function wE(){const e=getComputedStyle(document.documentElement);return{grid:(e.getPropertyValue("--chart-grid")||"#e5e7eb").trim(),axis:(e.getPropertyValue("--chart-axis")||"#374151").trim(),text:(e.getPropertyValue("--chart-text")||"#000000").trim(),helper:(e.getPropertyValue("--chart-helper-border")||"#9ca3af").trim(),border:(e.getPropertyValue("--border")||"#e5e7eb").trim(),bg:(e.getPropertyValue("--chart-bg")||"transparent").trim()}}function Bb(e,t=100,n=1){const r=e.width,i=e.height,a=Number.isFinite(n)&&n>0?n:1,o=Math.min(Math.max(a,1),3),s=12,l=40,c=36,u=36,d=26,p=34,f=s*o,h=l*o,g=(c+d)*o,b=(u+p)*o,S=Math.max(0,r-g-b),E=Math.max(0,i-f-h);return{width:r,height:i,padding:f,bottomPadding:h,leftPadding:g,rightPadding:b,chartWidth:S,chartHeight:E,displayMax:t,dpr:o}}function CE(e,t,n){e.strokeStyle=n.grid,e.lineWidth=1;const r=t.bottomPadding||t.padding;for(let s=0;s<=10;s++){const l=t.leftPadding+s*t.chartWidth/10;e.beginPath(),e.moveTo(l,t.padding),e.lineTo(l,t.height-r),e.stroke()}const i=hi(t),a=i<=50?5:10,o=[];for(let s=0;s<=i;s+=a)o.push(Math.round(s*100)/100);o[o.length-1]!==i&&o.push(i),o.forEach(s=>{const l=Qt(s,t);e.beginPath(),e.moveTo(t.leftPadding,l),e.lineTo(t.leftPadding+t.chartWidth,l),e.stroke()})}class AE{constructor(){this.windowRef=typeof window<"u"?window:null}getWindow(){return typeof window<"u"&&(this.windowRef=window),this.windowRef}getLoadedQuadData(){const t=this.getWindow();return t&&t.loadedQuadData||null}setLoadedQuadData(t){const n=this.getWindow();n&&(n.loadedQuadData=t||null)}getEditModeFlag(){const t=this.getWindow();return!t||typeof t.EDIT_MODE_ENABLED>"u"?null:t.EDIT_MODE_ENABLED===!0}setEditModeFlag(t){const n=this.getWindow();n&&(n.EDIT_MODE_ENABLED=t===!0)}registerHelpers(t={}){const n=this.getWindow();n&&Object.entries(t).forEach(([r,i])=>{n[r]===void 0&&(n[r]=i)})}}let Fu=null;function Tb(){return Fu||(Fu=new AE),Fu}const _n=Object.freeze({DENSITY_SOLVER:"densitySolver",SIMPLE_SCALING:"simpleScaling"}),Ob="quadgen.correctionMethod.v1",Ud=new Set;function _b(e){return e===_n.DENSITY_SOLVER?_n.DENSITY_SOLVER:_n.SIMPLE_SCALING}function ME(){try{if(typeof localStorage>"u")return _n.SIMPLE_SCALING;const e=localStorage.getItem(Ob);return e?_b(e):_n.SIMPLE_SCALING}catch{return _n.SIMPLE_SCALING}}let Xi=ME();function LE(){try{typeof localStorage<"u"&&localStorage.setItem(Ob,Xi)}catch{}}function IE(e){Ud.forEach(t=>{try{t(e)}catch(n){console.warn("[correction-method] listener error:",n)}})}function Dc(){return Xi}function kE(e){const t=_b(e);return t===Xi||(Xi=t,LE(),IE(Xi)),Xi}function DE(e){return typeof e!="function"?()=>{}:(Ud.add(e),()=>{Ud.delete(e)})}const xs={BELL:"bell",MONOTONIC:"monotonic",FLAT:"flat",UNKNOWN:"unknown"},so=65535,PE={smoothingWindow:5,useSavitzkyGolay:!0,slopeTolerance:150/so,monotonicPositiveFraction:.9,monotonicRiseThreshold:.05,bellEndRatio:.35,bellMinProminence:.08,bellSlopeFraction:.78,bellMinPeakOffset:10,flatAmplitudeThreshold:.02};function $d(e){return!Number.isFinite(e)||e<=0?0:e>=1?1:e}function xE(e){return Array.isArray(e)?e.map(t=>{const n=Number(t);return!Number.isFinite(n)||n<0?0:n>so?so:n}):[]}function Nb(e){return e.map(t=>$d(t/so))}function BE(e){if(!Array.isArray(e)||e.length===0)return null;let t=2166136261;for(let n=0;n<e.length;n+=1)t^=Number(e[n])&65535,t=t*16777619>>>0;return t>>>0}function TE(e,t){if(!Array.isArray(e)||e.length===0)return[];const n=Math.max(1,Math.floor(t));if(n<=1)return e.slice();const r=Math.floor(n/2),i=new Array(e.length);for(let a=0;a<e.length;a++){let o=0,s=0;for(let l=a-r;l<=a+r;l++){const c=Math.min(e.length-1,Math.max(0,l));o+=e[c],s+=1}i[a]=o/s}return i}function OE(e){if(!Array.isArray(e)||e.length<5)return e.slice();const t=[-3/35,12/35,17/35,12/35,-3/35],n=new Array(e.length);for(let r=0;r<e.length;r++){let i=0;for(let a=-2;a<=2;a++){const o=Math.min(e.length-1,Math.max(0,r+a));i+=e[o]*t[a+2]}n[r]=i}return n}function _E(e){if(!Array.isArray(e)||e.length<2)return[];const t=new Array(e.length-1);for(let n=1;n<e.length;n++)t[n-1]=e[n]-e[n-1];return t}function NE(e,t){if(!Array.isArray(e)||e.length===0||!Number.isFinite(t))return null;const n=e[t];if(!Number.isFinite(n)||n<=0)return null;const r=n*.2;let i=t,a=t;for(;i>0&&e[i]>r;)i-=1;for(;a<e.length-1&&e[a]>r;)a+=1;const o=Math.max(0,t-i),s=Math.max(0,a-t),l=Math.max(0,a-i),c=e.length>1?e.length-1:null,u=d=>c?d/c*100:null;return{totalSamples:l,leftSamples:o,rightSamples:s,totalPercent:u(l),leftPercent:u(o),rightPercent:u(s)}}function FE(e,t){if(!Array.isArray(e)||e.length<10||!Number.isFinite(t))return null;const n=e[t];if(!Number.isFinite(n)||n<=0)return null;const r=n*.5;let i=t,a=t;for(;i>0&&e[i]>r;)i--;for(;a<e.length-1&&e[a]>r;)a++;const s=(a-i)/2.355;if(s<1)return null;let l=0,c=0;const u=e.reduce((p,f)=>p+f,0)/e.length;for(let p=0;p<e.length;p++){const f=p-t,h=n*Math.exp(-(f*f)/(2*s*s));l+=(e[p]-h)**2,c+=(e[p]-u)**2}const d=c>0?1-l/c:0;return Math.max(0,Math.min(1,d))}function GE(e){const t=xE(e),n=t.length,r=BE(t),i=n>0?t.reduce((d,p,f,h)=>p>h[d]?f:d,0):null,a=i!=null?t[i]:null,o=i!=null?NE(t,i):null,s=n>0?t[0]:null,l=n>0?t[n-1]:null,c=Nb(t),u=i!=null?FE(c,i):null;return{classification:xs.UNKNOWN,confidence:0,startValue:s,endValue:l,peakIndex:i,peakValue:a,peakInputPercent:i!=null&&n>1?i/(n-1)*100:null,apexSampleIndex:i,apexInputPercent:i!=null&&n>1?i/(n-1)*100:null,apexOutputPercent:a!=null?$d(a/so)*100:null,apexSpanSamples:o?.totalSamples??null,apexSpanPercent:o?.totalPercent??null,apexSpanLeftSamples:o?.leftSamples??null,apexSpanRightSamples:o?.rightSamples??null,apexSpanLeftPercent:o?.leftPercent??null,apexSpanRightPercent:o?.rightPercent??null,asymmetryRatio:o?.leftSamples&&o?.rightSamples?o.leftSamples/o.rightSamples:null,isLeftSkewed:(o?.leftSamples??0)<(o?.rightSamples??0)*.8,isRightSkewed:(o?.leftSamples??0)>(o?.rightSamples??0)*1.2,gaussianFitQuality:u,sampleCount:n,normalizedPeak:a!=null?$d(a/so):null,reasons:[],curveHash:r,sanitized:t}}function RE(e,t,n){if(!Array.isArray(t)||t.length===0)return e.reasons.push("no_samples"),!1;const r=Math.min(...t),a=Math.max(...t)-r;return a<=n.flatAmplitudeThreshold?(e.classification=xs.FLAT,e.confidence=1-a/n.flatAmplitudeThreshold,e.reasons.push("flat_amplitude"),!0):!1}function zE(e,t,n,r){const i=t.length;if(i<r.bellMinPeakOffset*2+3)return e.reasons.push("bell_too_short"),!1;const a=e.peakIndex??Math.floor(i/2);if(a<r.bellMinPeakOffset||a>i-1-r.bellMinPeakOffset)return e.reasons.push("peak_near_edge"),!1;const o=t[a],s=Math.min(...t);if(o-s<r.bellMinProminence)return e.reasons.push("bell_low_prominence"),!1;const c=t[0]<=o*r.bellEndRatio+r.slopeTolerance,u=t[i-1]<=o*r.bellEndRatio+r.slopeTolerance;if(!c||!u)return e.reasons.push("ends_not_low"),!1;const d=n.slice(0,Math.max(1,a)),p=n.slice(Math.max(0,a));if(d.length===0||p.length===0)return e.reasons.push("insufficient_slopes"),!1;const f=d.filter(g=>g>=-r.slopeTolerance).length/d.length,h=p.filter(g=>g<=r.slopeTolerance).length/p.length;return f<r.bellSlopeFraction||h<r.bellSlopeFraction?(e.reasons.push("bell_slope_mismatch"),!1):(e.classification=xs.BELL,e.confidence=Math.min(f,h),e.reasons.push("bell_detected"),!0)}function UE(e,t,n,r){if(!Array.isArray(n)||n.length===0)return e.reasons.push("no_slopes"),!1;const i=n.filter(o=>o>=-r.slopeTolerance).length/n.length,a=t[t.length-1]-t[0];return i>=r.monotonicPositiveFraction&&a>=r.monotonicRiseThreshold?(e.classification=xs.MONOTONIC,e.confidence=Math.min(1,i),e.reasons.push("monotonic_detected"),!0):(e.reasons.push("monotonic_threshold_not_met"),!1)}function Hm(e,t={}){const n={...PE,...t||{}},r=GE(e);if(r.sampleCount<3)return r.reasons.push("insufficient_samples"),delete r.sanitized,r;const i=Nb(r.sanitized),a=n.useSavitzkyGolay?OE(i):TE(i,n.smoothingWindow),o=_E(a);return RE(r,i,n)||zE(r,i,o,n)?(delete r.sanitized,r):(UE(r,i,o,n),delete r.sanitized,r)}const Fb={leftFactor:1,rightFactor:1,linked:!0,baselineHash:null,lastCurveHash:null,baselineCurve:null};function Pc(e){return!e||typeof e!="object"?null:((!e.bellCurveShift||typeof e.bellCurveShift!="object")&&(e.bellCurveShift={}),e.bellCurveShift)}function yf(e){return Pc(e)}function Bs(e){return e?(!e.widthScale||typeof e.widthScale!="object"?e.widthScale={...Fb}:(Number.isFinite(e.widthScale.leftFactor)||(e.widthScale.leftFactor=1),Number.isFinite(e.widthScale.rightFactor)||(e.widthScale.rightFactor=1),typeof e.widthScale.linked!="boolean"&&(e.widthScale.linked=!0),e.widthScale.baselineHash==null&&(e.widthScale.baselineHash=null),e.widthScale.lastCurveHash==null&&(e.widthScale.lastCurveHash=null),Array.isArray(e.widthScale.baselineCurve)||(e.widthScale.baselineCurve=null)),e.widthScale):null}function Vd(e,t,n={}){const r=Ts(e,t,{create:!0});if(!r)return null;const i=Bs(r);return i?(Number.isFinite(n.leftFactor)&&(i.leftFactor=n.leftFactor),Number.isFinite(n.rightFactor)&&(i.rightFactor=n.rightFactor),typeof n.linked=="boolean"&&(i.linked=n.linked),Array.isArray(n.baselineCurve)&&(i.baselineCurve=n.baselineCurve.slice()),n.invalidateBaseline&&(i.baselineHash=null,i.lastCurveHash=null,i.baselineCurve=null),Gb(i)):null}function Ts(e,t,{create:n=!1}={}){if(!t)return null;const r=Pc(e);if(!r)return null;!r[t]&&n&&(r[t]={});const i=r[t]||null;return i&&n&&Bs(i),i}function $E(e,t){if(!t)return;const n=Pc(e);!n||!n[t]||delete n[t]}function VE(e){return e?{baselineInputPercent:Number.isFinite(e.baselineInputPercent)?e.baselineInputPercent:null,baselineOutputPercent:Number.isFinite(e.baselineOutputPercent)?e.baselineOutputPercent:null,latestInputPercent:Number.isFinite(e.latestInputPercent)?e.latestInputPercent:null,latestOutputPercent:Number.isFinite(e.latestOutputPercent)?e.latestOutputPercent:null,offsetPercent:Number.isFinite(e.offsetPercent)?e.offsetPercent:0,requestedInputPercent:Number.isFinite(e.requestedInputPercent)?e.requestedInputPercent:null,lastClassificationTs:e.lastClassificationTs||null,lastRequestedTs:e.lastRequestedTs||null}:null}function Gb(e){return e?{leftFactor:Number.isFinite(e.leftFactor)?e.leftFactor:1,rightFactor:Number.isFinite(e.rightFactor)?e.rightFactor:1,linked:typeof e.linked=="boolean"?e.linked:!0,baselineHash:e.baselineHash??null,lastCurveHash:e.lastCurveHash??null}:{...Fb}}function HE(e,t){if(!(!e||!Number.isFinite(t))){if(e.baselineHash==null){e.baselineHash=t,e.lastCurveHash=t;return}e.lastCurveHash!==t&&(e.lastCurveHash=t,e.baselineHash=t)}}function qm(e,t){const n=Ts(e,t,{create:!1});if(!n)return null;const r=Bs(n);return!r?.baselineCurve||!Array.isArray(r.baselineCurve)?null:r.baselineCurve}function qE(e,t,n){if(!Array.isArray(n))return null;const r=Ts(e,t,{create:!0});if(!r)return null;const i=Bs(r);return i.baselineCurve=n.slice(),i.baselineCurve}function jE(e,t,n){const r=Pc(e);if(!r)return null;if(!n||n.classification!=="bell")return r[t]&&delete r[t],null;const i=Number.isFinite(n.apexInputPercent)?n.apexInputPercent:Number.isFinite(n.peakInputPercent)?n.peakInputPercent:null,a=Number.isFinite(n.apexOutputPercent)?n.apexOutputPercent:Number.isFinite(n.normalizedPeak)?n.normalizedPeak*100:null,o=Ts(e,t,{create:!0});o&&(!Number.isFinite(o.baselineInputPercent)&&Number.isFinite(i)&&(o.baselineInputPercent=i),!Number.isFinite(o.baselineOutputPercent)&&Number.isFinite(a)&&(o.baselineOutputPercent=a),o.latestInputPercent=i,o.latestOutputPercent=a,Number.isFinite(o.baselineInputPercent)&&Number.isFinite(i)?o.offsetPercent=i-o.baselineInputPercent:o.offsetPercent=0,!Number.isFinite(o.requestedInputPercent)&&Number.isFinite(i)&&(o.requestedInputPercent=i),o.lastClassificationTs=Date.now());const s=Bs(o);return HE(s,n?.curveHash),{shift:VE(o),widthScale:Gb(s)}}function WE(e,t,n){if(!Number.isFinite(n))return null;const r=Ts(e,t,{create:!0});return r?(r.requestedInputPercent=n,r.lastRequestedTs=Date.now(),r):null}const Os=Tb();typeof window<"u"&&(typeof window.__USE_SCALING_COORDINATOR>"u"&&(window.__USE_SCALING_COORDINATOR=!1),typeof window.__USE_SCALING_STATE>"u"&&(window.__USE_SCALING_STATE=!0));const dn={P400:{name:"Epson P400",channels:["K","C","M","Y","LC","LM"]},P800:{name:"Epson P600-P800",channels:["K","C","M","Y","LC","LM","LK","LLK"]},"3880-7880":{name:"Epson 3880-7880",channels:["K","C","M","Y","LC","LM","LK","LLK"]},"x800-x890":{name:"Epson x800-x890",channels:["K","C","M","Y","LC","LM","LK","LLK"]},x900:{name:"Epson x900",channels:["K","C","M","Y","LC","LM","LK","LLK","OR","GR"]},"P4-6-8000":{name:"Epson P4-6-8000",channels:["K","C","M","Y","LC","LM","LK","LLK"]},"P5-7-9000":{name:"Epson P5-7-9000",channels:["K","C","M","Y","LC","LM","LK","LLK","OR","GR"]},P700P900:{name:"Epson P700-P900",channels:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},ni={K:"#111111",C:"#00AEEF",M:"#EC008C",Y:"#FFF200",LC:"#8FD3FF",LM:"#FF9AD5",LK:"#777777",LLK:"#BBBBBB",OR:"#FF7F00",GR:"#00A651",V:"#7F00FF",MK:"#000000"},ve=65535,m={rows:null,printerSelect:null,channelInfo:null,printerDescription:null,downloadBtn:null,previewFull:null,status:null,inkChart:null,chartCursorTooltip:null,chartZoomInBtn:null,chartZoomOutBtn:null,snapshotFlagOverlay:null,filenameInput:null,linearizationFile:null,scaleAllInput:null,loadQuadBtn:null,quadFile:null,referenceQuadFile:null,loadReferenceQuadBtn:null,disabledChannelsCompact:null,disabledChannelsRow:null,globalLinearizationBtn:null,globalLinearizationHint:null,globalLinearizationToggle:null,autoWhiteLimitToggle:null,autoBlackLimitToggle:null,autoLimitDebugPanel:null,autoLimitInputLimitProximity:null,autoLimitInputSlopeFactor:null,autoLimitInputSustain:null,autoLimitInputMinWidth:null,autoLimitInputBlackShoulder:null,autoLimitInputWhiteToe:null,autoLimitInputFallback:null,autoLimitApplyBtn:null,autoLimitRecalcBtn:null,autoLimitResetBtn:null,curveSmoothingMethod:null,catmullTension:null,catmullTensionContainer:null,smoothingSlider:null,smoothingValue:null,smoothingWarning:null,kpSimplifierContainer:null,correctionGainSlider:null,correctionGainInput:null,correctionGainValue:null,intentTuningPanel:null,tuningInterpolationSelect:null,tuningSmoothingPercent:null,tuningSmoothingLabel:null,tuningSmoothingAlgorithm:null,tuningPostPasses:null,tuningPostPercent:null,tuningPostLabel:null,tuningPostAlgorithm:null,tuningNeighbors:null,tuningSigmaFloor:null,tuningApplyBtn:null,tuningRestoreBtn:null,editModeToggle:null,editModeToggleBtn:null,editModeLabel:null,editChannelSelect:null,editChannelPrev:null,editChannelNext:null,editKeyPointsContainer:null,editPanelBody:null,editChannelState:null,editPointIndex:null,editPointLeft:null,editPointRight:null,editXYInput:null,editDeleteBtn:null,editRecomputeBtn:null,editNudgeXPos:null,editNudgeXNeg:null,editNudgeYUp:null,editNudgeYDown:null,editSmoothingSlider:null,editSmoothingValue:null,editMaxPoints:null,editMaxError:null,editDisabledHint:null,editBellShiftContainer:null,editBellShiftInput:null,editBellShiftDec:null,editBellShiftInc:null,editBellWidthContainer:null,bellWidthLeftInput:null,bellWidthRightInput:null,bellWidthLeftDec:null,bellWidthLeftInc:null,bellWidthRightDec:null,bellWidthRightInc:null,bellWidthLinkToggle:null,bellWidthResetBtn:null,chatMessages:null,chatInput:null,sendChatBtn:null,clearChatBtn:null,labTechIcon:null,sendMessageBtnCompact:null,aiInputCompact:null,aiChevron:null,aiCompactBar:null,aiContent:null,aiInput:null,aiInputCompact:null,aiLabelToggle:null,aiShowStatusToggle:null,aiStatus:null,aiStatusIcon:null,aiToggle:null,applyIntentBtn:null,applyIntentToQuadBtn:null,intentModal:null,intentContent:null,intentPresetSelect:null,intentImportBtn:null,intentImportFile:null,intentPasteArea:null,cancelIntentBtn:null,resetIntentBtn:null,closeIntentModal:null,contrastIntentSelect:null,intentTuningPanel:null,tuningApplyBtn:null,tuningRestoreBtn:null,autoLimitApplyBtn:null,autoLimitRecalcBtn:null,autoLimitResetBtn:null,autoLimitInputLimitProximity:null,autoLimitInputSlopeFactor:null,autoLimitInputSustain:null,autoLimitInputMinWidth:null,autoLimitInputBlackShoulder:null,autoLimitInputWhiteToe:null,autoLimitInputFallback:null,helpBtn:null,helpPopup:null,helpContent:null,closeHelpBtn:null,helpTabWorkflow:null,helpTabReadme:null,helpTabHistory:null,helpTabGlossary:null,editModeHelpBtn:null,editModeHelpPopup:null,globalCorrectionHelpBtn:null,globalCorrectionHelpPopup:null,closeGlobalCorrectionHelpBtn:null,intentHelpBtn:null,intentHelpPopup:null,closeIntentHelpBtn:null,intentHelpContent:null,undoBtn:null,redoBtn:null,globalLinearizationBtn:null,globalLinearizationDetails:null,globalLinearizationFilename:null,globalLinearizationInfo:null,revertGlobalToMeasurementBtn:null,labDensityToggle:null,labSmoothingSlider:null,labSmoothingValue:null,plotSmoothingSlider:null,plotSmoothingValue:null,appVersion:null,helpAppVersion:null,sessionStatus:null,usageCounter:null,pageTitle:null,themeToggle:null,optionsBtn:null,optionsModal:null,optionsContent:null,closeOptionsBtn:null,correctionMethodRadios:null,smartPointDragToggle:null,correctionOverlayToggle:null,labSpotMarkersToggle:null,lightBlockingOverlayToggle:null,inkLoadOverlayToggle:null,inkLoadThresholdInput:null,compositeWeightingSelect:null,compositeDebugToggle:null,autoRaiseInkToggle:null,redistributionSmoothingToggle:null,lstarModal:null,manualLstarBtn:null,addLstarInput:null,removeLstarInput:null,lstarInputs:null,lstarCountInput:null,lstarValidation:null,generateFromLstar:null,cancelLstar:null,closeLstarModal:null,saveLstarTxt:null,manualLstarDensityToggle:null,notesToggle:null,notesChevron:null,notesContent:null,userNotes:null};function KE(){m.rows=document.getElementById("rows"),m.printerSelect=document.getElementById("printerSelect"),m.channelInfo=document.getElementById("channelInfo"),m.printerDescription=document.getElementById("printerDescription"),m.downloadBtn=document.getElementById("downloadBtn"),m.previewFull=document.getElementById("previewFull"),m.status=document.getElementById("status"),m.inkChart=document.getElementById("inkChart"),m.snapshotFlagOverlay=document.getElementById("snapshotFlagOverlay"),m.chartCursorTooltip=document.getElementById("chartCursorTooltip"),m.chartZoomInBtn=document.getElementById("chartZoomInBtn"),m.chartZoomOutBtn=document.getElementById("chartZoomOutBtn"),m.filenameInput=document.getElementById("filenameInput"),m.linearizationFile=document.getElementById("linearizationFile"),m.scaleAllInput=document.getElementById("scaleAllInput"),m.loadQuadBtn=document.getElementById("loadQuadBtn"),m.quadFile=document.getElementById("quadFile"),m.referenceQuadFile=document.getElementById("referenceQuadFile"),m.loadReferenceQuadBtn=document.getElementById("loadReferenceQuadBtn"),m.disabledChannelsCompact=document.getElementById("disabledChannelsCompact"),m.disabledChannelsRow=document.getElementById("disabledChannelsRow"),m.globalLinearizationBtn=document.getElementById("globalLinearizationBtn"),m.globalLinearizationHint=document.getElementById("globalLinearizationHint"),m.globalLinearizationToggle=document.getElementById("globalLinearizationToggle"),m.labDensityToggle=document.getElementById("labDensityModeToggle"),m.labSmoothingSlider=document.getElementById("labSmoothingPercentSlider"),m.labSmoothingValue=document.getElementById("labSmoothingPercentValue"),m.plotSmoothingSlider=document.getElementById("plotSmoothingPercentSlider"),m.plotSmoothingValue=document.getElementById("plotSmoothingPercentValue"),m.autoWhiteLimitToggle=document.getElementById("autoWhiteLimitToggle"),m.autoBlackLimitToggle=document.getElementById("autoBlackLimitToggle"),m.autoLimitDebugPanel=document.getElementById("autoLimitDebugPanel"),m.chatMessages=document.getElementById("chatMessages"),m.chatInput=document.getElementById("chatInput"),m.sendChatBtn=document.getElementById("sendChatBtn"),m.clearChatBtn=document.getElementById("clearChatBtn"),m.labTechIcon=document.getElementById("labTechIcon"),m.sendMessageBtnCompact=document.getElementById("sendMessageBtnCompact"),m.aiInputCompact=document.getElementById("aiInputCompact"),m.aiChevron=document.getElementById("aiChevron"),m.aiCompactBar=document.getElementById("aiCompactBar"),m.aiContent=document.getElementById("aiContent"),m.aiInput=document.getElementById("aiInput"),m.aiInputCompact=document.getElementById("aiInputCompact"),m.aiLabelToggle=document.getElementById("aiLabelToggle"),m.aiShowStatusToggle=document.getElementById("aiShowStatusToggle"),m.aiStatus=document.getElementById("aiStatus"),m.aiStatusIcon=document.getElementById("aiStatusIcon"),m.aiToggle=document.getElementById("aiToggle"),m.applyIntentBtn=document.getElementById("applyIntentBtn"),m.applyIntentToQuadBtn=document.getElementById("applyIntentToQuadBtn"),m.intentModal=document.getElementById("intentModal"),m.intentContent=document.getElementById("intentContent"),m.intentPresetSelect=document.getElementById("intentPresetSelect"),m.intentImportBtn=document.getElementById("intentImportBtn"),m.intentImportFile=document.getElementById("intentImportFile"),m.intentPasteArea=document.getElementById("intentPasteArea"),m.cancelIntentBtn=document.getElementById("cancelIntentBtn"),m.resetIntentBtn=document.getElementById("resetIntentBtn"),m.closeIntentModal=document.getElementById("closeIntentModal"),m.contrastIntentSelect=document.getElementById("contrastIntentSelect"),m.intentTuningPanel=document.getElementById("intentTuningPanel"),m.tuningApplyBtn=document.getElementById("tuningApplyBtn"),m.tuningRestoreBtn=document.getElementById("tuningRestoreBtn"),m.autoLimitApplyBtn=document.getElementById("autoLimitApplyBtn"),m.autoLimitRecalcBtn=document.getElementById("autoLimitRecalcBtn"),m.autoLimitResetBtn=document.getElementById("autoLimitResetBtn"),m.autoLimitInputLimitProximity=document.getElementById("autoLimitInputLimitProximity"),m.autoLimitInputSlopeFactor=document.getElementById("autoLimitInputSlopeFactor"),m.autoLimitInputSustain=document.getElementById("autoLimitInputSustain"),m.autoLimitInputMinWidth=document.getElementById("autoLimitInputMinWidth"),m.autoLimitInputBlackShoulder=document.getElementById("autoLimitInputBlackShoulder"),m.autoLimitInputWhiteToe=document.getElementById("autoLimitInputWhiteToe"),m.autoLimitInputFallback=document.getElementById("autoLimitInputFallback"),m.editModeToggle=document.getElementById("editModeToggle"),m.editModeToggleBtn=document.getElementById("editModeToggleBtn"),m.editModeLabel=document.getElementById("editModeLabel"),m.editChannelSelect=document.getElementById("editChannelSelect"),m.editChannelPrev=document.getElementById("editChannelPrev"),m.editChannelNext=document.getElementById("editChannelNext"),m.editPanelBody=document.getElementById("editPanelBody"),m.editChannelState=document.getElementById("editChannelState"),m.editPointIndex=document.getElementById("editPointIndex"),m.editPointLeft=document.getElementById("editPointLeft"),m.editPointRight=document.getElementById("editPointRight"),m.editXYInput=document.getElementById("editXYInput"),m.editDeleteBtn=document.getElementById("editDeleteBtn"),m.editRecomputeBtn=document.getElementById("editRecomputeBtn"),m.editNudgeXPos=document.getElementById("editNudgeXPos"),m.editNudgeXNeg=document.getElementById("editNudgeXNeg"),m.editNudgeYUp=document.getElementById("editNudgeYUp"),m.editNudgeYDown=document.getElementById("editNudgeYDown"),m.editSmoothingSlider=document.getElementById("editSmoothingSlider"),m.editSmoothingValue=document.getElementById("editSmoothingValue"),m.editMaxPoints=document.getElementById("editMaxPoints"),m.editMaxError=document.getElementById("editMaxError"),m.editDisabledHint=document.getElementById("editDisabledHint"),m.editBellShiftContainer=document.getElementById("editBellShiftContainer"),m.editBellShiftInput=document.getElementById("editBellShiftInput"),m.editBellShiftDec=document.getElementById("editBellShiftDec"),m.editBellShiftInc=document.getElementById("editBellShiftInc"),m.editBellWidthContainer=document.getElementById("editBellWidthContainer"),m.bellWidthLeftInput=document.getElementById("bellWidthLeftInput"),m.bellWidthRightInput=document.getElementById("bellWidthRightInput"),m.bellWidthLeftDec=document.getElementById("bellWidthLeftDec"),m.bellWidthLeftInc=document.getElementById("bellWidthLeftInc"),m.bellWidthRightDec=document.getElementById("bellWidthRightDec"),m.bellWidthRightInc=document.getElementById("bellWidthRightInc"),m.bellWidthLinkToggle=document.getElementById("bellWidthLinkToggle"),m.bellWidthResetBtn=document.getElementById("bellWidthResetBtn"),m.helpBtn=document.getElementById("helpBtn"),m.helpPopup=document.getElementById("helpPopup"),m.helpContent=document.getElementById("helpContent"),m.closeHelpBtn=document.getElementById("closeHelpBtn"),m.helpTabWorkflow=document.getElementById("helpTabWorkflow"),m.helpTabReadme=document.getElementById("helpTabReadme"),m.helpTabHistory=document.getElementById("helpTabHistory"),m.helpTabGlossary=document.getElementById("helpTabGlossary"),m.editModeHelpBtn=document.getElementById("editModeHelpBtn"),m.editModeHelpPopup=document.getElementById("editModeHelpPopup"),m.globalCorrectionHelpBtn=document.getElementById("globalCorrectionHelpBtn"),m.globalCorrectionHelpPopup=document.getElementById("globalCorrectionHelpPopup"),m.closeGlobalCorrectionHelpBtn=document.getElementById("closeGlobalCorrectionHelpBtn"),m.intentHelpBtn=document.getElementById("intentHelpBtn"),m.intentHelpPopup=document.getElementById("intentHelpPopup"),m.closeIntentHelpBtn=document.getElementById("closeIntentHelpBtn"),m.intentHelpContent=document.getElementById("intentHelpContent"),m.undoBtn=document.getElementById("undoBtn"),m.redoBtn=document.getElementById("redoBtn"),m.globalLinearizationDetails=document.getElementById("globalLinearizationDetails"),m.globalLinearizationFilename=document.getElementById("globalLinearizationFilename"),m.globalLinearizationInfo=document.getElementById("globalLinearizationInfo"),m.revertGlobalToMeasurementBtn=document.getElementById("revertGlobalToMeasurementBtn"),m.appVersion=document.getElementById("appVersion"),m.helpAppVersion=document.getElementById("helpAppVersion"),m.sessionStatus=document.getElementById("sessionStatus"),m.usageCounter=document.getElementById("usageCounter"),m.pageTitle=document.getElementById("pageTitle"),m.themeToggle=document.getElementById("themeToggle"),m.optionsBtn=document.getElementById("optionsBtn"),m.optionsModal=document.getElementById("optionsModal"),m.optionsContent=document.getElementById("optionsContent"),m.closeOptionsBtn=document.getElementById("closeOptionsBtn"),m.correctionMethodRadios=Array.from(document.querySelectorAll('input[name="correctionMethod"]')),m.correctionGainSlider=document.getElementById("correctionGainSlider"),m.correctionGainInput=document.getElementById("correctionGainInput"),m.correctionGainValue=document.getElementById("correctionGainValue"),m.smartPointDragToggle=document.getElementById("smartPointDragToggle"),m.correctionOverlayToggle=document.getElementById("correctionOverlayToggle"),m.labSpotMarkersToggle=document.getElementById("labSpotMarkersToggle"),m.lightBlockingOverlayToggle=document.getElementById("lightBlockingOverlayToggle"),m.inkLoadOverlayToggle=document.getElementById("inkLoadOverlayToggle"),m.inkLoadThresholdInput=document.getElementById("inkLoadThresholdInput"),m.compositeWeightingSelect=document.getElementById("compositeWeightingSelect"),m.compositeDebugToggle=document.getElementById("compositeDebugToggle"),m.autoRaiseInkToggle=document.getElementById("autoRaiseInkToggle"),m.redistributionSmoothingToggle=document.getElementById("redistributionSmoothingToggle"),m.lstarModal=document.getElementById("lstarModal"),m.manualLstarBtn=document.getElementById("manualLstarBtn"),m.addLstarInput=document.getElementById("addLstarInput"),m.removeLstarInput=document.getElementById("removeLstarInput"),m.lstarInputs=document.getElementById("lstarInputs"),m.lstarCountInput=document.getElementById("lstarCountInput"),m.lstarValidation=document.getElementById("lstarValidation"),m.generateFromLstar=document.getElementById("generateFromLstar"),m.cancelLstar=document.getElementById("cancelLstar"),m.closeLstarModal=document.getElementById("closeLstarModal"),m.saveLstarTxt=document.getElementById("saveLstarTxt"),m.manualLstarDensityToggle=document.getElementById("manualLstarDensityToggle"),m.notesToggle=document.getElementById("notesToggle"),m.notesChevron=document.getElementById("notesChevron"),m.notesContent=document.getElementById("notesContent"),m.userNotes=document.getElementById("userNotes"),m.curveSmoothingMethod=document.getElementById("curveSmoothingMethod"),m.catmullTension=document.getElementById("catmullTension"),m.catmullTensionContainer=document.getElementById("catmullTensionContainer"),m.smoothingSlider=document.getElementById("smoothingSlider"),m.smoothingValue=document.getElementById("smoothingValue"),m.smoothingWarning=document.getElementById("smoothingWarning"),m.kpSimplifierContainer=document.getElementById("kpSimplifierContainer"),m.editKeyPointsContainer=document.getElementById("editKeyPointsContainer"),m.tuningInterpolationSelect=document.getElementById("tuningInterpolationSelect"),m.tuningSmoothingPercent=document.getElementById("tuningSmoothingPercent"),m.tuningSmoothingLabel=document.getElementById("tuningSmoothingLabel"),m.tuningSmoothingAlgorithm=document.getElementById("tuningSmoothingAlgorithm"),m.tuningPostPasses=document.getElementById("tuningPostPasses"),m.tuningPostPercent=document.getElementById("tuningPostPercent"),m.tuningPostLabel=document.getElementById("tuningPostLabel"),m.tuningPostAlgorithm=document.getElementById("tuningPostAlgorithm"),m.tuningNeighbors=document.getElementById("tuningNeighbors"),m.tuningSigmaFloor=document.getElementById("tuningSigmaFloor"),typeof window<"u"&&(window.elements=m),console.log("âœ… DOM elements initialized")}function lt(){const e=m.printerSelect||document.getElementById("printerSelect");return e&&dn[e.value]||dn.P700P900}function YE(){try{const e=lt(),t={};return m.rows&&Array.from(m.rows.children).filter(r=>r.id!=="noChannelsRow").forEach(r=>{const i=r.querySelector("td span span:nth-child(2)")?.textContent?.trim(),a=r.querySelector(".percent-input"),o=r.querySelector(".end-input");i&&(t[i]={percentage:a&&parseFloat(a.value)||0,endValue:o&&parseInt(o.value)||0,enabled:(a&&parseFloat(a.value)||0)>0})}),{success:!0,data:{printer:e,channels:t,filename:m.filenameInput?.value||"untitled.quad"}}}catch(e){return console.warn("Error getting current state:",e),{success:!1,message:e.message,data:{printer:dn.P700P900,channels:{},filename:"untitled.quad"}}}}const Hd=new Set,qd=new Set,ye={loadedQuadData:null,linearizationData:null,linearizationApplied:!1,perChannelLinearization:{},referenceQuadData:null,chartZoomIndex:9,overlayAutoToggledOff:!1,showCorrectionOverlay:!0,showLabSpotMarkers:!1,showLightBlockingOverlay:!1,showInkLoadOverlay:!1,inkLoadThreshold:25,plotSmoothingPercent:0,correctionMethod:Dc(),correctionGain:1,editMode:!1,selectedChannel:null,debugLogs:!1,debugAI:!1};function Po(e,t=null){if(!e||typeof e!="object")return null;(!e.channelShapeMeta||typeof e.channelShapeMeta!="object")&&(e.channelShapeMeta={}),yf(e);const n=(i,a)=>{const o=jE(e,i,a);if(o?.shift){const s={...o.shift,shiftedApexInputPercent:Number.isFinite(o.shift.latestInputPercent)?o.shift.latestInputPercent:o.shift.baselineInputPercent,shiftedApexOutputPercent:Number.isFinite(o.shift.latestOutputPercent)?o.shift.latestOutputPercent:o.shift.baselineOutputPercent};a.bellShift=s,a.bellWidthScale=o.widthScale||null}else a.bellShift=null,a.bellWidthScale=null;return a},r=e.curves&&typeof e.curves=="object"?e.curves:{};if(t){const i=r[t],a=Hm(Array.isArray(i)?i:[]);return e.channelShapeMeta[t]=n(t,a),e.channelShapeMeta[t]}return Object.keys(r).forEach(i=>{const a=r[i],o=Hm(Array.isArray(a)?a:[]);e.channelShapeMeta[i]=n(i,o)}),Object.keys(e.channelShapeMeta).forEach(i=>{Object.prototype.hasOwnProperty.call(r,i)||(delete e.channelShapeMeta[i],$E(e,i))}),e.channelShapeMeta}try{if(typeof localStorage<"u"){if(localStorage.getItem("quadgen.showLabSpotMarkers")==="1"&&(ye.showLabSpotMarkers=!0),localStorage.getItem("quadgen.correctionGain")!=null){const n=Number(localStorage.getItem("quadgen.correctionGain"));Number.isFinite(n)&&(ye.correctionGain=Math.max(0,Math.min(1,n)))}const e=localStorage.getItem("quadgen.inkLoadOverlayEnabled.v1");e==="true"?ye.showInkLoadOverlay=!0:e==="false"&&(ye.showInkLoadOverlay=!1);const t=localStorage.getItem("quadgen.inkLoadThreshold.v1");if(t!=null){const n=Number(t);if(Number.isFinite(n)){const r=Math.max(10,Math.min(400,Math.round(n)));ye.inkLoadThreshold=r}}}}catch{}function na(e){const t=ye.loadedQuadData;if(e&&typeof e=="object"){e.curves||(e.curves={}),e.sources||(e.sources={}),(!e.normalizeToEndChannels||typeof e.normalizeToEndChannels!="object")&&(e.normalizeToEndChannels={}),(!e.baselineEnd||typeof e.baselineEnd!="object")&&(e.baselineEnd={}),(!e.rebasedCurves||typeof e.rebasedCurves!="object")&&(e.rebasedCurves={},Object.keys(e.curves).forEach(i=>{const a=e.curves?.[i];Array.isArray(a)&&(e.rebasedCurves[i]=a.slice())})),(!e.rebasedSources||typeof e.rebasedSources!="object")&&(e.rebasedSources={},Object.keys(e.curves).forEach(i=>{const a=e.curves?.[i];Array.isArray(a)&&(e.rebasedSources[i]=a.slice())})),(!e.plotBaseCurves||typeof e.plotBaseCurves!="object")&&(e.plotBaseCurves={},Object.keys(e.curves||{}).forEach(i=>{const a=e.curves?.[i];Array.isArray(a)&&(e.plotBaseCurves[i]=a.slice())})),(!e.plotBaseCurvesBaseline||typeof e.plotBaseCurvesBaseline!="object")&&(e.plotBaseCurvesBaseline={});const n=e.plotBaseCurvesBaseline,r=e.plotBaseCurves&&typeof e.plotBaseCurves=="object"?e.plotBaseCurves:e.curves;r&&typeof r=="object"&&Object.entries(r).forEach(([i,a])=>{!n[i]&&Array.isArray(a)&&(n[i]=a.slice())}),(!e._originalBaselineEnd||typeof e._originalBaselineEnd!="object")&&(e._originalBaselineEnd={},e.baselineEnd&&typeof e.baselineEnd=="object"&&Object.keys(e.baselineEnd).forEach(i=>{e._originalBaselineEnd[i]=e.baselineEnd[i]})),yf(e),Po(e)}ye.loadedQuadData=e||null,xc(),Ef(t,ye.loadedQuadData)}function Ee(){return ye.loadedQuadData&&Po(ye.loadedQuadData),ye.loadedQuadData}function Vr(e=null){const t=Ee();if(!t)return e?null:{};const n=Po(t,e||void 0);return e?n||null:{...n||{}}}function $t(e={curves:{},sources:{},normalizeToEndChannels:{}}){return ye.loadedQuadData||(ye.loadedQuadData=typeof e=="function"?e():{...e},ye.loadedQuadData.curves||(ye.loadedQuadData.curves={}),ye.loadedQuadData.sources||(ye.loadedQuadData.sources={}),(!ye.loadedQuadData.normalizeToEndChannels||typeof ye.loadedQuadData.normalizeToEndChannels!="object")&&(ye.loadedQuadData.normalizeToEndChannels={}),(!ye.loadedQuadData.baselineEnd||typeof ye.loadedQuadData.baselineEnd!="object")&&(ye.loadedQuadData.baselineEnd={}),(!ye.loadedQuadData.rebasedCurves||typeof ye.loadedQuadData.rebasedCurves!="object")&&(ye.loadedQuadData.rebasedCurves={}),(!ye.loadedQuadData.rebasedSources||typeof ye.loadedQuadData.rebasedSources!="object")&&(ye.loadedQuadData.rebasedSources={}),(!ye.loadedQuadData.channelShapeMeta||typeof ye.loadedQuadData.channelShapeMeta!="object")&&(ye.loadedQuadData.channelShapeMeta={}),(!ye.loadedQuadData.bellCurveShift||typeof ye.loadedQuadData.bellCurveShift!="object")&&(ye.loadedQuadData.bellCurveShift={}),Po(ye.loadedQuadData),xc(),Ef(null,ye.loadedQuadData)),ye.loadedQuadData}function Hr(e){if(!e)return!1;const t=ye.loadedQuadData;if(!t)return!1;const n=t.normalizeToEndChannels||{};return Object.prototype.hasOwnProperty.call(n,e)?!!n[e]:(t.channelShapeMeta&&t.channelShapeMeta[e]||Po(t,e))?.classification!==xs.BELL}function Sf(e){return typeof e!="function"?()=>{}:(Hd.add(e),()=>{Hd.delete(e)})}function _i(){return!!ye.editMode}function _s(e){const t=!!ye.editMode,n=!!e;return t===n?(jd(),ye.editMode):(ye.editMode=n,jd(),ew(t,n),ye.editMode)}function Rb(e){return typeof e!="function"?()=>{}:(qd.add(e),()=>{qd.delete(e)})}function zb(){return ye.referenceQuadData}function XE(e){e&&typeof e=="object"?ye.referenceQuadData={filename:e.filename||"",channels:Array.isArray(e.channels)?e.channels.slice():[],curves:e.curves&&typeof e.curves=="object"?Object.fromEntries(Object.entries(e.curves).map(([t,n])=>[t,Array.isArray(n)?n.slice():[]])):{}}:ye.referenceQuadData=null}function jm(){const e=ye.referenceQuadData?.filename;return ye.referenceQuadData=null,e}function vf(){return!!ye.referenceQuadData}function nt(e){Object.assign(ye,e)}function gt(){return{...ye}}function lo(){return Number.isFinite(ye.plotSmoothingPercent)?ye.plotSmoothingPercent:0}function QE(e){const t=Number(e),n=Number.isFinite(t)?Math.max(0,Math.min(600,Math.round(t))):0;return ye.plotSmoothingPercent=n,n}function On(){const e=Number(ye.correctionGain);return Number.isFinite(e)?Math.max(0,Math.min(1,e)):1}function ZE(e,t={}){const n=Number(e),r=Number.isFinite(n)?Math.max(0,Math.min(1,n)):1,i=On();if(Math.abs(i-r)<=5e-4)return i;ye.correctionGain=r;const{persist:a=!0}=t||{};if(a)try{typeof localStorage<"u"&&localStorage.setItem("quadgen.correctionGain",String(r))}catch(o){console.warn("Failed to persist correction gain:",o)}return r}function JE(){ye.loadedQuadData=null,ye.linearizationData=null,ye.linearizationApplied=!1,ye.perChannelLinearization={},ye.perChannelEnabled={},ye.chartZoomIndex=0,ye.overlayAutoToggledOff=!1,ye.showCorrectionOverlay=!0,ye.showLabSpotMarkers=!1,ye.showLightBlockingOverlay=!1,ye.showInkLoadOverlay=!1,ye.inkLoadThreshold=25,ye.editMode=!1,ye.selectedChannel=null,ye.correctionMethod=Dc(),ye.correctionGain=1,ye.scaleAllPercent=100,ye.scaleBaselineEnds=null,xc(),Ef(null,null);try{const e=typeof globalThis<"u"?globalThis:{};e.LinearizationState?.clear&&e.LinearizationState.clear()}catch{}try{const e=typeof globalThis<"u"?globalThis:{};typeof e.invalidateMake256Cache=="function"&&e.invalidateMake256Cache()}catch{}try{const e=typeof globalThis<"u"?globalThis:{};typeof e.clearHistory=="function"&&e.clearHistory()}catch{}console.log("Application state reset")}function xc(){Os.setLoadedQuadData(ye.loadedQuadData)}function Ef(e,t){const n=e?Wm(e):null,r=t?Wm(t):null;Hd.forEach(i=>{try{i(r,n)}catch(a){console.warn("Error in loadedQuadData listener:",a)}})}function jd(){Os.setEditModeFlag(ye.editMode===!0)}function ew(e,t){qd.forEach(n=>{try{n(t,e)}catch(r){console.warn("Error in editMode listener:",r)}})}function Wm(e){if(!e)return e;if(typeof structuredClone=="function")try{return structuredClone(e)}catch{}try{return JSON.parse(JSON.stringify(e))}catch{return Array.isArray(e)?e.slice():{...e}}}const Km=Os.getLoadedQuadData();Km&&!ye.loadedQuadData&&(ye.loadedQuadData=Km,Po(ye.loadedQuadData));const Ym=Os.getEditModeFlag();Ym!==null&&(ye.editMode=Ym);Xe("coreState",{getLoadedQuadData:Ee,setLoadedQuadData:na,subscribeLoadedQuadData:Sf,ensureLoadedQuadData:$t,getChannelShapeMeta:Vr,getEditModeFlag:_i,setEditModeFlag:_s,subscribeEditModeFlag:Rb,getAppState:gt,updateAppState:nt,resetAppState:JE});Os.registerHelpers({getLoadedQuadData:Ee,setLoadedQuadData:na,subscribeLoadedQuadData:Sf,getEditModeFlag:_i,setEditModeFlag:_s,subscribeEditModeFlag:Rb,getChannelShapeMeta:Vr});if(typeof window<"u")try{window.getChannelShapeMeta=Vr}catch{}xc();jd();const tw={};function wf(){return typeof globalThis<"u"?globalThis:typeof window<"u"?window:tw}function wa(){return wf()}function Cf(e){if(!e)return;const n=wf()?.[e];return typeof n=="function"?n:void 0}function Wd(e,...t){const n=Cf(e);if(typeof n=="function")try{return n(...t)}catch(r){console.warn(`[legacy-helper] call failed for ${e}:`,r);return}}function ri(e={}){const t=wf();return Object.entries(e).forEach(([n,r])=>{typeof t[n]>"u"&&(t[n]=r)}),t}const Ie=256,Bc={config:new Map([["limitProximityPct",3],["slopeAbsolutePct",15],["sustainSamples",4],["minWidthPct",5],["blackShoulderScanStartPct",80],["whiteToeScanEndPct",10],["fallbackPlateauPct",5]]),getNumber(e,t=0){const n=this.config.get(e);return typeof n=="number"&&isFinite(n)?n:t},setNumber(e,t){typeof t=="number"&&isFinite(t)&&this.config.set(e,t)}},ft={SPACE:{PRINTER:"printer",IMAGE:"image",LAB:"lab",UNKNOWN:"unknown"},normalizeSpace(e){if(!e||typeof e!="string")return this.SPACE.UNKNOWN;const t=e.toLowerCase().trim();return Object.values(this.SPACE).includes(t)?t:this.SPACE.UNKNOWN},isPrinterSpace(e){return e?this.normalizeSpace(e)===this.SPACE.PRINTER:!0},convertSamples(e,t={}){const{from:n,to:r=this.SPACE.PRINTER,metadata:i={}}=t,a=this.normalizeSpace(n),o=a===this.SPACE.UNKNOWN?this.SPACE.PRINTER:a,s=this.normalizeSpace(r)===this.SPACE.UNKNOWN?this.SPACE.PRINTER:this.normalizeSpace(r),l=Array.isArray(e)?e:[];if(!l.length||o===s)return{values:l.slice(),sourceSpace:s,meta:{...i,sourceSpace:s}};let c=l.slice();return o===this.SPACE.IMAGE&&s===this.SPACE.PRINTER?c=l.slice().reverse().map(u=>1-u):o===this.SPACE.PRINTER&&s===this.SPACE.IMAGE&&(c=l.map(u=>1-u).reverse()),{values:c,sourceSpace:s,meta:{...i,fromSpace:o,sourceSpace:s,convertedAt:Date.now()}}},convertControlPoints(e,{from:t,to:n=this.SPACE.PRINTER,scale:r=100,inputScale:i=1,outputScale:a=1}={}){if(!Array.isArray(e)||!e.length)return[];const o=this.normalizeSpace(t),s=o===this.SPACE.UNKNOWN?this.SPACE.PRINTER:o,l=this.normalizeSpace(n)===this.SPACE.UNKNOWN?this.SPACE.PRINTER:this.normalizeSpace(n),c=Number(r)||100,u=(f,h)=>Math.max(0,Math.min(1,Number(f)/(h||1))),d=e.map(f=>({input:u(f.input,i),output:u(f.output,a)})),p=(f,h)=>f.map(h).sort((g,b)=>g.input-b.input);return s===l?p(d,f=>({input:f.input*c,output:f.output*c})):s===this.SPACE.IMAGE&&l===this.SPACE.PRINTER?p(d,f=>({input:(1-f.input)*c,output:(1-f.output)*c})):s===this.SPACE.PRINTER&&l===this.SPACE.IMAGE?p(d,f=>({input:(1-f.input)*c,output:(1-f.output)*c})):p(d,f=>({input:f.input*c,output:f.output*c}))}};function Af(e,t,n){return e+(t-e)*n}function Rr(e,t,n){return Math.min(n,Math.max(t,e))}function Mf(e,t=0,n=ve){const r=new Array(e);for(let i=0;i<e;i++){const a=e===1?0:i/(e-1);r[i]=Math.round(Af(t,n,a))}return r}function Ub(e,t,n=!0){return!Array.isArray(e)||!isFinite(t)?e.slice():e.map(r=>{const i=r*t;return n?Math.round(i):i})}function nw(e){return!Array.isArray(e)||e.length===0?0:Math.max(...e.filter(t=>isFinite(t)))}function rw(e,t=ve){const n=nw(e);if(n===0)return e.slice();const r=t/n;return Ub(e,r)}function iw(e,t){if(!Array.isArray(e)||e.length===0)return new Array(t).fill(0);if(e.length===t)return e.slice();const n=new Array(t),r=e.length;for(let i=0;i<t;i++){const a=i/(t-1)*(r-1),o=Math.floor(a),s=Math.min(o+1,r-1),l=a-o;o===s?n[i]=e[o]:n[i]=Math.round(Af(e[o],e[s],l))}return n}function Lf(e,t={}){const{expectedLength:n=Ie,allowEmpty:r=!1,maxValue:i=ve,minValue:a=0}=t;if(!Array.isArray(e))return{valid:!1,message:"Input is not an array"};if(e.length===0&&!r)return{valid:!1,message:"Array is empty"};if(n>0&&e.length!==n)return{valid:!1,message:`Expected length ${n}, got ${e.length}`};for(let o=0;o<e.length;o++){const s=e[o];if(!isFinite(s))return{valid:!1,message:`Non-finite value at index ${o}: ${s}`};if(s<a||s>i)return{valid:!1,message:`Value out of range at index ${o}: ${s} (expected ${a}-${i})`}}return{valid:!0,message:"Curve data is valid"}}function If(e=Ie){return new Array(e).fill(0)}function $b(e){return Array.isArray(e)?e.slice():[]}const Yl=wa();Yl.AUTO_LIMIT_CONFIG=Yl.AUTO_LIMIT_CONFIG||Bc;Yl.DataSpace=Yl.DataSpace||ft;ri({AUTO_LIMIT_CONFIG:Bc,DataSpace:ft,validateCurveData:Lf,createEmptyCurve:If,copyCurveData:$b});Xe("processingUtils",{AUTO_LIMIT_CONFIG:Bc,DataSpace:ft,validateCurveData:Lf,createEmptyCurve:If,copyCurveData:$b},{exposeOnWindow:typeof window<"u",windowAliases:["AUTO_LIMIT_CONFIG","DataSpace"]});const aw=Tb();class kf{constructor(){this.state=this.createInitialState(),this.listeners=new Map,this.isRestoring=!1,this.isBatching=!1,this.batchDepth=0,this.batchBuffer=new Map,this.batchOriginalState=null,this.selectorRegistry=new Set,this.computedRegistry=new Map,this.enableDebugging=!1,this.stateSnapshots=[],this.maxSnapshots=10}createInitialState(){return{app:{version:"2.6.4",debugLogs:!1,debugAI:!1,chartZoomIndex:9,editMode:!1,editSelection:{channel:null,ordinal:1},darkMode:!0,logoAnimatedOnce:!1},printer:{currentModel:"P700P900",channels:[...dn.P700P900.channels],channelValues:{},channelStates:{},channelPreviousValues:{},channelOriginalValues:{}},curves:{loadedQuadData:null,smartCurves:{},keyPoints:{},keyPointsMeta:{},sources:{}},linearization:{global:{data:null,applied:!1,filename:"",enabled:!1,baked:null},perChannel:{data:{},enabled:{}}},ui:{activeTab:"main",modalOpen:null,statusMessage:"",processingState:!1,filenames:{quadFile:"",globalLinearization:"",perChannelLinearization:{}}},files:{loadedFiles:{},recentFiles:[],autoSaveEnabled:!1,lastSaveTime:null},scaling:{globalPercent:100,baselines:null,maxAllowed:1e3},computed:{scaling:{isActive:!1}}}}getState(){return JSON.parse(JSON.stringify(this.state))}get(t){return this.getValueByPath(this.state,t)}set(t,n,r={}){if(this.isRestoring&&!r.allowDuringRestore)return;if(typeof t=="string"&&t!=="printer.channels"){const a=this.get("printer.channels")||[],o=new Set(a),s=(l,c=()=>({}))=>{if(!l||typeof l!="object")return{};const u={};return a.forEach(d=>{if(Object.prototype.hasOwnProperty.call(l,d)){const p=l[d];u[d]=p&&typeof p=="object"?{...p}:c(d)}}),u};if(t==="printer.channelValues")n=s(n,()=>({percentage:0,endValue:0}));else if(t.startsWith("printer.channelValues.")){const c=t.split(".")[2];if(c&&!o.has(c))return}if(t==="printer.channelStates")n=s(n,()=>({locked:!1,limitPercent:0,limitEndValue:0,enabled:!1}));else if(t.startsWith("printer.channelStates.")){const c=t.split(".")[2];if(c&&!o.has(c))return}if(t==="printer.channelOriginalValues")n=s(n,()=>({percent:0,end:0}));else if(t.startsWith("printer.channelOriginalValues.")){const c=t.split(".")[2];if(c&&!o.has(c))return}}if(this.isBatching){const a=this.get(t);this.setValueByPath(this.state,t,n);const o=this.batchBuffer.get(t),s=o||{oldValue:a,options:{...r}};o&&(s.options={...s.options,...r}),s.newValue=n,this.batchBuffer.set(t,s),this.enableDebugging&&this.captureStateSnapshot(`BATCHED SET ${t}`,{path:t,oldValue:a,newValue:n}),this.invalidateSelectorsForPath(t);return}const i=this.get(t);this.setValueByPath(this.state,t,n),this.enableDebugging&&this.captureStateSnapshot(`SET ${t}`,{path:t,oldValue:i,newValue:n}),this.invalidateSelectorsForPath(t),this.updateComputedForPaths([t]),this.notifyListeners(t,n,i,r),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[STATE] ${t}: ${JSON.stringify(i)} â†’ ${JSON.stringify(n)}`)}batch(t,n={}){if(typeof t=="function"){this.beginBatch();try{t(),this.completeBatch(n)}catch(r){throw this.rollbackBatch(),r}return}if(!t||typeof t!="object")throw new Error("stateManager.batch expects a function or an object map");this.beginBatch();try{for(const r in t)this.set(r,t[r],n);this.completeBatch(n)}catch(r){throw this.rollbackBatch(),r}}reset(t=null){const n=this.createInitialState();if(t){const r={};for(const i of t)r[i]=this.getValueByPath(n,i);this.batch(r,{reason:"reset"})}else this.state=n,this.notifyListeners("*",this.state,null,{reason:"fullReset"}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[STATE] Full reset to initial state")}beginBatch(){this.isBatching||(this.isBatching=!0,this.batchBuffer.clear(),this.batchOriginalState=JSON.parse(JSON.stringify(this.state))),this.batchDepth+=1}completeBatch(t={}){if(!this.isBatching||(this.batchDepth-=1,this.batchDepth>0))return;const r=Array.from(this.batchBuffer.entries()).map(([a])=>a);this.computedRegistry.size>0&&this.updateComputedForPaths(r,{forceBatch:!0}),this.isBatching=!1;const i=Array.from(this.batchBuffer.entries());for(const[a,o]of i){const{oldValue:s,newValue:l}=o;this.invalidateSelectorsForPath(a),this.notifyListeners(a,l,s,{...o.options,batched:!0,batchSize:i.length,...t})}this.batchBuffer.clear(),this.batchOriginalState=null,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[STATE] Batch flushed",i.map(([a])=>a))}rollbackBatch(){this.isBatching&&(this.batchOriginalState&&(this.state=JSON.parse(JSON.stringify(this.batchOriginalState))),this.isBatching=!1,this.batchDepth=0,this.batchBuffer.clear(),this.batchOriginalState=null)}subscribe(t,n){typeof t=="string"&&(t=[t]);const r={paths:t,callback:n},i=Symbol("subscription");return this.listeners.set(i,r),()=>{this.listeners.delete(i)}}createSelector(t,n=r=>r){const r=Array.isArray(t)?[...t]:[t];if(r.length===0)throw new Error("createSelector requires at least one dependency path");const i=new WeakMap,a=()=>{const o=r.map(c=>this.get(c));let s=i.get(this.state);if(s&&s.dependencies.length===o.length&&s.dependencies.every((c,u)=>c===o[u]))return s.result;const l=n(...o);return i.set(this.state,{dependencies:o,result:l}),l};return a.invalidate=()=>{i.delete(this.state)},this.selectorRegistry.add({selector:a,dependencyPaths:r,cache:i}),a}addComputed(t,n,r){if(!t||typeof t!="string")throw new Error("addComputed requires a string path");const i=Array.isArray(n)?[...n]:[n];if(i.length===0)throw new Error("addComputed requires at least one dependency");const a=this.createSelector(i,(...s)=>r(...s));this.computedRegistry.set(t,{dependencies:i,selector:a});const o=a();this.setValueByPath(this.state,t,o)}removeComputed(t){this.computedRegistry.delete(t)}getValueByPath(t,n){if(n==="*")return t;const r=n.split(".");let i=t;for(const a of r){if(i==null)return;i=i[a]}return i}updateComputedForPaths(t,{forceBatch:n=!1}={}){if(this.computedRegistry.size===0)return;const r=Array.isArray(t)?t:[t],i=this.isBatching||n;for(const[a,o]of this.computedRegistry.entries()){const{dependencies:s,selector:l}=o;if(!s.some(p=>r.some(f=>this.pathsIntersect(p,f))))continue;const u=this.getValueByPath(this.state,a),d=l();if(d!==u)if(this.setValueByPath(this.state,a,d),this.invalidateSelectorsForPath(a),i){const p=this.batchBuffer.get(a),f=p?{...p.options,computed:!0}:{computed:!0},h=p||{oldValue:u,options:f};h.newValue=d,h.options=f,this.batchBuffer.set(a,h)}else this.notifyListeners(a,d,u,{computed:!0})}}setValueByPath(t,n,r){const i=n.split(".");let a=t;for(let o=0;o<i.length-1;o++){const s=i[o];(a[s]===null||typeof a[s]!="object")&&(a[s]={}),a=a[s]}a[i[i.length-1]]=r}notifyListeners(t,n,r,i){for(const[a,o]of this.listeners){const{paths:s,callback:l}=o;if(s.includes("*")||s.some(u=>this.pathsIntersect(u,t)))try{l(t,n,r,i)}catch(u){console.error("State listener error:",u)}}}invalidateSelectorsForPath(t){for(const n of this.selectorRegistry)n.dependencyPaths.some(r=>this.pathsIntersect(r,t))&&n.cache.delete(this.state)}pathsIntersect(t,n){return t===n||t.startsWith(`${n}.`)||n.startsWith(`${t}.`)}captureStateSnapshot(t,n){if(!this.enableDebugging)return;const r={timestamp:Date.now(),action:t,details:n,state:JSON.parse(JSON.stringify(this.state))};this.stateSnapshots.push(r),this.stateSnapshots.length>this.maxSnapshots&&this.stateSnapshots.shift()}setDebugging(t){this.enableDebugging=t,t&&console.log("[STATE] Debugging enabled - state changes will be captured")}getDebugInfo(){return{currentState:this.getState(),snapshots:[...this.stateSnapshots],listenerCount:this.listeners.size}}getCurrentPrinter(){const t=this.get("printer.currentModel");return dn[t]||dn.P700P900}setPrinter(t,n=null){if(!dn[t])throw new Error(`Unknown printer model: ${t}`);const i=[...dn[t].channels],a=n&&typeof n=="object"?n:null,o=i.includes("MK")?"MK":i.includes("K")?"K":i[0],s=p=>{const f=a?.[p]||{};let h=Number.isFinite(f.percent)?InputValidator.clampPercent(f.percent):void 0,g=Number.isFinite(f.endValue)?InputValidator.clampEnd(f.endValue):void 0;return h===void 0&&g!==void 0&&(h=InputValidator.clampPercent(InputValidator.computePercentFromEnd(g))),g===void 0&&h!==void 0&&(g=InputValidator.computeEndFromPercent(h)),h===void 0&&(h=p===o?100:0),g===void 0&&(g=InputValidator.computeEndFromPercent(h)),{percent:h,endValue:g}},l={},c={},u={};i.forEach(p=>{const{percent:f,endValue:h}=s(p);l[p]={percentage:f,endValue:h},c[p]={locked:!1,limitPercent:f,limitEndValue:h,enabled:f>0||h>0},u[p]={percent:f,end:h}}),this.batch(()=>{this.set("printer.currentModel",t),this.set("printer.channels",i),this.set("printer.channelOriginalValues",u,{skipHistory:!0}),this.set("printer.channelValues",l,{skipHistory:!0}),this.set("printer.channelStates",c,{skipHistory:!0})});const d=()=>{const p=this.get("printer.channelValues")||{},f=this.get("printer.channelStates")||{},h=this.get("printer.channelOriginalValues")||{},g=(b,S)=>{const E={};return i.forEach(y=>{if(Object.prototype.hasOwnProperty.call(b,y)){const v=b[y];E[y]=v&&typeof v=="object"?{...v}:{...S[y]}}else S[y]&&(E[y]={...S[y]})}),E};this.batch(()=>{this.set("printer.channelValues",g(p,l),{skipHistory:!0,allowDuringRestore:!0}),this.set("printer.channelStates",g(f,c),{skipHistory:!0,allowDuringRestore:!0}),this.set("printer.channelOriginalValues",g(h,u),{skipHistory:!0,allowDuringRestore:!0})})};d(),typeof window<"u"&&(queueMicrotask(d),typeof window.requestAnimationFrame=="function"&&window.requestAnimationFrame(()=>d()))}getChannelValue(t,n){return this.get(`printer.channelValues.${t}.${n}`)}setChannelValue(t,n,r){if((this.get("printer.channels")||[]).includes(t)&&(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[STATE DEBUG] setChannelValue(${t}, ${n}, ${r})`),this.set(`printer.channelValues.${t}.${n}`,r),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS)){const a=this.get(`printer.channelValues.${t}.${n}`);console.log(`[STATE DEBUG] Verify: get returned ${a}`)}}isChannelEnabled(t){return(this.get("printer.channels")||[]).includes(t)&&this.get(`printer.channelStates.${t}.enabled`)||!1}setChannelEnabled(t,n){(this.get("printer.channels")||[]).includes(t)&&this.set(`printer.channelStates.${t}.enabled`,n)}getGlobalLinearization(){return this.get("linearization.global")}setGlobalLinearization(t,n=!0){this.batch({"linearization.global.data":t,"linearization.global.applied":n})}getPerChannelLinearization(t){return this.get(`linearization.perChannel.data.${t}`)}setPerChannelLinearization(t,n,r=!0){this.batch({[`linearization.perChannel.data.${t}`]:n,[`linearization.perChannel.enabled.${t}`]:r})}getLoadedQuadData(){return this.get("curves.loadedQuadData")}setLoadedQuadData(t){this.set("curves.loadedQuadData",t)}getSmartCurve(t){return this.get(`curves.smartCurves.${t}`)}setSmartCurve(t,n){this.set(`curves.smartCurves.${t}`,n)}setEditMode(t){this.set("app.editMode",t)}isEditMode(){return this.get("app.editMode")||!1}setEditSelection(t,n=1,r={}){const i=t??null,a=Number.isFinite(n)?n:1,o=r.skipHistory!==!0,s=typeof r.description=="string"?r.description:i?`Select channel ${i} (point ${a})`:"Clear edit selection";this.batch({"app.editSelection.channel":i,"app.editSelection.ordinal":a,"app.editSelection.__meta":o?{description:s}:null},r)}getEditSelection(){const t=this.get("app.editSelection")||{},n=t.channel??null,r=Number.isFinite(t.ordinal)?t.ordinal:1;return{channel:n,ordinal:r}}setStatus(t){this.set("ui.statusMessage",t)}getStatus(){return this.get("ui.statusMessage")||""}}let Gu=null;function at(){return Gu||(Gu=new kf),Gu}function Vb(){return at().getState()}function Df(e){return at().get(e)}function Pf(e,t,n={}){return at().set(e,t,n)}function xf(e,t={}){return at().batch(e,t)}function Bf(e,t){return at().subscribe(e,t)}aw.registerHelpers({QuadGenStateManager:kf,getStateManager:at,getAppState:Vb,getState:Df,setState:Pf,batchUpdateState:xf,subscribeToState:Bf});Xe("stateManager",{getStateManager:at,getAppState:Vb,getState:Df,setState:Pf,batchUpdateState:xf,subscribeToState:Bf},{exposeOnWindow:typeof window<"u",windowAliases:["getStateManager","getAppState","getState","setState","batchUpdateState","subscribeToState"]});let q=class Vo{static clampPercent(t){const n=parseFloat(t);return isNaN(n)?0:Math.min(100,Math.max(0,n))}static clampEnd(t){const n=parseInt(t);return isNaN(n)?0:Math.min(ve,Math.max(0,n))}static computeEndFromPercent(t){return Math.round(ve*t/100)}static computePercentFromEnd(t){return t/ve*100}static validateInput(t,n){const r=t.value,i=n(r),a=i.toString()===r||Math.abs(parseFloat(r)-i)<.01;return t.classList.toggle("border-red-300",!a),t.classList.toggle("border-gray-300",a),a||(t.value=i.toString()),i}static validatePercentInput(t){return Vo.validateInput(t,Vo.clampPercent)}static validateEndInput(t){return Vo.validateInput(t,Vo.clampEnd)}static clearValidationStyling(t){t.classList.remove("border-red-300"),t.classList.add("border-gray-300")}static validateRange(t,n,r,i=0){const a=parseFloat(t);return isNaN(a)?i:Math.min(r,Math.max(n,a))}static validateInteger(t,n=0){const r=parseInt(t);return isNaN(r)?n:r}static validatePositive(t,n=0){const r=parseFloat(t);return isNaN(r)||r<0?n:r}};const yr=new Map,Na=new Map;function Tf(e){const t=yr.get(e),n=Na.get(e);n&&n.forEach(r=>{try{r({...t})}catch(i){console.warn("[channel-locks] listener failed for",e,i)}})}function Xm(e){const t=q.clampEnd(e);return t<=0?0:q.clampPercent(q.computePercentFromEnd(t))}function ow(e,t={}){const n=at?.(),r=yr.get(e);if(r)return r;const i={locked:!1,percentLimit:100,endValue:ve};if(n){const a=n.get(`printer.channelStates.${e}.locked`),o=n.get(`printer.channelStates.${e}.limitPercent`),s=n.get(`printer.channelStates.${e}.limitEndValue`);typeof a=="boolean"&&(i.locked=a),Number.isFinite(o)&&(i.percentLimit=q.clampPercent(o)),Number.isFinite(s)?i.endValue=q.clampEnd(s):i.percentLimit!==void 0&&(i.endValue=q.clampEnd(Math.round(i.percentLimit/100*ve)))}return typeof t.locked=="boolean"&&(i.locked=t.locked),Number.isFinite(t.percentLimit)&&(i.percentLimit=q.clampPercent(t.percentLimit)),Number.isFinite(t.endValue)?i.endValue=q.clampEnd(t.endValue):(!Number.isFinite(i.endValue)||i.endValue<=0)&&(i.endValue=q.clampEnd(Math.round(i.percentLimit/100*ve))),i}function Xl(e){const t=at?.();if(!t)return;const n=yr.get(e);n&&(t.set(`printer.channelStates.${e}.locked`,!!n.locked,{allowDuringRestore:!0,skipHistory:!0}),t.set(`printer.channelStates.${e}.limitPercent`,q.clampPercent(n.percentLimit),{allowDuringRestore:!0,skipHistory:!0}),t.set(`printer.channelStates.${e}.limitEndValue`,q.clampEnd(n.endValue),{allowDuringRestore:!0,skipHistory:!0}))}function Ca(e,t={}){if(!e)return null;if(yr.has(e)){if(t&&Object.keys(t).length){const r={...yr.get(e)};typeof t.locked=="boolean"&&(r.locked=t.locked),Number.isFinite(t.percentLimit)&&(r.percentLimit=q.clampPercent(t.percentLimit)),Number.isFinite(t.endValue)&&(r.endValue=q.clampEnd(t.endValue)),yr.set(e,r),Xl(e),Tf(e)}}else{const n=ow(e,t);yr.set(e,n),Xl(e)}return{...yr.get(e)}}function Ql(e,t,n={}){if(!e)return;const r=Ca(e),i={...r,locked:!!t};if(t){const a=Number.isFinite(n.percentLimit)?q.clampPercent(n.percentLimit):Xm(n.endValue??r.endValue),o=Number.isFinite(n.endValue)?q.clampEnd(n.endValue):q.clampEnd(Math.round(a/100*ve));i.percentLimit=a,i.endValue=o}else if(Number.isFinite(n.percentLimit)||Number.isFinite(n.endValue)){const a=Number.isFinite(n.percentLimit)?q.clampPercent(n.percentLimit):Xm(n.endValue??r.endValue),o=Number.isFinite(n.endValue)?q.clampEnd(n.endValue):q.clampEnd(Math.round(a/100*ve));i.percentLimit=a,i.endValue=o}yr.set(e,i),Xl(e),Tf(e)}function Nt(e){return!!Ca(e)?.locked}function Zl(e,{percent:t,endValue:n}={}){if(!e)return;const i={...Ca(e)};Number.isFinite(t)&&(i.percentLimit=q.clampPercent(t)),Number.isFinite(n)?i.endValue=q.clampEnd(n):Number.isFinite(t)&&(i.endValue=q.clampEnd(Math.round(i.percentLimit/100*ve))),yr.set(e,i),Xl(e),Tf(e)}function ki(e){const t=Ca(e)||{locked:!1,percentLimit:100,endValue:ve};return{locked:!!t.locked,percentLimit:q.clampPercent(t.percentLimit??100),endValue:q.clampEnd(t.endValue??ve)}}function Di(e,t){const n=ki(e);let r=q.clampPercent(Number(t)||0);if(!n.locked)return{value:r,clamped:!1,limit:n.percentLimit};const i=q.clampPercent(n.percentLimit??100);return r>i?(r=i,{value:r,clamped:!0,limit:i}):{value:r,clamped:!1,limit:i}}function sw(e,t){return!e||typeof t!="function"?()=>{}:(Na.has(e)||Na.set(e,new Set),Na.get(e).add(t),()=>{const r=Na.get(e);r&&r.delete(t)})}function lw(e={}){yr.clear(),Na.clear(),e&&typeof e=="object"&&Object.entries(e).forEach(([t,n])=>{Ca(t,n||{})})}function Vi(e,t="editing points"){return`${e||"Channel"} is locked. Unlock before ${t}.`}function Tc(e=[]){if(Array.isArray(e)&&e.length)return e.filter(n=>Ca(n)?.locked);const t=[];return yr.forEach((n,r)=>{n?.locked&&t.push(r)}),t}function Of(e=[]){return!Array.isArray(e)||e.length===0?"":e.length===1?`${e[0]} is locked. Unlock to adjust global scale.`:e.length===2?`${e[0]} and ${e[1]} are locked. Unlock them to adjust global scale.`:`${e.length} channels are locked. Unlock them to adjust global scale.`}typeof window<"u"&&(typeof window.setChannelLock!="function"&&(window.setChannelLock=(e,t,n)=>Ql(e,t,n)),typeof window.isChannelLocked!="function"&&(window.isChannelLocked=e=>Nt(e)),typeof window.getChannelLockInfo!="function"&&(window.getChannelLockInfo=e=>ki(e)),typeof window.getLockedChannels!="function"&&(window.getLockedChannels=e=>Tc(e)));function Ns(e,t){let n;return function(...i){const a=()=>{clearTimeout(n),e(...i)};clearTimeout(n),n=setTimeout(a,t)}}function Jn(e){if(!Number.isFinite(e))return"100";const t=Math.round(e*100)/100;return Math.abs(t-Math.round(t))<.005?String(Math.round(t)):t.toFixed(2)}function Yo(e){return e.replace(/[\\/:*?"<>|]/g,"_").replace(/\s+/g,"_").replace(/_{2,}/g,"_").replace(/^_+|_+$/g,"").substring(0,200)}function Oc(e,t){if(!e)return!1;const n=typeof t=="function"?t():!!t;return e.checked=n,e.setAttribute("aria-checked",String(n)),n}const yi=typeof globalThis<"u"?globalThis:{};function Pa(e){if(!e||typeof e!="object")return null;const t={};let n=!1;return Object.keys(e).forEach(r=>{const i=e[r];if(Array.isArray(i)||i&&typeof i.length=="number"){try{t[r]=Array.from(i)}catch{const s=new Array(i.length);for(let l=0;l<s.length;l+=1)s[l]=i[l];t[r]=s}n=!0}}),n?t:null}function Ru(e,t){if(!Array.isArray(e)||e.length===0)return 0;const n=Math.max(0,Math.min(e.length-1,t)),r=e[n],i=Number(r);return Number.isFinite(i)?i:0}function zu(e,t,n){if(!e||typeof e!="object")return null;const r=Number(n),i=Number.isFinite(r)?Math.max(0,Math.min(1,r)):1,a={};let o=!1;return Object.keys(e).forEach(s=>{const l=e[s];if(!Array.isArray(l)||l.length===0)return;const c=t&&Array.isArray(t[s])?t[s]:null,u=l.length,d=new Array(u);for(let p=0;p<u;p+=1){const f=Number(l[p]),h=Number.isFinite(f)?f:Ru(l,p);let g=h;if(c)if(c.length===u){const b=Number(c[p]);g=Number.isFinite(b)?b:Ru(c,p)}else{const b=u>1?p/(u-1):0,S=Math.round(b*(c.length-1));g=Ru(c,S)}if(i<=.001)d[p]=Math.round(g);else if(i>=.999)d[p]=Math.round(h);else{const b=g+(h-g)*i;d[p]=Math.round(b)}}a[s]=d,o=!0}),o?a:null}function Qm(e){if(!Array.isArray(e)||e.length===0)return null;const t=e.map(n=>!n||typeof n!="object"?null:{...n}).filter(Boolean);return t.length?t:null}function cl(e,t){if(!Array.isArray(e)||e.length===0)return null;const n=Number(t),r=Number.isFinite(n)?Math.max(0,Math.min(1,n)):1,i=e.map(a=>{if(!a||typeof a!="object")return null;const o=Number(a.tolerancePercent),s=Number.isFinite(o)?o:1,l=Number.isFinite(a.arrowClampPercent)?a.arrowClampPercent:Number.isFinite(a.maxArrowPercent)?a.maxArrowPercent:8,c=Number(a.measuredSourceNormalized),u=Number(a.targetNormalized);let d=Number(a.baseDeltaNormalized);!Number.isFinite(d)&&Number.isFinite(u)&&Number.isFinite(c)&&(d=u-c),Number.isFinite(d)||(d=0);const p=d*r,f=d-p,h=Number.isFinite(l)&&l>0?l:8;let g=null;Number.isFinite(c)&&(g=c+p);const b=p*100,S=f*100,E=Math.abs(b),y=E<=s+1e-9,v=y?0:b>0?1:-1,A=Math.min(h,E),w=h>0?A/h:0,M=Number.isFinite(g)?g:Number.isFinite(a.correctedNormalized)?a.correctedNormalized:null,I=Number.isFinite(M)?M*100:a.correctedPercent;return{...a,correctionGain:r,measuredNormalized:M,measuredPercent:I,correctedNormalized:M,correctedPercent:I,deltaNormalized:p,deltaPercent:b,appliedDeltaNormalized:p,appliedDeltaPercent:b,residualDeltaNormalized:f,residualDeltaPercent:S,magnitudePercent:E,clampedMagnitudePercent:A,normalizedMagnitude:w,action:y?"within":b>0?"darken":"lighten",withinTolerance:y,direction:v}}).filter(Boolean);return i.length?i:null}const D={globalData:null,globalApplied:!1,globalBakedMeta:null,globalDataSource:null,globalBaselineCurves:null,globalCorrectedCurves:null,globalCorrectedCurvesBase:null,globalWarnings:[],compositeCoverageSummary:null,globalMeasurementCorrections:null,globalMeasurementCorrectionsBase:null,perChannelData:{},perChannelEnabled:{},perChannelMeasurementCorrections:{},perChannelMeasurementCorrectionsBase:{},hasAnyLinearization(){const e=!!(this.globalData&&this.globalApplied),t=Object.keys(this.perChannelData).some(n=>this.perChannelEnabled[n]);return e||t},getGlobalData(){return this.globalData},setGlobalData(e,t=!0,n={}){this.globalData=e,this.globalApplied=t,this.globalBakedMeta=null,this.globalBaselineCurves=null,this.globalCorrectedCurves=null,this.globalWarnings=[],e?n&&Object.prototype.hasOwnProperty.call(n,"source")?this.globalDataSource=n.source||null:this.globalDataSource||(this.globalDataSource=null):this.globalDataSource=null,this.setGlobalMeasurementCorrections(e?.measurementCorrections||null),yi.invalidateMake256Cache?.()},getPerChannelData(e){return this.perChannelData[e]||null},setPerChannelData(e,t,n=!0){this.perChannelData[e]=t,this.perChannelEnabled[e]=n,this.setPerChannelMeasurementCorrections(e,t?.measurementCorrections||null),yi.invalidateMake256Cache?.()},isPerChannelEnabled(e){return!!this.perChannelEnabled[e]},clear(){this.globalData=null,this.globalApplied=!1,this.globalBakedMeta=null,this.perChannelData={},this.perChannelEnabled={},this.globalBaselineCurves=null,this.globalCorrectedCurves=null,this.globalCorrectedCurvesBase=null,this.globalWarnings=[],this.compositeCoverageSummary=null,this.globalMeasurementCorrections=null,this.globalMeasurementCorrectionsBase=null,this.perChannelMeasurementCorrections={},this.perChannelMeasurementCorrectionsBase={},yi.invalidateMake256Cache?.()},clearGlobal(){this.globalData=null,this.globalApplied=!1,this.globalBakedMeta=null,this.globalBaselineCurves=null,this.globalCorrectedCurves=null,this.globalCorrectedCurvesBase=null,this.globalWarnings=[],this.compositeCoverageSummary=null,this.globalMeasurementCorrections=null,this.globalMeasurementCorrectionsBase=null,yi.invalidateMake256Cache?.()},clearPerChannel(e){delete this.perChannelData[e],delete this.perChannelEnabled[e],delete this.perChannelMeasurementCorrections[e],delete this.perChannelMeasurementCorrectionsBase[e],yi.invalidateMake256Cache?.()},isGlobalEnabled(){return!!(this.globalData&&this.globalApplied)},setGlobalBakedMeta(e){this.globalBakedMeta=e||null,e?this.globalDataSource="baked":this.globalDataSource||(this.globalDataSource=null)},getGlobalBakedMeta(){return this.globalBakedMeta||null},isGlobalBaked(){return!!this.globalBakedMeta},setGlobalDataSource(e){this.globalDataSource=e||null},getGlobalDataSource(){return this.globalDataSource||null},setGlobalBaselineCurves(e){this.globalBaselineCurves=Pa(e);const t=On();if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const n=this.globalBaselineCurves?.K?.slice(0,10),r=this.globalCorrectedCurvesBase?.K?.slice(0,10);console.log("[LinState] setGlobalBaselineCurves - gain:",t,"K baseline:",n,"K corrBase:",r)}if(this.globalCorrectedCurvesBase&&(this.globalCorrectedCurves=zu(this.globalCorrectedCurvesBase,this.globalBaselineCurves,t),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS)){const n=this.globalCorrectedCurves?.K?.slice(0,10);console.log("[LinState] setGlobalBaselineCurves result - K:",n)}},getGlobalBaselineCurves(){return Pa(this.globalBaselineCurves)},setGlobalCorrectedCurves(e){const t=Pa(e);if(this.globalCorrectedCurvesBase=t,!t){this.globalCorrectedCurves=null,yi.invalidateMake256Cache?.();return}const n=On();if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const r=t?.K?.slice(0,10);this.globalBaselineCurves?.K?.slice(0,10);const i=new Error().stack.split(`
`).slice(2,6).join(`
`);console.log("[LinState] setGlobalCorrectedCurves - gain:",n,"K base:",r,`
Stack:`,i)}if(this.globalCorrectedCurves=zu(t,this.globalBaselineCurves,n)||Pa(t),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const r=this.globalCorrectedCurves?.K?.slice(0,10);console.log("[LinState] setGlobalCorrectedCurves result - K:",r)}yi.invalidateMake256Cache?.()},getGlobalCorrectedCurves(){return Pa(this.globalCorrectedCurves)},setGlobalWarnings(e=[]){this.globalWarnings=Array.isArray(e)?e.slice():[]},getGlobalWarnings(){return Array.isArray(this.globalWarnings)?this.globalWarnings.slice():[]},setCompositeCoverageSummary(e=null){if(!e||typeof e!="object"){this.compositeCoverageSummary=null;return}try{this.compositeCoverageSummary=JSON.parse(JSON.stringify(e))}catch{this.compositeCoverageSummary=null}},getCompositeCoverageSummary(){if(!this.compositeCoverageSummary)return null;try{return JSON.parse(JSON.stringify(this.compositeCoverageSummary))}catch{return null}},setGlobalMeasurementCorrections(e=null){const t=Qm(e);if(this.globalMeasurementCorrectionsBase=t,!t){this.globalMeasurementCorrections=null;return}this.globalMeasurementCorrections=cl(t,On())},getGlobalMeasurementCorrections(e={}){const{skipEndpoints:t=!0,clone:n=!0}=e||{},r=Array.isArray(this.globalMeasurementCorrections)?this.globalMeasurementCorrections:[],i=t?r.filter(a=>!a?.isEndpoint):r;return n?i.map(a=>({...a})):i},setPerChannelMeasurementCorrections(e,t=null){if(!e)return;const n=Qm(t);if(!n){delete this.perChannelMeasurementCorrections[e],delete this.perChannelMeasurementCorrectionsBase[e];return}this.perChannelMeasurementCorrectionsBase[e]=n,this.perChannelMeasurementCorrections[e]=cl(n,On())},refreshMeasurementCorrectionsForGain(e=On()){const t=Number(e),n=Number.isFinite(t)?Math.max(0,Math.min(1,t)):On();this.globalMeasurementCorrectionsBase&&(this.globalMeasurementCorrections=cl(this.globalMeasurementCorrectionsBase,n)),this.globalCorrectedCurvesBase&&(this.globalCorrectedCurves=zu(this.globalCorrectedCurvesBase,this.globalBaselineCurves,n)||Pa(this.globalCorrectedCurvesBase)),this.perChannelMeasurementCorrectionsBase&&typeof this.perChannelMeasurementCorrectionsBase=="object"&&Object.keys(this.perChannelMeasurementCorrectionsBase).forEach(r=>{const i=this.perChannelMeasurementCorrectionsBase[r];if(!i){delete this.perChannelMeasurementCorrections[r];return}this.perChannelMeasurementCorrections[r]=cl(i,n)}),yi.invalidateMake256Cache?.()},getPerChannelMeasurementCorrections(e,t={}){if(!e)return[];const{skipEndpoints:n=!0,clone:r=!0}=t||{},i=Array.isArray(this.perChannelMeasurementCorrections?.[e])?this.perChannelMeasurementCorrections[e]:[],a=n?i.filter(o=>!o?.isEndpoint):i;return r?a.map(o=>({...o})):a},getLabMeasurementCorrections(e={}){const{channelName:t=null,skipEndpoints:n=!0,clone:r=!0}=e||{};return t?this.getPerChannelMeasurementCorrections(t,{skipEndpoints:n,clone:r}):this.getGlobalMeasurementCorrections({skipEndpoints:n,clone:r})}};function Rn(e,t=ft.SPACE.PRINTER){if(!e||typeof e!="object")return null;const n={...e};return n.sourceSpace||(n.sourceSpace=t),n.sourceSpace=ft.normalizeSpace(n.sourceSpace),typeof n.domainMin!="number"&&(n.domainMin=0),typeof n.domainMax!="number"&&(n.domainMax=1),Array.isArray(n.samples)||(n.samples=[]),typeof n.edited!="boolean"&&(n.edited=!1),n}function _f(e){if(!Array.isArray(e)||e.length===0)return[];if(e.length===1)return[0];const t=e.map(n=>ce(Number(n)||0));return t[0]=0,t[t.length-1]=1,t}function ls(e,t=1/65535){if(!Array.isArray(e)||e.length===0)return Array.isArray(e)?e:[];const n=e.map(r=>ce(Number(r)||0));if(n.length===0)return n;n[0]=0;for(let r=1;r<n.length;r++)n[r]<n[r-1]&&(n[r]=Math.min(1,n[r-1]+t));return n[n.length-1]=1,n}function cw(e,t){return!e||!t||["filename","originalSamples","smoothingMethod","interpolationType","description","metadata"].forEach(r=>{t[r]!==void 0&&e[r]===void 0&&(e[r]=t[r])}),e}function Aa(e){if(!e||typeof e!="object")return e;const t=ft.normalizeSpace(e.sourceSpace);if(t===ft.SPACE.PRINTER)return e;const n={...e};return n.sourceSpace=ft.SPACE.PRINTER,t===ft.SPACE.IMAGE&&console.log("ðŸ“Š Image->Printer space conversion needed (placeholder)"),n}function uw(e,t){return e?.interpolationType?e.interpolationType:t||"cubic"}function dw(e,t={}){const{sourceSpace:n=ft.SPACE.PRINTER,domainMin:r=0,domainMax:i=1,interpolationType:a="cubic",filename:o="generated",description:s="Generated linearization data"}=t;if(!Array.isArray(e)||e.length===0)throw new Error("Samples array is required and must not be empty");return Rn({samples:e.slice(),sourceSpace:n,domainMin:r,domainMax:i,interpolationType:a,filename:o,description:s,originalSamples:e.slice(),edited:!1})}function pw(e){if(!e||typeof e!="object")return{valid:!1,message:"Linearization data must be an object"};if(!Array.isArray(e.samples))return{valid:!1,message:"Samples array is required"};if(e.samples.length===0)return{valid:!1,message:"Samples array cannot be empty"};for(let n=0;n<e.samples.length;n++){const r=e.samples[n];if(typeof r!="number"||!isFinite(r))return{valid:!1,message:`Invalid sample at index ${n}: ${r}`}}return typeof e.domainMin!="number"||typeof e.domainMax!="number"?{valid:!1,message:"domainMin and domainMax must be numbers"}:e.domainMin>=e.domainMax?{valid:!1,message:"domainMin must be less than domainMax"}:ft.normalizeSpace(e.sourceSpace)===ft.SPACE.UNKNOWN?{valid:!1,message:"Invalid sourceSpace"}:{valid:!0,message:"Linearization data is valid"}}function Hb(e=null){if(e){const t=D.getPerChannelData(e);t&&(t.edited=!0)}else{const t=D.getGlobalData();t&&(t.edited=!0)}}function ur(e,t){return e?t?`${e} (edited)`:e:"unknown file"}function Pt(e){if(!e)return"0 points";const t=Array.isArray(e.originalData)?e.originalData.length:null;if(t&&t>1)return`${t} points`;const n=Array.isArray(e.samples)?e.samples.length:0;return n<=1?`${n} point`:`${n} points`}function Nf(e){return e?{...e,samples:Array.isArray(e.samples)?e.samples.slice():[],originalSamples:Array.isArray(e.originalSamples)?e.originalSamples.slice():[],metadata:e.metadata?{...e.metadata}:void 0,measurementCorrections:Array.isArray(e.measurementCorrections)?e.measurementCorrections.map(t=>t&&typeof t=="object"?{...t}:t):e.measurementCorrections??null}:null}const Zm=wa();Zm.LinearizationState=Zm.LinearizationState||D;ri({LinearizationState:D,normalizeLinearizationEntry:Rn,ensurePrinterSpaceData:Aa,getBasePointCountLabel:Pt,cloneLinearizationData:Nf});Xe("linearization",{LinearizationState:D,normalizeLinearizationEntry:Rn,ensurePrinterSpaceData:Aa,getBasePointCountLabel:Pt,cloneLinearizationData:Nf},{exposeOnWindow:typeof window<"u",windowAliases:["LinearizationState","normalizeLinearizationEntry","ensurePrinterSpaceData"]});const co={K_NEIGHBORS:2,SIGMA_FLOOR:.036,SIGMA_CEIL:.15,SIGMA_ALPHA:2,MAX_SMOOTHING:90};function fw(e){const t=Math.max(0,Math.min(100,Number(e)));if(t>8){const n=(t+16)/116;return n*n*n}else return t/903.3}function mw(e){const t=Math.max(1e-6,Math.min(1,e));return Math.log(t)/Math.LN10}function Jm(e){const t=fw(e);return-mw(t)}function Ff(e){return Math.max(0,Math.min(1,e))}function qb(e,t){if(!Array.isArray(e)||e.length===0)throw new Error("Invalid LAB data points");const n=Array.from(e).map(l=>({input:l.input,lab:l.lab}));n.sort((l,c)=>l.input-c.input);const i=n.map(l=>l.lab).map(l=>Jm(l)),a=Math.max(...i,1e-6),o=n.map(l=>{const c=Ff(l.input/100),u=Jm(l.lab)/a,p=t(c)-u;return{position:c,correction:p,originalLab:l.lab,originalInput:l.input}}),s=o.map(l=>l.position);return{correctionPoints:o,positions:s,Dmax:a}}function jb(e,t,n=co){const{K_NEIGHBORS:r,SIGMA_FLOOR:i,SIGMA_CEIL:a,SIGMA_ALPHA:o}=n,s=t.length;if(s<=1)return a;let l=0,c=s;for(;l<c;){const g=l+c>>1;t[g]<e?l=g+1:c=g}const u=[];let d=l-1,p=l;for(;(d>=0||p<s)&&u.length<r;){const g=d>=0?Math.abs(e-t[d]):1/0,b=p<s?Math.abs(e-t[p]):1/0;g<=b?(Number.isFinite(g)&&u.push(g),d--):(Number.isFinite(b)&&u.push(b),p++)}if(!u.length)return a;u.sort((g,b)=>g-b);const f=u.length>>1,h=u.length%2===0?.5*(u[f-1]+u[f]):u[f];return Math.min(a,Math.max(i,o*h))}function hw(e,t,n=co){const{correctionPoints:r}=e,i=[];for(let a=0;a<256;a++){const o=a/255,s=t(o),l=2*s*s;let c=0,u=0;for(let p=0;p<r.length;p++){const f=Math.abs(o-r[p].position),h=Math.exp(-(f*f)/Math.max(1e-9,l));c+=r[p].correction*h,u+=h}const d=u>0?c/u:0;i.push(Ff(o+d))}return i[0]=0,i[255]=1,i}function gw(e,t=30,n=co){const{correctionPoints:r,positions:i}=e,{SIGMA_FLOOR:a,SIGMA_CEIL:o,MAX_SMOOTHING:s}=n,l=Math.max(0,Math.min(s,Number(t)||0)),c=1+l/100,u=new Array(256);for(let g=0;g<256;g++){const b=g/255,S=jb(b,i,n),E=Math.min(o,Math.max(a,S*c)),y=2*E*E;let v=0,A=0;for(let M=0;M<r.length;M++){const I=Math.abs(b-r[M].position),_=Math.exp(-(I*I)/Math.max(1e-9,y));v+=r[M].correction*_,A+=_}const w=A>0?v/A:0;u[g]=Ff(b+w)}u[0]=0,u[255]=1;const d=21-Math.floor(l/10),p=Math.max(3,d),f=[],h=[];for(let g=0;g<p;g++){const b=g/(p-1),S=Math.round(b*255);h.push(b),f.push(u[S])}return{samples:f,xCoords:h,controlPointCount:p,needsDualTransformation:!1,influenceRadius:null,fullCurve:u}}function ul(e,t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(e,t)}const cs={uniformSampling(e,t){if(!Array.isArray(e))return[];if(t===0||e.length<=3)return e;const n=1-t/100,r=Math.max(3,Math.round(e.length*n)),i=(e.length-1)/(r-1);ul("ðŸ” Uniform Sampling DEBUG:",{originalPoints:e.length,reductionPercent:t,keepRatio:n,targetCount:r,step:i});const a=[];for(let o=0;o<r;o++){const s=Math.round(o*i);a.push(e[s])}return ul("âœ… Uniform Sampling Result:",`${e.length} â†’ ${a.length} points`),a},smoothingSplines(e,t){if(!Array.isArray(e))return[];if(t===0||e.length<=3)return e;const n=e.length,r=1-t/100,i=Math.max(3,Math.round(n*r)),a=[],o=[];for(let d=0;d<n;d++)a.push(d/(n-1)),o.push(e[d]);const s=Math.max(...o)-Math.min(...o),l=Math.pow(t/100,2)*s*.1;ul("ðŸ” Smoothing Splines DEBUG:",{originalPoints:e.length,reductionPercent:t,keepRatio:r,targetCount:i,dataRange:s,lambda:l});const c=this._buildSmoothingSpline(a,o,l),u=[];for(let d=0;d<i;d++){const p=d/(i-1),f=this._evaluateSmoothingSpline(c,a,o,p);u.push(f)}return ul("âœ… Smoothing Splines Result:",`${e.length} â†’ ${u.length} points`),u},_buildSmoothingSpline(e,t,n){const r=e.length;if(r<4)return{x:e,y:t,c:new Array(r).fill(0)};const i=[];for(let l=0;l<r-1;l++)i[l]=e[l+1]-e[l];const a=new Array(r).fill(null).map(()=>new Array(r).fill(0)),o=new Array(r).fill(0);a[0][0]=1+n,a[r-1][r-1]=1+n,o[0]=t[0],o[r-1]=t[r-1];for(let l=1;l<r-1;l++){const c=i[l-1],u=i[l];a[l][l]=1,o[l]=t[l],n>0&&(a[l][l]+=n*(2/(c+u)),l>1&&(a[l][l-1]=-n/(c+u)),l<r-2&&(a[l][l+1]=-n/(c+u)))}const s=this._solveTridiagonal(a,o);return{x:e,y:t,c:s}},_evaluateSmoothingSpline(e,t,n,r){const{x:i,y:a,c:o}=e,s=i.length;r=Math.max(0,Math.min(1,r));let l=0;for(;l<s-1&&i[l+1]<r;)l++;if(l>=s-1)return a[s-1];const c=i[l+1]-i[l],u=r-i[l],d=c>0?u/c:0,p=a[l],f=a[l+1],h=o[l],g=o[l+1],b=d*d,S=b*d,E=2*S-3*b+1,y=S-2*b+d,v=-2*S+3*b,A=S-b;return E*p+y*c*h+v*f+A*c*g},_solveTridiagonal(e,t){const n=e.length,r=new Array(n).fill(0);for(let i=0;i<n-1;i++)for(let a=i+1;a<n;a++){if(Math.abs(e[i][i])<1e-12)continue;const o=e[a][i]/e[i][i];for(let s=i;s<n;s++)e[a][s]-=o*e[i][s];t[a]-=o*t[i]}for(let i=n-1;i>=0;i--){r[i]=t[i];for(let a=i+1;a<n;a++)r[i]-=e[i][a]*r[a];Math.abs(e[i][i])>1e-12&&(r[i]/=e[i][i])}return r},applySmoothingReduction(e,t,n="smoothing-splines"){if(t===0)return e;switch(n){case"smoothing-splines":return this.smoothingSplines(e,t);case"uniform":return this.uniformSampling(e,t);default:return this.smoothingSplines(e,t)}}};function Uu(e){try{const t=Array.isArray(e)?e.slice():[],n=t.length;if(n<2)return o=>ce(o);const r=new Array(n),i=t.map(o=>ce(Number(o)||0));for(let o=0;o<n;o++)r[o]=n===1?0:o/(n-1);const a=zr(r,i);return o=>ce(a(ce(o)))}catch(t){return console.warn("buildTargetFnFromSamples fallback to linear:",t),n=>ce(n)}}function Wb(e){switch(e){case"uniform":return"uniform";case"smoothing-splines":default:return"smoothing-splines"}}const eh=wa();eh.CurveSimplification=eh.CurveSimplification||cs;ri({CurveSimplification:cs});Xe("curveSimplification",{CurveSimplification:cs},{exposeOnWindow:typeof window<"u",windowAliases:["CurveSimplification"]});function Kb(e){const t=Math.max(0,Math.min(100,Number(e)));if(t>8){const n=(t+16)/116;return n*n*n}return t/903.3}function Yb(e){const t=Math.max(1e-6,Math.min(1,e));return Math.log(t)/Math.LN10}function Fs(e){const t=Kb(e);return-Yb(t)}var $u={};const Xb="quadgen.smartPointDragEnabled";function bw(){if(typeof window>"u"||!window.localStorage)return null;try{const e=window.localStorage.getItem(Xb);return e===null?null:e==="true"}catch(e){return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("Failed to load smartPointDrag from storage:",e),null}}function yw(e){if(!(typeof window>"u"||!window.localStorage))try{window.localStorage.setItem(Xb,e?"true":"false")}catch(t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("Failed to persist smartPointDrag flag:",t)}}const Wr=Object.freeze({targetSpan:.07,minSamples:3,maxSamples:9,alpha:1.5,momentumBias:0}),dl=Object.freeze({targetSpan:{min:.03,max:.1},minSamples:{min:3,max:9},maxSamples:{min:3,max:12},alpha:{min:.5,max:3}}),Sw={activeRangeLinearization:!1,cubeEndpointAnchoring:!1,smartPointDrag:!0,compositeLabRedistribution:!0,compositeClampGuard:!0,compositeHighlightGuard:!1,labBaselineSmoothing:!0,redistributionSmoothingWindow:!1,autoRaiseInkLimitsOnImport:!1,compositePerSampleCeiling:!0,slopeKernelSmoothing:!0,simpleScalingCorrection:!1},Ze={...Sw},Qi={targetSpan:Wr.targetSpan,minSamples:Wr.minSamples,maxSamples:Wr.maxSamples,alpha:Wr.alpha,momentumBias:Wr.momentumBias};function pl(e,{min:t,max:n},r){const i=Number(e);return Number.isFinite(i)?typeof t=="number"&&i<t?t:typeof n=="number"&&i>n?n:i:r}function vw(e={}){const t={...Qi};if(Object.prototype.hasOwnProperty.call(e,"targetSpan")&&(t.targetSpan=pl(e.targetSpan,dl.targetSpan,Wr.targetSpan)),Object.prototype.hasOwnProperty.call(e,"minSamples")){const n=pl(e.minSamples,dl.minSamples,Wr.minSamples);t.minSamples=Math.round(n)}if(Object.prototype.hasOwnProperty.call(e,"maxSamples")){const n=pl(e.maxSamples,dl.maxSamples,Wr.maxSamples);t.maxSamples=Math.round(n)}if(t.maxSamples<t.minSamples&&(t.maxSamples=t.minSamples),Object.prototype.hasOwnProperty.call(e,"alpha")&&(t.alpha=pl(e.alpha,dl.alpha,Wr.alpha)),Object.prototype.hasOwnProperty.call(e,"momentumBias")){const n=Number(e.momentumBias);t.momentumBias=Number.isFinite(n)?n:Wr.momentumBias}return t}const th=bw();th!==null&&(Ze.smartPointDrag=th);if(typeof process<"u"&&process&&$u&&Object.prototype.hasOwnProperty.call($u,"QUADGEN_ENABLE_SLOPE_KERNEL")){const e=$u.QUADGEN_ENABLE_SLOPE_KERNEL;Ze.slopeKernelSmoothing=e!=="0"&&e!=="false"}function _c(){return!!Ze.activeRangeLinearization}function Qb(e){return Ze.activeRangeLinearization=!!e,Ze.activeRangeLinearization}function Nc(){return!!Ze.cubeEndpointAnchoring}function Zb(e){return Ze.cubeEndpointAnchoring=e!==!1,Ze.cubeEndpointAnchoring}function Fc(){return!!Ze.smartPointDrag}function Gf(e){return Ze.smartPointDrag=!!e,yw(Ze.smartPointDrag),Ze.smartPointDrag}function Rf(){return!!Ze.compositeLabRedistribution}function Jb(e){return Ze.compositeLabRedistribution=!!e,Ze.compositeLabRedistribution}function ey(){return!!Ze.compositeClampGuard}function ty(e){return Ze.compositeClampGuard=e!==!1,Ze.compositeClampGuard}function zf(){return!!Ze.compositeHighlightGuard}function ny(e){return Ze.compositeHighlightGuard=!!e,Ze.compositeHighlightGuard}function Gs(){return!!Ze.labBaselineSmoothing}function ry(e){return Ze.labBaselineSmoothing=e!==!1,Ze.labBaselineSmoothing}function Rs(){return!!Ze.autoRaiseInkLimitsOnImport}function Uf(e){return Ze.autoRaiseInkLimitsOnImport=!!e,Ze.autoRaiseInkLimitsOnImport}function Gc(){return!!Ze.redistributionSmoothingWindow}function $f(e){return Ze.redistributionSmoothingWindow=!!e,Ze.redistributionSmoothingWindow}function Rc(){return!!Ze.compositePerSampleCeiling}function iy(e){return Ze.compositePerSampleCeiling=!!e,Ze.compositePerSampleCeiling}function Vf(){return!!Ze.slopeKernelSmoothing}function ay(e){return Ze.slopeKernelSmoothing=!!e,Ze.slopeKernelSmoothing}function oy(){return!!Ze.simpleScalingCorrection}function sy(e){return Ze.simpleScalingCorrection=!!e,Ze.simpleScalingCorrection}function zc(){return{...Qi}}function ly(e={}){const t=vw(e||{});return Object.assign(Qi,t),Qi.maxSamples<Qi.minSamples&&(Qi.maxSamples=Qi.minSamples),zc()}function Ew(){typeof window>"u"||(typeof window.enableActiveRangeLinearization!="function"&&(window.enableActiveRangeLinearization=(e=!0)=>Qb(e)),typeof window.isActiveRangeLinearizationEnabled!="function"&&(window.isActiveRangeLinearizationEnabled=()=>_c()),typeof window.setCubeEndpointAnchoringEnabled!="function"&&(window.setCubeEndpointAnchoringEnabled=(e=!0)=>Zb(e)),typeof window.isCubeEndpointAnchoringEnabled!="function"&&(window.isCubeEndpointAnchoringEnabled=()=>Nc()),typeof window.enableSmartPointDrag!="function"&&(window.enableSmartPointDrag=(e=!0)=>Gf(e)),typeof window.isSmartPointDragEnabled!="function"&&(window.isSmartPointDragEnabled=()=>Fc()),typeof window.enableCompositeLabRedistribution!="function"&&(window.enableCompositeLabRedistribution=(e=!0)=>Jb(e)),typeof window.isCompositeLabRedistributionEnabled!="function"&&(window.isCompositeLabRedistributionEnabled=()=>Rf()),typeof window.enableCompositeClampGuard!="function"&&(window.enableCompositeClampGuard=(e=!0)=>ty(e)),typeof window.isCompositeClampGuardEnabled!="function"&&(window.isCompositeClampGuardEnabled=()=>ey()),typeof window.enableCompositeHighlightGuard!="function"&&(window.enableCompositeHighlightGuard=(e=!0)=>ny(e)),typeof window.isCompositeHighlightGuardEnabled!="function"&&(window.isCompositeHighlightGuardEnabled=()=>zf()),typeof window.enableLabBaselineSmoothing!="function"&&(window.enableLabBaselineSmoothing=(e=!0)=>ry(e)),typeof window.isLabBaselineSmoothingEnabled!="function"&&(window.isLabBaselineSmoothingEnabled=()=>Gs()),typeof window.enableAutoRaiseInkLimitsOnImport!="function"&&(window.enableAutoRaiseInkLimitsOnImport=(e=!0)=>Uf(e)),typeof window.isAutoRaiseInkLimitsEnabled!="function"&&(window.isAutoRaiseInkLimitsEnabled=()=>Rs()),typeof window.setRedistributionSmoothingWindowEnabled!="function"&&(window.setRedistributionSmoothingWindowEnabled=(e=!0)=>$f(e)),typeof window.configureRedistributionSmoothingWindow!="function"&&(window.configureRedistributionSmoothingWindow=e=>ly(e)),typeof window.getRedistributionSmoothingWindowConfig!="function"&&(window.getRedistributionSmoothingWindowConfig=()=>zc()),typeof window.enableCompositePerSampleCeiling!="function"&&(window.enableCompositePerSampleCeiling=(e=!0)=>iy(e)),typeof window.isCompositePerSampleCeilingEnabled!="function"&&(window.isCompositePerSampleCeilingEnabled=()=>Rc()),typeof window.enableSlopeKernelSmoothing!="function"&&(window.enableSlopeKernelSmoothing=(e=!0)=>ay(e)),typeof window.isSlopeKernelSmoothingEnabled!="function"&&(window.isSlopeKernelSmoothingEnabled=()=>Vf()),typeof window.enableSimpleScalingCorrection!="function"&&(window.enableSimpleScalingCorrection=(e=!0)=>sy(e)),typeof window.isSimpleScalingCorrectionEnabled!="function"&&(window.isSimpleScalingCorrectionEnabled=()=>oy()))}Ew();Xe("featureFlags",{setActiveRangeLinearizationEnabled:Qb,isActiveRangeLinearizationEnabled:_c,setCubeEndpointAnchoringEnabled:Zb,isCubeEndpointAnchoringEnabled:Nc,setSmartPointDragEnabled:Gf,isSmartPointDragEnabled:Fc,setCompositeLabRedistributionEnabled:Jb,isCompositeLabRedistributionEnabled:Rf,setCompositeClampGuardEnabled:ty,isCompositeClampGuardEnabled:ey,setCompositeHighlightGuardEnabled:ny,isCompositeHighlightGuardEnabled:zf,setLabBaselineSmoothingEnabled:ry,isLabBaselineSmoothingEnabled:Gs,setAutoRaiseInkLimitsEnabled:Uf,isAutoRaiseInkLimitsEnabled:Rs,setRedistributionSmoothingWindowEnabled:$f,isRedistributionSmoothingWindowEnabled:Gc,configureRedistributionSmoothingWindow:ly,getRedistributionSmoothingWindowConfig:zc,setCompositePerSampleCeilingEnabled:iy,isCompositePerSampleCeilingEnabled:Rc,setSlopeKernelSmoothingEnabled:ay,isSlopeKernelSmoothingEnabled:Vf,setSimpleScalingCorrectionEnabled:sy,isSimpleScalingCorrectionEnabled:oy},{exposeOnWindow:typeof window<"u"});const Kt=Object.freeze({LSTAR:"lstar",DENSITY:"density"}),Xo=0,ww=50,nh=600,Cw=1,Aw=3,Kd="quadgen.labSmoothingPercent",cy="quadgen.labNormalizationMode",Yd=new Set,Xd=new Set;function uy(e){return e===Kt.DENSITY?Kt.DENSITY:Kt.LSTAR}function Mw(){try{const e=typeof localStorage<"u"?localStorage.getItem(cy):null;return e?uy(e):Kt.LSTAR}catch{return Kt.LSTAR}}let vi=Mw();function dy(e){const t=Number(e);return Number.isFinite(t)?Math.max(0,Math.min(600,Math.round(t))):Xo}function Lw(){try{const e=typeof localStorage<"u"?localStorage.getItem(Kd):null;if(e==null)return Xo;const t=dy(e);if(t===ww){try{typeof localStorage<"u"&&localStorage.removeItem(Kd)}catch{}return Xo}return t}catch{return Xo}}let Ei=Lw();function Iw(){try{typeof localStorage<"u"&&localStorage.setItem(cy,vi)}catch{}}function kw(){try{typeof localStorage<"u"&&localStorage.setItem(Kd,String(Ei))}catch{}}function Dw(e){Yd.forEach(t=>{try{t(e)}catch(n){console.warn("[lab-settings] listener error:",n)}})}function Pw(e){Xd.forEach(t=>{try{t(e)}catch(n){console.warn("[lab-settings] smoothing listener error:",n)}})}function rr(){return vi}function va(){return vi===Kt.DENSITY}function us(e){const t=uy(e);return t===vi||(vi=t,Iw(),Dw(vi)),vi}function xw(){const e=va()?Kt.LSTAR:Kt.DENSITY;return us(e)}function Bw(e){return typeof e!="function"?()=>{}:(Yd.add(e),()=>{Yd.delete(e)})}function Gn(){return Ei}function Uc(){return Ir(Ei)}function Ir(e){const t=Number(e);if(!Number.isFinite(t))return 1;const r=Math.max(0,Math.min(nh,t))/nh;return 1+Math.pow(r,Cw)*Aw}function py(e){const t=dy(e);return t===Ei||(Ei=t,kw(),Pw(Ei)),Ei}function fy(){return Gs?.()??!0}function my(e){return typeof e!="function"?()=>{}:(Xd.add(e),()=>{Xd.delete(e)})}Xe("labSettings",{getLabNormalizationMode:rr,setLabNormalizationMode:us,toggleLabNormalizationMode:xw,isDensityNormalizationEnabled:va,LAB_NORMALIZATION_MODES:Kt,getLabSmoothingPercent:Gn,setLabSmoothingPercent:py,subscribeLabSmoothingPercent:my,getLabWidenFactor:Uc,mapSmoothingPercentToWiden:Ir,DEFAULT_LAB_SMOOTHING_PERCENT:Xo,isLabBaselineSmoothingEnabled:fy},{exposeOnWindow:typeof window<"u",windowAliases:["setLabNormalizationMode","toggleLabNormalizationMode"]});const Hn=e=>Math.max(0,Math.min(1,e)),Tw=.015,Vu=.15;function Ow(e,t){if(!Number.isFinite(t)||t<=1)return 1;const n=Math.max(0,Math.min(Vu,e));if(n===Vu)return t;const r=n/Vu,i=r*r*(3-2*r);return 1+(t-1)*i}function $c(e,t={}){const n=[...e].sort((M,I)=>M.input-I.input);if(!n.length){const M=I=>Hn(I);return{evaluate:M,createEvaluator:()=>M,positions:[]}}const r=t.normalizationMode||rr(),i=t.skipDefaultSmoothing===!0,a=Number.isFinite(t.widenFactor)?Math.max(.1,Number(t.widenFactor)):null;let o;if(r===Kt.LSTAR){const M=Math.max(...n.map(C=>C.lab)),I=Math.min(...n.map(C=>C.lab)),_=Math.max(1e-6,M-I);o=n.map(C=>Hn((M-C.lab)/_))}else{const M=n.map(x=>Fs(x.lab)),I=Math.min(...M),_=Math.max(...M),C=Math.max(1e-6,_-I);o=M.map(x=>Hn((x-I)/C))}const s=n.map(M=>Hn(M.input/100)),c=o.reduce((M,I,_)=>{const C=Math.abs(I-(s[_]??0));return C>M?C:M},0)<=Tw,u=i||c,d=a||(u?1:Uc()),p=t.neighbors??6,f=t.sigmaFloor??.02,h=t.sigmaCeil??.15,g=t.sigmaAlpha??3;function b(){if(s.length<2)return{positions:s.slice(),values:o.slice()};const M=s.slice(),I=o.slice(),_=(()=>{let k=0,N=0;for(let F=1;F<s.length;F+=1){const U=Math.abs(s[F]-s[F-1]);U>0&&(k+=U,N+=1)}return N>0?k/N:.05})(),C=h*3,x=Math.max(3,Math.ceil(C/Math.max(_,1e-6))),P=k=>{const N=k>0?s.length-1:0,F=k>0?s.length-2:1,U=Math.max(Math.abs(s[N]-s[F]),1e-6),j=(o[N]-o[F])/Math.max(U,1e-6);for(let B=1;B<=x;B+=1){const G=U*B*k,V=s[N]+G,K=Hn(o[N]+j*G);k>0?(M.push(V),I.push(K)):(M.unshift(V),I.unshift(K))}};return P(-1),P(1),{positions:M,values:I}}const S=b();function E(M,I){const _=I.length;if(_<=1)return h;let C=0,x=_;for(;C<x;){const j=C+x>>1;I[j]<M?C=j+1:x=j}const P=[];let k=C-1,N=C;for(;(k>=0||N<_)&&P.length<p;){const j=k>=0?Math.abs(M-I[k]):1/0,B=N<_?Math.abs(M-I[N]):1/0;j<=B?(Number.isFinite(j)&&P.push(j),k-=1):(Number.isFinite(B)&&P.push(B),N+=1)}if(!P.length)return h;P.sort((j,B)=>j-B);const F=P.length>>1,U=P.length%2===0?.5*(P[F-1]+P[F]):P[F];return Math.min(h,Math.max(f,g*U))}function y(M=1){if(u){const C=o.slice(),x=1/4096;if(C.length){C[0]=Hn(o[0]);for(let k=1;k<C.length;k+=1)C[k]<=C[k-1]&&(C[k]=Hn(C[k-1]+x));const P=C.length-1;C[P]=Math.max(C[P],Hn(o[o.length-1]))}return C}const I=o.map((C,x)=>{const P=s[x],k=Ow(P,M),N=Math.min(h,Math.max(f,E(P,S.positions)*k)),F=Math.max(1e-9,2*N*N);let U=0,j=0;for(let G=0;G<S.positions.length;G++){const V=Math.abs(P-S.positions[G]),K=Math.exp(-(V*V)/F);U+=S.values[G]*K,j+=K}const B=j>0?U/j:S.values[x];return Hn(B)}),_=1/4096;if(I.length){I[0]=Hn(o[0]);for(let x=1;x<I.length;x++)I[x]<=I[x-1]&&(I[x]=Hn(I[x-1]+_));const C=I.length-1;I[C]=Math.max(I[C],Hn(o[o.length-1]))}return I}function v(M=d){const I=Math.max(.1,Number.isFinite(M)?M:d),_=y(I),C=s.map(x=>x*100);return zr(C,_)}const A=v(d),w=M=>I=>Hn(M(Hn(I)*100));return{evaluate:w(A),createEvaluator(M=d){return w(v(M))},positions:s.slice()}}const Xr={K_NEIGHBORS:4,SIGMA_FLOOR:.036,SIGMA_CEIL:.3,SIGMA_ALPHA:2},_w=Object.freeze({passes:2,percent:30,algorithm:"smoothing-splines"}),fn={overrides:null,setOverrides(e){if(!e||typeof e!="object"){this.overrides=null;return}const t={},n=(r,i)=>{const a=Number(i);Number.isFinite(a)&&a>0&&(t[r]=a)};n("K_NEIGHBORS",e.K_NEIGHBORS),n("SIGMA_FLOOR",e.SIGMA_FLOOR),n("SIGMA_CEIL",e.SIGMA_CEIL),n("SIGMA_ALPHA",e.SIGMA_ALPHA),this.overrides=Object.keys(t).length?t:null},get(e,t){const n=this.overrides&&this.overrides[e];return Number.isFinite(n)?n:Xr[e]!==void 0?Xr[e]:t},exportOverrides(){return this.overrides?{...this.overrides}:null}};fn.setOverrides({K_NEIGHBORS:Xr.K_NEIGHBORS,SIGMA_FLOOR:Xr.SIGMA_FLOOR,SIGMA_CEIL:Xr.SIGMA_CEIL,SIGMA_ALPHA:Xr.SIGMA_ALPHA});let hr={key:null,targetFn:e=>ce(e)};function Nw(){const t=(typeof globalThis<"u"?globalThis:{})?.contrastIntent;return t&&typeof t=="object"?t:{id:"linear",name:"Linear",params:{}}}function Hu(e){return ft.convertSamples(e,{from:ft.SPACE.IMAGE,to:ft.SPACE.PRINTER}).values}function Fw(){return{neighbors:fn.get("K_NEIGHBORS",Xr.K_NEIGHBORS),sigmaFloor:fn.get("SIGMA_FLOOR",Xr.SIGMA_FLOOR),sigmaCeil:fn.get("SIGMA_CEIL",Xr.SIGMA_CEIL),sigmaAlpha:fn.get("SIGMA_ALPHA",Xr.SIGMA_ALPHA)}}function Gw(){return{gaussian:Fw(),smoothingSequence:_w,anchorToUnitRange:!0}}function qu(e,t){if(!t)return e;const n=Object.keys(t).sort().map(r=>`${r}:${t[r]}`);return`${e}::${n.join(",")}`}function Hi(e){const t=Nw(),n=t?.id||"linear";if(n==="linear")return ce(e);const r=Do?.[n];if(r&&r.curveFunction){const i=r.params||{};if(typeof i.gamma=="number"){const a=i.gamma,o=1/Math.max(.01,a);return Math.pow(ce(e),o)}try{const a=qu(n,i);if(hr.key!==a||typeof hr.targetFn!="function"){const o=new Array(256);for(let s=0;s<256;s++)o[s]=ce(r.curveFunction(s/255));hr={key:a,targetFn:Uu(Hu(o))}}return hr.targetFn(e)}catch(a){return console.warn("Intent preset processing failed for",n,a),ce(e)}}if(n==="pops_standard")try{const i=qu(n,t?.params);if(hr.key!==i||typeof hr.targetFn!="function"){const a=new Array(256);for(let o=0;o<256;o++)a[o]=yE(o/255);hr={key:i,targetFn:Uu(Hu(a))}}return hr.targetFn(e)}catch(i){return console.warn("Intent processing failed for pops_standard:",i),ce(e)}if(n==="custom_gamma")try{const i=Number(t?.params?.gamma),o=1/(Number.isFinite(i)&&i>0?i:1);return Math.pow(ce(e),o)}catch(i){return console.warn("Intent processing failed for custom_gamma:",i),ce(e)}if(n==="custom_filmic")try{const i=Number(t?.params?.gain),a=Number(t?.params?.shoulder),o=qu(n,{gain:i,shoulder:a});if(hr.key!==o||typeof hr.targetFn!="function"){const s=new Array(256),l=Number.isFinite(i)?i:.55,c=Number.isFinite(a)?a:.35;for(let u=0;u<256;u++)s[u]=bE(u/255,l,c);hr={key:o,targetFn:Uu(Hu(s))}}return hr.targetFn(e)}catch(i){return console.warn("Intent processing failed for custom_filmic:",i),ce(e)}if(n==="custom_points"&&typeof t?.targetFn=="function")try{return ce(t.targetFn(ce(e)))}catch(i){return console.warn("Intent processing failed for custom_points:",i),ce(e)}return ce(e)}function Rw(e){const t=[];let n="",r=!1;for(let i=0;i<e.length;i++){const a=e[i];if(a==='"'){r=!r;continue}if(!r&&(a==="#"||a===";"))return n&&t.push(n),t;!r&&/\s/.test(a)?n&&(t.push(n),n=""):n+=a}return n&&t.push(n),t}function ln(e){if(e==null||e==="")return NaN;const t=String(e).replace(/,/g,"").trim();if(!t)return NaN;const n=parseFloat(t);return Number.isFinite(n)?n:NaN}function uo(e,t,n={}){try{const r=e.split(/\r?\n/),i=[],a=n.normalizationMode||rr();for(const E of r){const y=E.trim();if(!y||y.startsWith("#")||y.startsWith("//")||y.toUpperCase().includes("GRAY")&&y.toUpperCase().includes("LAB_L"))continue;const v=y.split(/\s+/);if(v.length<2)continue;const A=parseFloat(v[0]),w=parseFloat(v[1]);if(!Number.isFinite(A)||!Number.isFinite(w)||w<0||w>100)continue;const M=A>100?A/255*100:A;M<0||i.push({input:M,lab:w})}if(i.length<2)throw new Error("Not enough valid LAB measurement data points found. Expected format: GRAY	LAB_L	LAB_A	LAB_B");i.sort((E,y)=>E.input-y.input);const o=i.map(E=>({...E})),s=(()=>{if(!o.length)return[];if(a===Kt.LSTAR){const w=Math.max(...o.map(_=>_.lab)),M=Math.min(...o.map(_=>_.lab)),I=Math.max(1e-6,w-M);return o.map(_=>ce((w-_.lab)/I))}const E=o.map(w=>Fs(w.lab)),y=Math.min(...E),v=Math.max(...E),A=Math.max(1e-6,v-y);return E.map(w=>ce((w-y)/A))})(),l=Gn(),c=Gs()?1:Uc(),u=$c(o,{neighbors:fn.get("K_NEIGHBORS",6),sigmaFloor:fn.get("SIGMA_FLOOR",.02),sigmaCeil:fn.get("SIGMA_CEIL",.15),sigmaAlpha:fn.get("SIGMA_ALPHA",3),normalizationMode:a,skipDefaultSmoothing:l<=0,widenFactor:c}),d=E=>ce(Hi(E)),p=(E=1)=>{const y=u.createEvaluator(Math.max(.1,E)),v=y(0),A=y(1);return w=>{const M=ce(w),I=ce(d(M));if(I<=v)return 0;if(I>=A)return 1;let _=0,C=1;for(let x=0;x<40;x++){const P=(_+C)/2,k=y(P);if(!Number.isFinite(k))break;k<I?_=P:C=P}return ce(C)}},f=p(1),h=new Array(256);for(let E=0;E<256;E++){const y=E/255;h[E]=f(y)}h[0]=0,h[255]=1;const g=ls(h),b=g.slice(),S=(()=>{const v=(()=>{if(u&&typeof u.evaluate=="function")return w=>u.evaluate(ce(w));if(u&&typeof u.createEvaluator=="function"){const w=u.createEvaluator(1);if(typeof w=="function")return M=>w(ce(M))}return w=>ce(w)})(),A=[];for(let w=0;w<o.length;w+=1){const M=o[w];if(!M)continue;const I=Math.max(0,Math.min(100,Number(M.input)||0)),_=ce(I/100),C=v(_),x=Number.isFinite(C)?ce(C):_,P=Number.isFinite(s[w])?s[w]:_,k=ce(d(_)),N=k-P,F=N*100,U=Math.abs(F),j=U<=1+1e-9,B=j?"within":F>0?"darken":"lighten",G=Math.min(8,U),V=G/8,K=j?0:F>0?1:-1;A.push({index:w,inputPercent:I,inputNormalized:_,lab:Number(M.lab)||null,measuredSourceNormalized:P,measuredSourcePercent:P*100,measuredNormalized:x,correctedNormalized:x,correctedPercent:x*100,measuredPercent:x*100,targetNormalized:k,targetPercent:k*100,deltaNormalized:N,deltaPercent:F,baseDeltaNormalized:N,baseDeltaPercent:F,baseMagnitudePercent:U,clampedMagnitudePercent:G,normalizedMagnitude:V,tolerancePercent:1,arrowClampPercent:8,maxArrowPercent:8,action:B,withinTolerance:j,direction:K,isEndpoint:w===0||w===o.length-1})}return A})();return{valid:!0,domainMin:0,domainMax:1,samples:b.slice(),rawSamples:g.slice(),baseSamples:g.slice(),previewSamples:b.slice(),previewSmoothingPercent:l,originalData:o,measurementCorrections:S,format:"LAB Data",filename:t||"lab_measurements.txt",sourceSpace:ft.SPACE.PRINTER,measurementIntent:"positive",edited:!1,getSmoothingControlPoints(E){const y=Math.max(0,Math.min(600,Number(E)||0)),v=Ir(y),A=p(v),w=new Array(256);for(let x=0;x<256;x++){const P=x/255;w[x]=A(P)}const M=ls(w),I=Math.max(3,21-Math.floor(y/10)),_=[],C=[];for(let x=0;x<I;x++){const P=x/(I-1||1),k=Math.round(P*255);C.push(P),_.push(M[k])}return{samples:_,xCoords:C,controlPointCount:I,needsDualTransformation:!1}}}}catch(r){return console.error("Error parsing LAB data:",r),{valid:!1,error:r.message,format:"LAB Data",filename:t}}}function er(e,t={}){const n=Array.isArray(e)?e.map(u=>({input:u.input,lab:u.lab})):[];if(n.length<2)return null;n.sort((u,d)=>u.input-d.input);const r=t.normalizationMode||rr(),i={neighbors:fn.get("K_NEIGHBORS",6),sigmaFloor:fn.get("SIGMA_FLOOR",.02),sigmaCeil:fn.get("SIGMA_CEIL",.15),sigmaAlpha:fn.get("SIGMA_ALPHA",3),normalizationMode:r,...t};if(!Number.isFinite(i.widenFactor)){const u=Gs();t.useBaselineWidenFactor&&u?i.widenFactor=1:i.widenFactor=Uc()}const a=$c(n,i),o=u=>ce(Hi(u)),l=(u=>{const d=typeof u=="number"?a.createEvaluator(Math.max(.1,u)):a.createEvaluator(),p=d(0),f=d(1);return h=>{const g=ce(h),b=ce(o(g));if(b<=p)return 0;if(b>=f)return 1;let S=0,E=1;for(let y=0;y<40;y++){const v=(S+E)/2,A=d(v);if(!Number.isFinite(A))break;A<b?S=v:E=v}return ce(E)}})(t.widenFactor),c=new Array(256);for(let u=0;u<256;u++){const d=u/255;c[u]=l(d)}return c[0]=0,c[255]=1,ls(c)}function Nl(e,t={}){if(!e||typeof e!="object")return e;const n=String(e.format||"").toLowerCase();if(!(n.includes("lab")||n.includes("cgats")||n.includes("manual"))||!Array.isArray(e.originalData)||e.originalData.length<2)return e;const{useBaselineWidenFactor:i,...a}=t,o=a.normalizationMode||rr(),s={...a,normalizationMode:o};Number.isFinite(a.widenFactor)||(s.useBaselineWidenFactor=!0);const l=er(e.originalData,{...s,skipDefaultSmoothing:!0})||null,c=er(e.originalData,s)||l,u=Gn(),d=Number.isFinite(u)&&u>0,p=d?Ir(u):1,f=er(e.originalData,{...a,normalizationMode:o,widenFactor:p})||c;return l&&(e.rawSamples=l.slice()),c&&(e.baseSamples=c.slice()),f?(e.previewSamples=f.slice(),e.samples=d?f.slice():c?c.slice():f.slice(),Array.isArray(e.originalSamples)||(e.originalSamples=f.slice())):c&&(e.samples=c.slice()),e.previewSmoothingPercent=Gn(),e.domainMin=0,e.domainMax=1,e.sourceSpace=ft.SPACE.PRINTER,e}function rh(e){if(!e||!Array.isArray(e.originalData))return null;const t=e.rawSamples?e.rawSamples.slice():er(e.originalData,{skipDefaultSmoothing:!0})||[],n=e.previewSamples?e.previewSamples.slice():er(e.originalData,{skipDefaultSmoothing:!1})||[];return{raw:t,smoothed:n,rawFirst:t.slice(0,16),smoothedFirst:n.slice(0,16)}}Xe("lab",{LAB_TUNING:fn,parseLabData:uo,getTargetRelAt:Hi,cieDensityFromLstar:Fs,getLabSmoothingDebug:Gw,rebuildLabSamplesFromOriginal:er,debugRebuildFromEntry:rh,debugLabRebuildFromEntry:rh},{exposeOnWindow:!0,windowAliases:["LAB_TUNING","parseLabData","getTargetRelAt","cieDensityFromLstar","rebuildLabSamplesFromOriginal","debugLabRebuildFromEntry"]});const hy=!0,Qn=()=>typeof DEBUG_LOGS<"u"&&DEBUG_LOGS||typeof globalThis<"u"&&globalThis.DEBUG_LOGS;function pr(e){return Qn()&&console.log("[LAB BYPASS] Detection check:",{hasEntry:!!e,entryType:typeof e,format:e?.format,filename:e?.filename,sourceSpace:e?.sourceSpace,measurementIntent:e?.measurementIntent,hasOriginalData:Array.isArray(e?.originalData)}),!e||typeof e!="object"?!1:e.format==="LAB Data"?(Qn()&&console.log("[LAB BYPASS] Detected via format:",e.format),!0):e.filename&&typeof e.filename=="string"&&e.filename.toLowerCase().includes("lab")?(Qn()&&console.log("[LAB BYPASS] Detected via filename:",e.filename),!0):e.sourceSpace==="printer"&&e.measurementIntent==="positive"?(Qn()&&console.log("[LAB BYPASS] Detected via space/intent:",e.sourceSpace,e.measurementIntent),!0):Array.isArray(e.originalData)&&e.originalData.length>0&&e.originalData.some(n=>n&&typeof n=="object"&&typeof n.lab=="number")?(Qn()&&console.log("[LAB BYPASS] Detected via originalData structure"),!0):!1}function Hf(e,t,n=30,r=65535){console.log("[LAB BYPASS] processLabLegacy called with:",{valuesCount:e.length,smoothingPercent:n,maxValue:r,bypassEnabled:hy,labEntryFormat:t?.format}),Qn()&&console.log("[LAB BYPASS] Processing LAB data:",{valuesCount:e.length,smoothingPercent:n,maxValue:r,labEntry:{format:t.format,filename:t.filename,originalDataCount:t.originalData?.length}});try{if(!t.originalData||!Array.isArray(t.originalData)||t.originalData.length<2)throw new Error("Invalid LAB originalData");Qn()&&console.log("[LAB BYPASS] Starting legacy processing with",t.originalData.length,"data points");const i=qb(t.originalData,Hi);Qn()&&console.log("[LAB BYPASS] Generated",i.correctionPoints.length,"correction points");const o=hw(i,l=>jb(l,i.positions,co),co);Qn()&&console.log("[LAB BYPASS] Generated 256-point curve, first few values:",o.slice(0,5));const s=e.map((l,c)=>{const u=Math.max(0,Math.min(1,r>0?l/r:0)),d=Math.round(u*255),p=o[d];return Math.round(p*r)});return Qn()&&console.log("[LAB BYPASS] Applied curve to values, result sample:",s.slice(0,10)),s}catch(i){return console.error("[LAB BYPASS] Error in legacy processing:",i),e.slice()}}function qf(e,t=30){Qn()&&console.log("[LAB BYPASS] Generating 256-point curve:",{smoothingPercent:t,labEntry:{format:e.format,filename:e.filename,originalDataCount:e.originalData?.length}});try{if(!e.originalData||!Array.isArray(e.originalData)||e.originalData.length<2)throw new Error("Invalid LAB originalData");Qn()&&console.log("[LAB BYPASS] Generating direct 256-point curve with smoothing:",t);const n=qb(e.originalData,Hi),r=gw(n,t,co),i=r.fullCurve;return Qn()&&(console.log("[LAB BYPASS] Generated 256-point curve, first few values:",i.slice(0,5)),console.log("[LAB BYPASS] Control points count:",r.controlPointCount)),i}catch(n){return console.error("[LAB BYPASS] Error generating LAB curve:",n),new Array(256).fill(0).map((r,i)=>i/255)}}function jf(){return{enabled:hy,debugMode:Qn,version:"1.0.0-bypass"}}const Fl=wa(),zw={isLabLinearizationData:pr,processLabLegacy:Hf,generateLabCurve256:qf,getStatus:jf},Wf=Fl.labBypass&&typeof Fl.labBypass=="object"?Fl.labBypass:{};Object.assign(Wf,zw);Fl.labBypass=Wf;ri({labBypass:Wf,isLabLinearizationData:pr,processLabLegacy:Hf,generateLabCurve256:qf,getLabBypassStatus:jf});Xe("labBypass",{isLabLinearizationData:pr,processLabLegacy:Hf,generateLabCurve256:qf,getLabBypassStatus:jf},{exposeOnWindow:typeof window<"u",windowAliases:["labBypass"]});const Dr=()=>{};let ju=null,Wu=!1,Ku=null,Yu=new Set,Xu=null,Qu=!1,gy=Dr,by=Dr,yy=Dr,Sy=Dr,vy=Dr,Ey=Dr;function Uw(e){gy=typeof e=="function"?e:Dr}function Je(){Wu||(Wu=!0,ju||(ju=requestAnimationFrame(()=>{ju=null,Wu=!1,gy()})))}function $w(e){by=typeof e=="function"?e:Dr}function Ur(e){e&&Yu.add(e),Ku||(Ku=requestAnimationFrame(()=>{Ku=null;const t=Array.from(Yu);Yu.clear(),t.forEach(n=>by(n))}))}function Vw(e){yy=typeof e=="function"?e:Dr}function po(){return yy()}function Hw(e){Sy=typeof e=="function"?e:Dr}function Er(){return Sy()}function qw(e){vy=typeof e=="function"?e:Dr}function Li(){return vy()}function jw(e){Ey=typeof e=="function"?e:Dr}function Pn(){Qu||(Qu=!0,Xu||(Xu=requestAnimationFrame(()=>{Xu=null,Qu=!1,Ey()})))}const ui=new Map;function Kf(e){return e&&typeof e=="object"&&"isConnected"in e?e.isConnected:!!e}function wy(e,t){!e||!t||ui.set(e,t)}function Ww(e){ui.clear()}function $r(e){if(!e)return null;const t=ui.get(e);if(Kf(t))return t;if(ui.delete(e),typeof document>"u")return null;const n=document.querySelector(`tr.channel-row[data-channel="${e}"]`);return n&&ui.set(e,n),n}function Kw(){const e=[];return ui.forEach((t,n)=>{Kf(t)?e.push(t):ui.delete(n)}),e}function Yw(){const e=new Map;return ui.forEach((t,n)=>{Kf(t)?e.set(n,t):ui.delete(n)}),e}const ih=65535;function Cy(e){if(!e||typeof e.length!="number")return[];const t=e.length>>>0,n=new Array(t);for(let r=0;r<t;r+=1){const i=Number(e[r]);Number.isFinite(i)?i<0?n[r]=0:i>ih?n[r]=ih:n[r]=i:n[r]=0}return n}function ah(e,t,n){const r=t-e,i=n-t;if(r*i<=0)return 0;const a=3,o=3;return(a+o)/(a/r+o/i)}function Ay(e,t){if(!Array.isArray(e)||e.length===0)return 0;if(e.length===1)return e[0];const n=Rr(t,0,e.length-1),r=Math.floor(n),i=n-r;if(i<1e-9)return e[r];if(r>=e.length-1)return e[e.length-1];const a=e[Math.max(0,r-1)],o=e[r],s=e[Math.min(e.length-1,r+1)],l=e[Math.min(e.length-1,r+2)],c=ah(a,o,s),u=ah(o,s,l),d=i*i,p=d*i,f=2*p-3*d+1,h=p-2*d+i,g=-2*p+3*d,b=p-d;return f*o+h*c+g*s+b*u}function My(e,t){const n=e.length;if(!n)return 12;const r=e[t]||1;if(r<=0)return 12;const i=r*.2;let a=t,o=t;for(;a>0&&e[a]>i;)a-=1;for(;o<n-1&&e[o]>i;)o+=1;return Math.max(6,o-a)*.45}function Yf(e,t){const n=Math.max(8,t/2);return Number.isFinite(e)?Math.min(Math.max(e,4),n):Math.min(n,Math.max(4,n/2))}function Xw(e,t){if(!Number.isFinite(e)||e<=0)return null;const n=e*.45;return Yf(n,t)}const Qw=4,Zw=4;function Ly(e,t,n,r={}){const i=Cy(e),a=i.length;if(a<8||!Number.isFinite(t))return i.slice();const o=Qw,s=a-1-Zw,l=Rr(t,o,s),c=Number(n)||0;if(Math.abs(c)<1e-4)return i.slice();const d=Rr(l+c/100*(a-1),o,s)-l;if(Math.abs(d)<1e-4)return i.slice();const p=Rr(r.falloff||My(i,l),4,a/2),f=Number.isFinite(r.strength)?r.strength:1,h=new Array(a);for(let g=0;g<a;g+=1){const b=Math.abs(g-l),S=Math.exp(-(b*b)/(2*p*p))*f,E=d*S,y=Rr(g-E,0,a-1);h[g]=Math.round(Ay(i,y))}return h[0]=i[0],h[a-1]=i[a-1],h}function Jw(e){return!Number.isFinite(e)||e<0?0:e>100?100:e}const Jl="quadgen:scaling-state-flag-changed",oh="quadgen:scaling-state-audit-updated",Qd=new Set,Vc=Object.freeze({INFO:"info",SUCCESS:"success",WARNING:"warning",ERROR:"error"});function Hc(e,t){const n={level:e,message:t,timestamp:Date.now()};Qd.forEach(r=>{try{r(n)}catch(i){console.warn("[status-service] listener error:",i)}})}function Z(e){Hc(Vc.INFO,e)}function eC(e){Hc(Vc.SUCCESS,e)}function tC(e){Hc(Vc.WARNING,e)}function qc(e){Hc(Vc.ERROR,e)}function nC(e){return typeof e!="function"?()=>{}:(Qd.add(e),()=>{Qd.delete(e)})}Xe("statusService",{showStatus:Z,showSuccess:eC,showWarning:tC,showError:qc,subscribeStatus:nC},{exposeOnWindow:typeof window<"u",windowAliases:["showStatus","showSuccess","showWarning","showError"]});const rC=typeof globalThis<"u"?globalThis:{};function iC(e){return String(e).replace(/[&<>"']/g,t=>{switch(t){case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";case'"':return"&quot;";case"'":return"&#39;";default:return t}})}class Iy{constructor(){this.lastStatusMessage={text:"",ts:0}}addChatMessage(t,n){if(!m.chatHistory){console.warn("Chat history element not found, cannot add message:",t,n);return}const r=document.createElement("div");r.className=`chat-line ${t}`;const i=t==="user"?"> ":"";if(t==="assistant"){let a=iC(n).replace(/\*\*(.*?)\*\*/g,"<strong>$1</strong>").replace(/\*(.*?)\*/g,"<em>$1</em>").replace(/^- (.+)$/gm,"â€¢ $1").replace(/^\* (.+)$/gm,"â€¢ $1").replace(/^(\d+\.\s)/gm,"$1");r.innerHTML=a}else r.textContent=i+n;if(t==="system"){const a=String(n||"");/^\s*error\s*:/i.test(a)?r.classList.add("error"):(/^\s*assistant\s*:/i.test(a)||/processing request/i.test(a))&&r.classList.add("info")}m.chatHistory.appendChild(r),m.chatHistory.scrollTop=m.chatHistory.scrollHeight;try{const a=rC.claudeAssistant;t==="system"&&typeof a?.addSystemContext=="function"&&a.addSystemContext(n)}catch{}}addStatusMessage(t,n=1e3){const r=Date.now();(this.lastStatusMessage.text!==t||r-this.lastStatusMessage.ts>n)&&(this.addChatMessage("system",t),this.lastStatusMessage={text:t,ts:r})}addErrorMessage(t){this.addChatMessage("system",`Error: ${t}`)}addSuccessMessage(t){this.addChatMessage("system",`âœ… ${t}`)}addWarningMessage(t){this.addChatMessage("system",`âš ï¸ ${t}`)}addProcessingMessage(t){this.addChatMessage("system",`Assistant: ${t}â€¦`)}addConnectionMessage(t){this.addChatMessage("system",t)}clearMessages(){m.chatHistory&&(m.chatHistory.innerHTML=""),this.lastStatusMessage={text:"",ts:0}}addApiKeyStatus(t,n){const i={valid:"âœ…",invalid:"âŒ",cleared:"ðŸ”‘",set:"âš ï¸"}[t]||"";this.addChatMessage("system",`${i} ${n}`)}addChannelOperationMessage(t,n=""){const r=n?`${t}: ${n}`:t;this.addChatMessage("system",r)}addModelConnectionMessage(t){this.addStatusMessage(t,1e3)}}const xn=new Iy;function ky(e,t){xn.addChatMessage(e,t)}function pn(e,t){xn.addStatusMessage(e,t)}function Zd(e){xn.addErrorMessage(e)}function Dy(e){xn.addSuccessMessage(e)}function Py(e){xn.addWarningMessage(e)}function xy(e){xn.addProcessingMessage(e)}function By(e){xn.addConnectionMessage(e)}function Ty(e,t){xn.addApiKeyStatus(e,t)}function Oy(e,t){xn.addChannelOperationMessage(e,t)}function _y(){xn.clearMessages()}Xe("statusMessages",{statusMessages:xn,addChatMessage:ky,addStatusMessage:pn,addErrorMessage:Zd,addSuccessMessage:Dy,addWarningMessage:Py,addProcessingMessage:xy,addConnectionMessage:By,addApiKeyStatus:Ty,addChannelOperationMessage:Oy,clearChatMessages:_y},{exposeOnWindow:typeof window<"u",windowAliases:["addChatMessage","statusMessages"]});const Jd=new Set,ep=wa(),Jt=(()=>{const e=ep._autoLimitState;if(e&&typeof e=="object")return e;const t={};return ep._autoLimitState=t,t})();function zs(){ep._autoLimitState=Jt}zs();function fo(e){if(!e)return{};if(typeof structuredClone=="function")try{return structuredClone(e)}catch{}try{return JSON.parse(JSON.stringify(e))}catch{return{...e}}}function jc(e){const t=fo(Jt);Jd.forEach(n=>{try{n(t,fo(e))}catch(r){console.warn("[auto-limit-state] listener error",r)}})}function Wc(){return Jt}function Ny(e){const t=fo(Jt);return Object.keys(Jt).forEach(n=>{delete Jt[n]}),e&&typeof e=="object"&&Object.keys(e).forEach(n=>{Jt[n]=e[n]}),zs(),jc(t),Jt}function Xf(e,t){if(!e)return null;const n=fo(Jt);return t&&typeof t=="object"&&Object.keys(t).length>0?Jt[e]=t:delete Jt[e],zs(),jc(n),Jt[e]||null}function Qf(e){if(!e||!Jt[e])return;const t=fo(Jt);delete Jt[e],zs(),jc(t)}function Fy(){if(!Object.keys(Jt).length)return;const e=fo(Jt);Object.keys(Jt).forEach(t=>delete Jt[t]),zs(),jc(e)}function Zf(e){return typeof e!="function"?()=>{}:(Jd.add(e),()=>{Jd.delete(e)})}ri({getAutoLimitState:Wc,setAutoLimitState:Ny,setChannelAutoLimitMeta:Xf,clearChannelAutoLimitMeta:Qf,resetAutoLimitState:Fy,subscribeAutoLimitState:Zf});Xe("autoLimitState",{getAutoLimitState:Wc,setAutoLimitState:Ny,setChannelAutoLimitMeta:Xf,clearChannelAutoLimitMeta:Qf,resetAutoLimitState:Fy,subscribeAutoLimitState:Zf},{exposeOnWindow:typeof window<"u",windowAliases:["getAutoLimitState","setAutoLimitState","setChannelAutoLimitMeta","clearChannelAutoLimitMeta","resetAutoLimitState"]});const Kc=typeof document<"u",aC=Kc&&typeof document.getElementById=="function",oC=Kc&&typeof document.createElement=="function",Xn=typeof window<"u"?window:globalThis,ja=Kc,sh=[10,20,30,40,50,60,70,80,90,100];function lh(){return{id:"sessionStatus",className:"virtual-session-status",style:{},innerHTML:"Â ",textContent:"Â ",setAttribute:()=>{}}}class sC{constructor(){this.sessionStatusElement=null,this.processingLabels=new Map,this.isInitialized=!1,this.lastStatusBaseLine=null,this.lastZoomPercent=100}initialize(){if(!this.isInitialized){if(console.log("ðŸŽ¯ Graph Status system initializing..."),!aC){console.log("âš ï¸ Document APIs unavailable; using virtual session status element for tests/headless runs."),this.sessionStatusElement=lh(),m&&!m.sessionStatus&&(m.sessionStatus=this.sessionStatusElement),this.isInitialized=!0;return}this.sessionStatusElement=document.getElementById("sessionStatus"),this.sessionStatusElement?(console.log("âœ… Found existing session status element:",this.sessionStatusElement),console.log("Element styles:",{display:this.sessionStatusElement.style.display,visibility:this.sessionStatusElement.style.visibility,position:this.sessionStatusElement.style.position,className:this.sessionStatusElement.className,textContent:this.sessionStatusElement.textContent}),console.log("ðŸŽ¯ Using existing session status element with proper styling")):(console.log("ðŸ” Session status element not found, creating it..."),this.createSessionStatusElement()),m&&!m.sessionStatus&&(m.sessionStatus=this.sessionStatusElement),this.isInitialized=!0,console.log("ðŸŽ¯ Graph Status system initialized"),this.updateSessionStatus()}}createSessionStatusElement(){if(console.log("ðŸ” Attempting to create session status element..."),!oC){console.log("âš ï¸ document.createElement unavailable; creating virtual session status element"),this.sessionStatusElement=lh();return}const t=document.createElement("div");t.id="graphStatusContainer",t.className="fixed top-1 right-4 z-50 bg-white bg-opacity-90 px-2 py-1 rounded shadow-sm",t.style.fontSize="11px",t.style.fontFamily="monospace",t.style.border="none",this.sessionStatusElement=document.createElement("span"),this.sessionStatusElement.id="sessionStatus",this.sessionStatusElement.className="text-gray-700",this.sessionStatusElement.innerHTML="&nbsp;",t.appendChild(this.sessionStatusElement),document.body&&typeof document.body.appendChild=="function"&&document.body.appendChild(t),console.log("ðŸ“Š Created session status element at top of page (visible fallback)",{element:this.sessionStatusElement,container:t});const n=["#inkChart",".chart-container","#chartContainer",'[id*="chart"]','[class*="chart"]'];for(const r of n){const i=document.querySelector(r);if(i){console.log(`ðŸŽ¯ Found potential graph container: ${r}`,i);break}}}updateSessionStatus(){if(!this.sessionStatusElement){console.log("âš ï¸ Session status element not found, cannot update status");return}console.log("ðŸ”„ Updating session status...");try{const t=Ee(),n=t&&t.filename?t.filename:"none";let r="none";try{const b=D?.getGlobalData?.()||null,S=D?.globalApplied;if(b&&S)r=m.globalLinearizationFilename?.textContent||b.filename||"data";else{const y=gt();y.linearizationApplied&&y.linearizationData&&(r=y.linearizationData.filename||"data")}const E=D?.getGlobalBakedMeta?.();E&&(r=`*BAKED* ${E.filename||r||"correction"}`)}catch{}const a=(()=>{try{const b=gt();if(b.contrastIntent)return b.contrastIntent}catch{}return null})()||(ja?Xn.contrastIntent:{})||{},o=String(a.id||"linear"),s=a.name||"Linear",l=a.params||{};let c="";if(o==="soft")c=" (Î³â‰ˆ0.85)";else if(o==="hard")c=" (Î³â‰ˆ1.20)";else if(o==="custom_gamma"){const b=l.gamma??1;c=` (Î³=${Number(b).toFixed?Number(b).toFixed(2):b})`}else if(o==="filmic"||o==="custom_filmic"){const b=Number(l.filmicGain??l.gain??.55),S=Number(l.shoulder??.35);c=` (gain ${isFinite(b)?b.toFixed(2):"0.55"}, shoulder ${isFinite(S)?S.toFixed(2):"0.35"})`}const u=`${s}${c}`,d=[];n&&n!=="none"&&d.push(`Quad: ${n}`),r&&r!=="none"&&d.push(`Global: ${r}`),o!=="linear"&&d.push(`Intent: ${u}`);const p=d.join(" â€¢ "),f=this.getChartZoomPercent();let h=null;f&&f!==100&&(h=`Zoom: ${f}% max`,d.push(h));const g=d.join(" â€¢ ");this.sessionStatusElement.textContent=g||"Â ",console.log("ðŸ“Š Session status updated:",{line:g||"(empty)",parts:d,quadName:n,globalName:r,intentId:o,zoomPercent:this.getChartZoomPercent()}),g&&g!=="Â "&&(p===this.lastStatusBaseLine&&f!==this.lastZoomPercent?console.log("ðŸ’¬ Skipped Lab Tech status message (zoom-only change)."):(xn.addStatusMessage(`Graph: ${g}`,2e3),console.log("ðŸ’¬ Added graph status to Lab Tech chat:",g))),Je(),this.lastStatusBaseLine=p,this.lastZoomPercent=f}catch(t){console.warn("Error updating session status:",t)}}getChartZoomPercent(){try{const t=gt(),n=Number.isFinite(t.chartZoomIndex)?t.chartZoomIndex:sh.length-1;return sh[n]||100}catch{return 100}}updateProcessingDetail(t){try{if(!t)return;const n=$r(t);if(!n){console.log("[status] missing row",t);return}const r=n.querySelector(".processing-label");if(!r){console.log("[status] missing label",t);return}this.processingLabels.set(t,r),console.log("[status] seeded label",t),r.textContent="â†’ Linear ramp",r.setAttribute("title","â†’ Linear ramp");const i=Ee()||{},a=i.curves||{},o=i.originalCurves||{},s=i.sources||{},l=(i.keyPointsMeta||{})[t]||{},c=typeof D.getGlobalBakedMeta=="function"?D.getGlobalBakedMeta():null,u=!!(l.bakedGlobal||c),d=l.bakedFilename||c?.filename||null,p=dC(t),f=uC(),h=[],g=a[t],b=Array.isArray(g);let S=!1;const E=s?s[t]:null;if(E==="smart"||E==="ai"){S=!0;const _=o?o[t]:null;lC(g,_)&&(S=!1)}const y=Te.get(t)?.points||null,v=Array.isArray(y)?y.length:null,A=p.data&&!p.enabled;if(S&&p.data&&A){const _=ur(p.filename||p.data.filename||"unknown file",p.edited),C=v?`${v} key points`:Pt(p.data),x=[];if(u){const k=d||p.data?.filename||_||"correction",N=v?`*BAKED* ${k} (${v} key points)`:`*BAKED* ${k}`;x.push(N)}x.push(`${_} (${C})`);const P=x.join(" â€¢ ");r.textContent=P,r.setAttribute("title",P);return}if(b)if(S){if(u){const C=d||f.data?.filename||"correction";h.push(`*BAKED* ${C}`)}const _=v&&v>0?` (${v} key points)`:"";h.push(`Smart Curve${_}`)}else{const _=i.filename||"loaded .quad";h.push(_)}if(p.data&&p.enabled){const _=p.data.format||"curve data",C=ur(p.filename||p.data.filename||"unknown file",p.edited),x=Pt(p.data);h.push(`channel: ${_} â€¢ ${C} (${x})`)}if(f.data&&f.applied){const _=f.data.format||"linearization",C=ur(f.data.filename||"unknown file",!!f.data.edited),x=Pt(f.data);h.push(`Global: ${_} â€¢ ${C} (${x})`)}else if(f.data&&u){const _=f.data.format||"linearization",C=ur(d||f.data.filename||"unknown file",!!f.data.edited),x=Pt(f.data);h.push(`Global (baked): ${_} â€¢ ${C} (${x})`)}const w=pC(t);if(w&&h.push(w),h.length===0){r.textContent="â†’ Linear ramp",r.setAttribute("title","Linear ramp");return}const M=h.join(" | ");h.length>1&&(h[0]=`${h[0]} â†´`),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[status] processing segments",t,h);const I=h.map(_=>`<span>${cC(_)}</span>`).join("<br>");r.innerHTML=I,r.setAttribute("title",M)}catch(n){console.warn(`Error updating processing detail for ${t}:`,n)}}addGraphStatusMessage(t,n=2e3){if(!this.sessionStatusElement)return;const r=this.sessionStatusElement.textContent,i=this.sessionStatusElement.style.color||"",a=this.sessionStatusElement.style.backgroundColor||"";this.sessionStatusElement.textContent=t,this.sessionStatusElement.style.color="#059669",this.sessionStatusElement.style.backgroundColor="#ecfdf5",this.sessionStatusElement.style.fontWeight="bold",console.log(`ðŸ“Š Showing graph message: "${t}" for ${n}ms`),Je(),setTimeout(()=>{this.sessionStatusElement.textContent=r,this.sessionStatusElement.style.color=i,this.sessionStatusElement.style.backgroundColor=a,this.sessionStatusElement.style.fontWeight="bold",console.log("ðŸ“Š Restored original session status content"),Je()},n),xn.addStatusMessage(`ðŸ“Š ${t}`,1e3)}clearSessionStatus(){this.sessionStatusElement&&(this.sessionStatusElement.textContent="Â ")}connectGlobalFunctions(){ja&&(Xn.updateSessionStatus=()=>this.updateSessionStatus(),Xn.updateProcessingDetail=t=>this.updateProcessingDetail(t),Xn.updateProcessingDetailForce=t=>this.updateProcessingDetail(t),Xn.graphStatus=this)}}function lC(e,t){if(!Array.isArray(e)||!Array.isArray(t)||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function cC(e){return e==null?"":String(e).replace(/[&<>"']/g,t=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"})[t])}function uC(){const e={data:null,applied:!1};try{const t=typeof D.getGlobalData=="function"?D.getGlobalData():null;t&&(e.data=t,e.applied=!!D.globalApplied)}catch{}if(!e.data)try{const t=gt();t?.linearizationData&&(e.data=t.linearizationData,e.applied=!!t.linearizationApplied)}catch{}return!e.data&&ja&&(e.data=Xn.linearizationData||null,e.applied=!!Xn.linearizationApplied),e}function dC(e){const t={data:null,enabled:!1,filename:null,edited:!1};try{const n=typeof D.getPerChannelData=="function"?D.getPerChannelData(e):null;n&&(t.data=n,t.enabled=typeof D.isPerChannelEnabled=="function"?D.isPerChannelEnabled(e):!!n.enabled)}catch{}if(!t.data)try{const r=gt()?.perChannelLinearization||{};r&&r[e]&&(t.data=r[e],typeof r[e]?.enabled=="boolean"&&(t.enabled=r[e].enabled))}catch{}if(!t.data&&ja&&Xn.perChannelLinearization){const n=Xn.perChannelLinearization[e];n&&(t.data=n,typeof n.enabled=="boolean"&&(t.enabled=n.enabled))}return ja&&Xn.perChannelEnabled&&Xn.perChannelEnabled[e]!=null&&(t.enabled=!!Xn.perChannelEnabled[e]),t.data&&(typeof t.data.enabled=="boolean"&&!t.enabled&&(t.enabled=t.data.enabled),t.edited=!!t.data.edited,t.filename=t.data.filename||null,!t.filename&&ja&&Xn.perChannelFilenames&&(t.filename=Xn.perChannelFilenames[e]||null)),t}function pC(e){try{const t=!!m?.autoWhiteLimitToggle?.checked,n=!!m?.autoBlackLimitToggle?.checked;if(!t&&!n)return null;const r=Wc()?.[e];if(!r)return null;const i=[];return n&&r.black&&Number.isFinite(r.black.widthPercent)&&i.push(`B ${r.black.widthPercent.toFixed(1)}%`),t&&r.white&&Number.isFinite(r.white.widthPercent)&&i.push(`W ${r.white.widthPercent.toFixed(1)}%`),i.length?`Auto limit: ${i.join(", ")}`:null}catch{return null}}const _r=new sC;Kc&&document.readyState==="loading"&&typeof document.addEventListener=="function"?document.addEventListener("DOMContentLoaded",()=>{_r.initialize(),_r.connectGlobalFunctions()}):(_r.initialize(),_r.connectGlobalFunctions());function yt(){_r.updateSessionStatus()}qw(yt);function un(e){_r.updateProcessingDetail(e)}let Gl=null;const ch=wa();function Gy(e){if(!e||typeof e!="object"){Gl=null,ch.__LAST_SMART_OVERLAY_DETAILS=null;return}Gl={channelName:e.channelName||null,selectedOrdinal:e.selectedOrdinal||null,points:Array.isArray(e.points)?e.points.map(t=>({...t})):[]},ch.__LAST_SMART_OVERLAY_DETAILS=Gl}function fC(){return Gl}function mC(e,t,n){e.strokeStyle=n.axis,e.lineWidth=2,e.beginPath();const r=t.bottomPadding||t.padding;e.moveTo(t.leftPadding,t.padding),e.lineTo(t.leftPadding,t.height-r),e.lineTo(t.leftPadding+t.chartWidth,t.height-r),e.stroke()}function hC(e,t,n){const a=t.leftPadding-10-1,o=t.padding,s=t.bottomPadding||t.padding,l=t.height-t.padding-s;e.fillStyle="#ffffff",e.fillRect(a,o,10,l);const c=e.createLinearGradient(0,o,0,o+l);return c.addColorStop(0,"#000000"),c.addColorStop(1,"#ffffff"),e.fillStyle=c,e.fillRect(a,o,10,l),e.strokeStyle=n.border,e.lineWidth=1,e.strokeRect(a,o,10,l),{width:10,gap:1,x:a,y:o,height:l}}function gC(e,t,n){const a=t.bottomPadding||t.padding,o=t.height-a;e.fillStyle="#ffffff",e.fillRect(t.leftPadding,o,t.chartWidth,10);const s=e.createLinearGradient(t.leftPadding,0,t.leftPadding+t.chartWidth,0);return s.addColorStop(0,"#ffffff"),s.addColorStop(1,"#000000"),e.fillStyle=s,e.fillRect(t.leftPadding,o,t.chartWidth,10),e.strokeStyle=n.border,e.lineWidth=1,e.strokeRect(t.leftPadding,o,t.chartWidth,10),{height:10,gap:0,y:o}}function bC(e,t,n,r,i,a){const o=t.dpr||1,s=Math.max(10,Math.round(12*o*10)/10);e.fillStyle=n.text,e.font=`${s}px system-ui`,e.textAlign="center";const l=t.bottomPadding||t.padding,c=a?a.height+a.gap+17*o:29*o;for(let p=0;p<=10;p++){const f=t.leftPadding+p*t.chartWidth/10,h=p*10;h===0||h===100?e.font=`bold ${s}px system-ui`:e.font=`${s}px system-ui`,e.fillText(`${h}`,f,t.height-l+c)}e.textAlign="right",e.fillStyle=n.text;const u=i?i.width+i.gap+11*o:23*o,d=t.leftPadding-u;r.forEach(p=>{const f=Qt(p,t),h=Math.abs(p)<.001||Math.abs(p-t.displayMax)<.001;e.font=h?`bold ${s}px system-ui`:`${s}px system-ui`;const g=Math.abs(p-Math.round(p))<.001?Math.round(p).toString():p.toFixed(1);e.fillText(g,d,f+4*o)})}function yC(e,t,n,r){t.dpr}function SC(e){const t=e<=50?5:10,n=[];for(let r=0;r<=e;r+=t)n.push(Math.round(r*100)/100);return n[n.length-1]!==e&&n.push(e),n}function vC(e,t,n,r,i,a,o,s,l,c={}){const{drawMarkers:u=!0,showLabels:d=!0,boxSize:p=6,isDragging:f=!1}=c;if(console.log(`[RENDER DEBUG] drawSmartKeyPointOverlays called for ${r}: keyPoints=${i?.length}, selectedOrdinal=${s}`),!i||i.length===0){console.log(`[RENDER DEBUG] No keyPoints for ${r}`);return}try{e.save();const h="16px system-ui";e.font=h,e.textBaseline="bottom",e.textAlign="center";const g=hi(t);console.log(`[RENDER DEBUG] About to draw ${i.length} points for ${r}`);const b=[];i.forEach((S,E)=>{console.log(`[RENDER DEBUG] Drawing point ${E+1}: input=${S.input}, output=${S.output}`);const y=Math.max(0,Math.min(1,(S.input||0)/100)),v=t.leftPadding+y*t.chartWidth,A=Ea(r,S.output||0);let w=Math.max(0,Math.min(100,A));if(!f&&a&&a.length>0){const Gt=Math.round(y*(a.length-1)),ir=a[Gt]||0,Lt=Math.max(0,Math.min(100,ir/o*100));Math.abs(Lt-w)>10&&(w=Lt),console.log(`[RENDER DEBUG] Point ${E+1}: input=${S.input}%, curveIndex=${Gt}, stored=${S.output}, curve=${Lt.toFixed(1)}%, finalDisplay=${w.toFixed(1)}%`)}const M=Math.max(0,Math.min(g,w)),I=Qt(M,t);b.push({ordinal:E+1,input:S.input,outputPercent:w,chartPercent:M,canvasX:v,canvasY:I});const _=p/2,C=p/2,x=E+1===s,P=Math.round(v-_)+.5,k=Math.round(I-C)+.5;if(console.log(`[RENDER DEBUG] Point ${E+1}: isSelected=${x}, drawMarkers=${u}, showLabels=${d}`),u&&(console.log(`[RENDER DEBUG] Drawing marker for point ${E+1} at (${P}, ${k})`),x?(e.save(),e.lineWidth=3,e.strokeStyle=l,e.strokeRect(P-2,k-2,p+4,p+4),e.restore(),e.fillStyle="rgba(255,255,255,1)"):e.fillStyle="rgba(255,255,255,0.95)",e.fillRect(P,k,p,p),e.strokeStyle=l,e.lineWidth=1,e.strokeRect(P,k,p,p)),!d)return;let N=v,F=I-C-3;const U=g*.05,j=g-U;M<=U&&(N+=8),M>=j&&(N-=8);const B=t.padding+8,G=t.bottomPadding||t.padding,V=t.height-G-2;F<B&&(F=B),F>V&&(F=V);const K=String(E+1),se=x?34:18;e.font=`bold ${se}px system-ui`;const W=e.measureText(K),fe=x?9:7,Se=Math.ceil(W.width)+fe*2,we=Math.round(se*1.22),Ne=Math.round(N-Se/2)+.5,ct=Math.round(F-we+1)+.5;let mt=0,Vt=0,xt=0;try{const Gt=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i.exec(String(l));Gt&&(mt=parseInt(Gt[1],16),Vt=parseInt(Gt[2],16),xt=parseInt(Gt[3],16))}catch{}const Bt=(mt*299+Vt*587+xt*114)/1e3>=140?"#000000":"#FFFFFF";e.fillStyle=l,e.fillRect(Ne,ct,Se,we),e.strokeStyle="rgba(0,0,0,0.2)",e.lineWidth=1,e.strokeRect(Ne+.5,ct+.5,Se-1,we-1),e.fillStyle=Bt,e.fillText(K,Math.round(N)+.5,Math.round(F)+.5),e.font=h}),e.restore(),Gy({channelName:r,selectedOrdinal:s,points:b})}catch(h){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("Smart key point overlay failed:",h)}}Xe("chartRenderer",{setSmartOverlayDebug:Gy,getSmartOverlayDebug:fC},{exposeOnWindow:typeof window<"u"});function EC(e,t){const n=Number.isFinite(t)&&t>0?t:100,r=Number.isFinite(e)?e:0;if(!Number.isFinite(n)||n<=0)return 0;const i=Math.max(0,Math.min(n,r));return Math.max(0,Math.min(100,i))}function Ry(e){return typeof document>"u"?null:document.querySelector(`tr[data-channel="${e}"]`)}function wC(e){switch(e){case"bell":return{icon:"ðŸ””",label:"Bell curve"};case"monotonic":return{icon:"ðŸ“ˆ",label:"Monotonic rise"};case"flat":return{icon:"âž¡ï¸",label:"Flat profile"};default:return{icon:"",label:"Curve profile"}}}function CC(e){if(typeof document>"u")return;const n=Ry(e)?.querySelector("[data-channel-shape]");if(!n)return;const r=Vr(e);if(!r||!r.classification||r.classification==="unknown"){n.classList.add("hidden"),n.removeAttribute("data-shape-type"),n.removeAttribute("title"),ac(e);return}const{icon:i,label:a}=wC(r.classification);if(!i){n.classList.add("hidden");return}const o=typeof r.peakInputPercent=="number"?`${r.peakInputPercent.toFixed(1)}% input`:"â€”",s=Number.isFinite(r.confidence)?`${(r.confidence*100).toFixed(0)}% confidence`:null,l=[a,`Apex ${o}`,s].filter(Boolean);n.textContent=i,n.setAttribute("title",l.join(" â€¢ ")),n.setAttribute("aria-label",l[0]||a),n.setAttribute("role","img"),n.dataset.shapeType=r.classification,n.classList.remove("hidden"),ac()}function uh(e){try{const t=Ee(),n=t?.sources?.[e];let r=n==="smart"||n==="ai";if(r){const i=t?.curves?.[e],a=t?.originalCurves?.[e];Array.isArray(i)&&Array.isArray(a)&&i.length===a.length&&i.every((s,l)=>s===a[l])&&(r=!1)}return r}catch{return!1}}function Yn(e){try{const t=Ry(e),n=t?t.querySelector(".processing-label"):null;if(!n)return;const r=[],i=Ee(),a=!!(i&&i.curves&&i.curves[e]&&uh(e)),o=D.getPerChannelData(e),s=D.isPerChannelEnabled(e);if(a&&o&&!!(o&&!s)){const p=o.filename||"unknown file",f=ur(p,!!o.edited),h=Te.get(e)?.points,g=Array.isArray(h)?h.length:null,b=g?`${g} key points`:Pt(o),S=`${f} (${b})`;n.textContent=S,n.setAttribute("title",S);return}if(i&&i.curves&&i.curves[e])if(uh(e)){const f=Te.get(e)?.points,h=Array.isArray(f)?` (${f.length} key points)`:"";r.push(`Smart Curve${h}`)}else{const f=i.filename||"loaded .quad";r.push(`${f}`)}if(o){const p=o.format||"curve data",f=o.filename||"unknown file",h=ur(f,!!o.edited),g=Pt(o);s&&r.push(`channel: ${p} â€¢ ${h} (${g})`)}const c=D.getGlobalData(),u=D.globalApplied,d=typeof D.getGlobalBakedMeta=="function"?D.getGlobalBakedMeta():null;if(c&&Array.isArray(c.samples)){const p=c.format||"linearization",f=d?.filename||c.filename||"unknown file",h=ur(f,!!c.edited),g=Pt(c);u?r.push(`Global: ${p} â€¢ ${h} (${g})`):d&&r.push(`Global (baked): ${p} â€¢ ${h} (${g})`)}else d&&d.filename&&r.push(`Global (baked): ${d.filename}`);try{const p=!!m?.autoWhiteLimitToggle?.checked,f=!!m?.autoBlackLimitToggle?.checked,g=Wc()?.[e];if((p||f)&&g){const b=[];f&&g.black&&isFinite(g.black.widthPercent)&&b.push(`B ${g.black.widthPercent.toFixed(1)}%`),p&&g.white&&isFinite(g.white.widthPercent)&&b.push(`W ${g.white.widthPercent.toFixed(1)}%`),b.length&&r.push(`Auto limit: ${b.join(", ")}`)}}catch{}if(r.length===0)n.textContent="â†’ Linear ramp",n.setAttribute("title","Linear ramp");else{const p=r.join(" â€¢ "),f=`â†’ ${p}`;n.textContent=f,n.setAttribute("title",p)}CC(e)}catch(t){console.warn(`Error updating processing detail for ${e}:`,t)}}function Us(){try{const e=lt();e&&e.channels&&e.channels.forEach(t=>{Yn(t)})}catch(e){console.warn("Error updating all processing details:",e)}}$w(Yn);Vw(Us);function zy(){console.log("ðŸ“Š Initializing processing status system..."),Us(),console.log("âœ… Processing status system initialized")}ri({updateProcessingDetail:Yn,updateAllProcessingDetails:Us,initializeProcessingStatus:zy});Xe("processingStatus",{updateProcessingDetail:Yn,updateAllProcessingDetails:Us,initializeProcessingStatus:zy},{exposeOnWindow:typeof window<"u",windowAliases:["updateProcessingDetail","updateAllProcessingDetails"]});const Pi=7,tp=Pi,fa=3;function AC(e){return Number.isFinite(e)?e<=0?0:e>=1?1:e:null}function Wa(e,t=fa){if(!Number.isFinite(e))return null;const n=10**Math.max(0,Math.min(6,t));return Math.round(e*n)/n}function dh(e){if(!e||typeof e!="object")return null;const t=[e.normalizedAfter,e.normalized,e.normalizedBefore];for(let n=0;n<t.length;n+=1){const r=AC(Number(t[n]));if(r!==null)return r}return null}function Uy(e=[]){const t=new Set,n=[];return e.forEach(r=>{typeof r!="string"||!r||t.has(r)||(t.add(r),n.push(r))}),n}function MC(e,t,n,r){if(!n.length)return null;n.sort((c,u)=>u.magnitude-c.magnitude);const i=n[0],a=i.delta>=0?"rise":"drop",o=n.map(c=>({channel:c.channel,delta:Wa(c.delta,fa),magnitude:Wa(c.magnitude,fa),direction:c.delta>=0?"rise":"drop"})),s=n.map(c=>c.channel),l={index:e,kind:a,magnitude:Wa(i.magnitude,fa),threshold:r,channels:s,details:o};return t&&Number.isFinite(t.inputPercent)&&(l.inputPercent=Number(t.inputPercent)),l}function LC(e,t={}){const{thresholdPercent:n=tp,autoRaiseInProgress:r=!1,channelNames:i=null}=t;if(!Array.isArray(e)||e.length<2)return{};const a=Number.isFinite(n)&&n>0?n:tp;if(r)return{};const o={};for(let s=1;s<e.length;s+=1){const l=e[s],c=e[s-1];if(!l||!c)continue;const u=Uy(Array.isArray(i)&&i.length?i:[...Object.keys(l.perChannel||{}),...Object.keys(c.perChannel||{})]);if(!u.length)continue;const d=[];u.forEach(f=>{const h=l.perChannel?.[f],g=c.perChannel?.[f];if(!h||!g)return;const b=dh(h),S=dh(g);if(b===null||S===null)return;const E=b*100,y=S*100,v=E-y,A=Math.abs(v);A>=a&&d.push({channel:f,delta:v,magnitude:A})});const p=MC(Number.isInteger(l?.index)?l.index:s,l,d,a);p&&(o[p.index]=p)}return o}function IC(e){if(!e||typeof e!="object")return null;const t=typeof e.channel=="string"&&e.channel?e.channel:null;if(!t)return null;const n=Number(e.delta),r=Number.isFinite(e.magnitude)?Math.abs(e.magnitude):Number.isFinite(n)?Math.abs(n):null,i=r!=null?Wa(r,fa):null,a=e.direction==="drop"?"drop":e.direction==="rise"?"rise":Number.isFinite(n)&&n<0?"drop":"rise";return{channel:t,delta:Number.isFinite(n)?Wa(n,fa):null,magnitude:i,direction:a}}function Yc(e){if(!e||typeof e!="object")return{};const t={};return Object.entries(e).forEach(([n,r])=>{if(!r||typeof r!="object")return;const i=Number.parseInt(n,10);if(!Number.isInteger(i))return;const a=Number.isFinite(r.threshold)?Math.max(0,r.threshold):tp,o=Uy(Array.isArray(r.channels)?r.channels:[]),s=Array.isArray(r.details)?r.details.map(IC).filter(Boolean):[];!o.length&&s.length&&s.forEach(d=>{o.includes(d.channel)||o.push(d.channel)});const l=Number.isFinite(r.magnitude)?Math.abs(r.magnitude):s.length?Math.max(...s.map(d=>Math.abs(d.magnitude??d.delta??0))):null,c=l!=null?Wa(l,fa):null,u={index:i,kind:r.kind==="drop"?"drop":"rise",magnitude:c,threshold:a,channels:o,details:s};Number.isFinite(r.inputPercent)&&(u.inputPercent=Number(r.inputPercent)),t[i]=u}),t}function Jf(e){const t=Yc(e),n={};return Object.entries(t).forEach(([r,i])=>{n[r]={index:i.index,kind:i.kind,magnitude:i.magnitude,threshold:i.threshold,channels:Array.isArray(i.channels)?i.channels.slice():[],details:Array.isArray(i.details)?i.details.map(a=>({...a})):[],inputPercent:Number.isFinite(i.inputPercent)?i.inputPercent:void 0},Number.isFinite(n[r].inputPercent)||delete n[r].inputPercent}),n}const $y="quadgen.compositeDebugEnabled";function kC(){if(typeof window>"u"||!window.localStorage)return null;try{const e=window.localStorage.getItem($y);return e===null?null:e==="true"}catch(e){return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CompositeDebug] Failed to read storage flag:",e),null}}function Vy(e){if(!(typeof window>"u"||!window.localStorage))try{window.localStorage.setItem($y,e?"true":"false")}catch(t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CompositeDebug] Failed to persist storage flag:",t)}}const De={enabled:!1,summary:null,snapshots:[],flags:{},selection:{index:null,percent:null},sessionId:0,lastUpdated:0},ec=new Set;let Fa=null,cn=null;function DC(e){return!e||typeof e!="object"?e:{...e}}function Hy(e=[]){return Array.isArray(e)?e.filter(t=>t&&typeof t=="object").map(t=>({channel:typeof t.channel=="string"?t.channel:typeof t.channelName=="string"?t.channelName:null,previousPercent:Number.isFinite(t.previousPercent)?t.previousPercent:null,newPercent:Number.isFinite(t.newPercent)?t.newPercent:null,desiredPercent:Number.isFinite(t.desiredPercent)?t.desiredPercent:null,locked:t.locked===!0,currentPercent:Number.isFinite(t.currentPercent)?t.currentPercent:null,reason:typeof t.reason=="string"?t.reason:null,coverage:t.coverage&&typeof t.coverage=="object"?{limit:Number.isFinite(t.coverage.limit)?t.coverage.limit:null,bufferedLimit:Number.isFinite(t.coverage.bufferedLimit)?t.coverage.bufferedLimit:null,maxNormalized:Number.isFinite(t.coverage.maxNormalized)?t.coverage.maxNormalized:null,headroom:Number.isFinite(t.coverage.headroom)?t.coverage.headroom:null}:null})):[]}function qy(){Fa&&(De.summary=De.summary?{...De.summary}:{},De.summary.autoRaisedEnds=Hy(Fa.entries),De.summary.autoRaiseContext=Fa.context?{...Fa.context}:null)}function jy(e,t={}){return Fa={entries:Hy(e),context:t&&typeof t=="object"?{...t}:null},qy(),De.lastUpdated=Date.now(),mo(),xo()}function $s(e){if(!e||typeof e!="object")return null;const t={};e.perChannel&&typeof e.perChannel=="object"&&Object.entries(e.perChannel).forEach(([r,i])=>{t[r]=i&&typeof i=="object"?{...i}:{}});const n=Array.isArray(e.smoothingWindows)?e.smoothingWindows.map(r=>!r||typeof r!="object"?null:{id:r.id??null,outgoingChannel:r.outgoingChannel??null,incomingChannels:Array.isArray(r.incomingChannels)?r.incomingChannels.slice():[],position:r.position??r.t??null,outFactor:r.outFactor??null,forced:r.forced===!0}).filter(Boolean):[];return{index:e.index??null,inputPercent:e.inputPercent??null,targetDensity:e.targetDensity??null,measurementDensity:e.measurementDensity??null,deltaDensity:e.deltaDensity??null,baselineInk:e.baselineInk??null,correctedInk:e.correctedInk??null,inkDelta:e.inkDelta??null,perChannel:t,weightingMode:e.weightingMode??null,smoothingWindows:n,ladderSelection:Array.isArray(e.ladderSelection)?e.ladderSelection.map(r=>({channel:typeof r?.channel=="string"?r.channel:null,ladderIndex:Number.isFinite(r?.ladderIndex)?r.ladderIndex:null,normalizedApplied:Number.isFinite(r?.normalizedApplied)?r.normalizedApplied:0})):[],ladderBlocked:Array.isArray(e.ladderBlocked)?e.ladderBlocked.map(r=>({channel:typeof r?.channel=="string"?r.channel:null,reason:typeof r?.reason=="string"?r.reason:null,blockedBy:typeof r?.blockedBy=="string"?r.blockedBy:null,headroom:Number.isFinite(r?.headroom)?r.headroom:null,usage:Number.isFinite(r?.usage)?r.usage:null})):[],ladderDirection:typeof e.ladderDirection=="string"?e.ladderDirection:null,ladderTrace:e.ladderTrace&&typeof e.ladderTrace=="object"?{direction:typeof e.ladderTrace.direction=="string"?e.ladderTrace.direction:null,remaining:Number.isFinite(e.ladderTrace.remaining)?e.ladderTrace.remaining:null,blocked:Array.isArray(e.ladderTrace.blocked)?e.ladderTrace.blocked.map(r=>({channel:typeof r?.channel=="string"?r.channel:null,reason:typeof r?.reason=="string"?r.reason:null,blockedBy:typeof r?.blockedBy=="string"?r.blockedBy:null,headroom:Number.isFinite(r?.headroom)?r.headroom:null,usage:Number.isFinite(r?.usage)?r.usage:null})):[],sequence:Array.isArray(e.ladderTrace.sequence)?e.ladderTrace.sequence.map(r=>({channel:typeof r?.channel=="string"?r.channel:null,ladderIndex:Number.isFinite(r?.ladderIndex)?r.ladderIndex:null,normalizedApplied:Number.isFinite(r?.normalizedApplied)?r.normalizedApplied:null,iteration:Number.isFinite(r?.iteration)?r.iteration:null,weight:Number.isFinite(r?.weight)?r.weight:null})):[]}:null}}function Xc(e){return!e||typeof e!="object"?null:{channelNames:Array.isArray(e.channelNames)?e.channelNames.slice():[],channelMaxima:e.channelMaxima?{...e.channelMaxima}:{},densityWeights:e.densityWeights?{...e.densityWeights}:{},densityConstants:e.densityConstants?{...e.densityConstants}:{},cumulativeDensity:e.cumulativeDensity?{...e.cumulativeDensity}:{},totalDensity:Number.isFinite(e.totalDensity)?e.totalDensity:null,measurementSamples:Array.isArray(e.measurementSamples)?e.measurementSamples.slice():null,measurementDeltas:Array.isArray(e.measurementDeltas)?e.measurementDeltas.slice():null,densityInputs:Array.isArray(e.densityInputs)?e.densityInputs.slice():null,coverageSummary:e.coverageSummary&&typeof e.coverageSummary=="object"?Object.keys(e.coverageSummary).reduce((n,r)=>{const i=e.coverageSummary[r];return n[r]=i&&typeof i=="object"?{...i}:null,n},{}):{},coverageLimits:e.coverageLimits?{...e.coverageLimits}:{},coverageBuffers:e.coverageBuffers?{...e.coverageBuffers}:{},warnings:Array.isArray(e.warnings)?e.warnings.slice():[],peakIndices:e.peakIndices?{...e.peakIndices}:null,weightingMode:e.weightingMode||null,densityLadder:Array.isArray(e.densityLadder)?e.densityLadder.slice():[],ladderOrderIndex:e.ladderOrderIndex&&typeof e.ladderOrderIndex=="object"?{...e.ladderOrderIndex}:{},momentumPeaks:e.momentumPeaks?{...e.momentumPeaks}:null,momentumWindow:Number.isFinite(e.momentumWindow)?e.momentumWindow:null,momentumSigma:Number.isFinite(e.momentumSigma)?e.momentumSigma:null,smoothingWindows:Array.isArray(e.smoothingWindows)?e.smoothingWindows.map(n=>!n||typeof n!="object"?null:{id:n.id??null,outgoingChannel:n.outgoingChannel??null,incomingChannels:Array.isArray(n.incomingChannels)?n.incomingChannels.slice():[],startIndex:n.startIndex??null,endIndex:n.endIndex??null,inputStart:n.inputStart??null,inputEnd:n.inputEnd??null,forced:n.forced===!0}).filter(Boolean):[],smoothingConfig:e.smoothingConfig?{...e.smoothingConfig}:null,autoRaisedEnds:Array.isArray(e.autoRaisedEnds)?e.autoRaisedEnds.map(n=>!n||typeof n!="object"?null:{channel:n.channel??n.channelName??null,previousPercent:Number.isFinite(n.previousPercent)?n.previousPercent:null,newPercent:Number.isFinite(n.newPercent)?n.newPercent:null,desiredPercent:Number.isFinite(n.desiredPercent)?n.desiredPercent:null,locked:n.locked===!0,currentPercent:Number.isFinite(n.currentPercent)?n.currentPercent:null,reason:typeof n.reason=="string"?n.reason:null,coverage:n.coverage&&typeof n.coverage=="object"?{limit:Number.isFinite(n.coverage.limit)?n.coverage.limit:null,bufferedLimit:Number.isFinite(n.coverage.bufferedLimit)?n.coverage.bufferedLimit:null,maxNormalized:Number.isFinite(n.coverage.maxNormalized)?n.coverage.maxNormalized:null,headroom:Number.isFinite(n.coverage.headroom)?n.coverage.headroom:null}:null}).filter(Boolean):[],autoRaiseContext:e.autoRaiseContext&&typeof e.autoRaiseContext=="object"?{...e.autoRaiseContext}:null,perSampleCeilingEnabled:e.perSampleCeilingEnabled===!0}}function Qc(){De.summary=null,De.snapshots=[],De.flags={},De.selection={index:null,percent:null},De.sessionId+=1,De.lastUpdated=Date.now(),Fa=null,cn=null}function mo(){if(!ec.size)return;const e=xo();ec.forEach(t=>{try{t(e)}catch(n){console.warn("[CompositeDebug] listener failed:",n)}})}function xo(){const e=typeof window<"u"&&window?window.__COMPOSITE_DEBUG_CACHE__:null,t=De.summary||(cn?cn.summary:null)||(e?e.summary:null),n=De.snapshots.length?De.snapshots:cn?cn.snapshots:e?e.snapshots:[],r=Object.keys(De.flags||{}).length?De.flags:cn&&cn.flags?cn.flags:e?e.snapshotFlags:{};return{enabled:De.enabled,summary:Xc(t),snapshots:n.map(i=>i?$s(i):null),flags:Jf(r),selection:DC(De.selection),sessionId:De.sessionId,lastUpdated:De.lastUpdated}}function PC(e){if(!Number.isInteger(e)||e<0||e>=De.snapshots.length)return null;const t=De.snapshots[e];return t?$s(t):null}function em(e){return typeof e!="function"?()=>{}:(ec.add(e),()=>{ec.delete(e)})}function ds(){return!!De.enabled}function Wy(e){const t=!!e;return De.enabled===t||(De.enabled=t,Vy(De.enabled),Qc(),mo()),De.enabled}function xC({keepEnabled:e=!1}={}){e||(De.enabled=!1,Vy(!1)),Qc(),mo()}function Ky(e){if(!Array.isArray(e))return null;for(let t=0;t<e.length;t+=1)if(e[t])return t;return null}function np(e){if(!Number.isInteger(e)||e<0||e>=De.snapshots.length||!De.snapshots[e]){De.selection={index:null,percent:null};return}const t=De.snapshots[e],n=typeof t?.inputPercent=="number"?t.inputPercent:null;De.selection={index:e,percent:n}}function Zc(e){if(!De.enabled)return null;const t=De.selection.index;return np(e),t!==De.selection.index&&(De.lastUpdated=Date.now(),mo()),De.selection.index}function Rl(e){if(!De.enabled||!Number.isInteger(e))return De.selection.index;const t=Number.isInteger(De.selection.index)?De.selection.index:Ky(De.snapshots);if(!Number.isInteger(t))return De.selection.index;let n=t+e;for(;n>=0&&n<De.snapshots.length;){if(De.snapshots[n]){Zc(n);break}n+=e>0?1:-1}return De.selection.index}function BC(e){if(!e||typeof e!="object"){Qc();return}De.summary=Xc(e.summary),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE DEBUG] assign summary keys",De.summary?Object.keys(De.summary):null,"channelCount",Array.isArray(De.summary?.channelNames)?De.summary.channelNames.length:null),qy(),De.snapshots=Array.isArray(e.snapshots)?e.snapshots.map(r=>r?$s(r):null):[];const t=Object.prototype.hasOwnProperty.call(e,"snapshotFlags")?e.snapshotFlags:e.flags;De.flags=Yc(t);const n=Number.isInteger(e.selectionIndex)?e.selectionIndex:null;if(Number.isInteger(n)&&De.snapshots[n])np(n);else{const r=Ky(De.snapshots);Number.isInteger(r)?np(r):De.selection={index:null,percent:null}}De.lastUpdated=Date.now(),De.sessionId+=1}function ps(e){if(!e||typeof e!="object"){cn=null,De.enabled&&(Qc(),mo());return}cn={summary:Xc(e.summary),snapshots:Array.isArray(e.snapshots)?e.snapshots.map(t=>t?$s(t):null):[],selectionIndex:Number.isInteger(e.selectionIndex)?e.selectionIndex:null,flags:Yc(Object.prototype.hasOwnProperty.call(e,"snapshotFlags")?e.snapshotFlags:e.flags)},typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE DEBUG] stored session cache",{summaryKeys:Object.keys(cn.summary||{}),snapshotCount:cn.snapshots.filter(t=>!!t).length}),De.enabled&&(BC(cn),mo())}function TC(){return cn?{summary:Xc(cn.summary),snapshots:cn.snapshots.map(e=>e?$s(e):null),selectionIndex:cn.selectionIndex,snapshotFlags:Jf(cn.flags)}:null}function OC(e){ps(e)}const ph=kC();ph!==null&&(De.enabled=!!ph);Xe("compositeDebug",{getCompositeDebugState:xo,getCompositeDebugSnapshot:PC,selectCompositeDebugSnapshot:Zc,stepCompositeDebugSelection:Rl,setCompositeDebugEnabled:Wy,isCompositeDebugEnabled:ds,resetCompositeDebugState:xC,commitCompositeDebugSession:OC,setCompositeAutoRaiseSummary:jy,storeCompositeDebugSession:ps,getCompositeDebugSessionCache:TC,getFlaggedSnapshots:()=>Jf(De.flags),sanitizeSnapshotFlags:Yc},{exposeOnWindow:typeof window<"u",windowAliases:["getCompositeDebugState","getCompositeDebugSnapshot","selectCompositeDebugSnapshot","stepCompositeDebugSelection","setCompositeDebugEnabled","isCompositeDebugEnabled","getCompositeDebugFlaggedSnapshots"]});const Yy="quadgen.channelDensity.v1",fh=2,fs=Object.freeze({K:1,MK:1,C:.21,LK:.054}),_C=.01,en=new Map,rp=new Set,ip=new Set;let mh=!1,ci=!0;function Vs(e){return Number.isFinite(e)?e<0?0:e>fh?fh:e:null}function Xy(e){if(!Number.isFinite(e))return"";const t=Vs(e);return t===null?"":t.toFixed(3).replace(/\.?0+$/,"")}function Qy(e){const t=fs[e];return Number.isFinite(t)?t:null}function Kr(e){if(!e)return;const t=kr(e);rp.forEach(n=>{try{n(e,t)}catch(r){console.warn("[channel-densities] subscriber failed:",r)}})}function NC(){const e=!!ci;ip.forEach(t=>{try{t(e)}catch(n){console.warn("[channel-densities] auto subscriber failed:",n)}})}function Zr(){if(typeof window>"u"||!window.localStorage)return;const e={auto:!!ci,channels:{}};en.forEach((t,n)=>{!t||!Number.isFinite(t.value)||t.source==="default"||t.source==="unset"||(e.channels[n]={value:t.value,source:t.source})});try{window.localStorage.setItem(Yy,JSON.stringify(e))}catch(t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[channel-densities] persist failed:",t)}}function Ma(){if(!mh&&(mh=!0,!(typeof window>"u"||!window.localStorage)))try{const e=window.localStorage.getItem(Yy);if(!e)return;const t=JSON.parse(e);if(!t||typeof t!="object")return;let n=t;("channels"in t||"auto"in t)&&(typeof t.auto=="boolean"&&(ci=t.auto),t.channels&&typeof t.channels=="object"?n=t.channels:n={}),en.clear();let r=!1;Object.entries(n).forEach(([i,a])=>{const o=Vs(Number(a?.value)),l=(typeof a?.source=="string"?a.source:"solver")==="manual"?"manual":"solver";if(o===null)return;const c=Qy(i);if(l!=="manual"&&Number.isFinite(c)&&c>0&&o<=_C){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[channel-densities] restoring default",{channel:i,stored:o,defaultValue:c}),r=!0;return}en.set(i,{value:o,source:l})}),r&&Zr()}catch(e){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[channel-densities] load failed:",e)}}function FC(e=[]){Ma();const t=new Set(Array.isArray(e)?e:[]);let n=!1;en.forEach((r,i)=>{t.has(i)||(en.delete(i),n=!0)}),n&&Zr()}function kr(e){if(Ma(),!e)return{value:null,source:"unset"};const t=en.get(e);if(t&&Number.isFinite(t.value))return{value:Vs(t.value),source:t.source||"manual"};const n=Qy(e);return n!==null?{value:n,source:"default"}:{value:null,source:"unset"}}function Zy(e,t){Ma();const n=Vs(t);if(!e)return kr(e);if(n===null)return en.delete(e)&&Zr(),Kr(e),kr(e);if(n<=0){const i=en.get(e);return(!i||i.value!==0||i.source!=="pending")&&(en.set(e,{value:0,source:"pending"}),Zr()),Kr(e),{value:0,source:"pending"}}const r=en.get(e);return r&&r.value===n&&r.source==="manual"?(Kr(e),{value:n,source:"manual"}):(en.set(e,{value:n,source:"manual"}),Zr(),Kr(e),{value:n,source:"manual"})}function tc(e,t){if(Ma(),!e)return;const n=Vs(t);if(n===null){en.delete(e)&&(Zr(),Kr(e));return}en.set(e,{value:n,source:"solver"}),Zr(),Kr(e)}function Jy(e){if(!e)return;en.delete(e)&&Zr(),Kr(e)}function GC(e=[]){let t=!1;if(!e||!e.length)en.size&&(en.clear(),t=!0);else{const n=new Set(e);en.forEach((r,i)=>{n.has(i)||(en.delete(i),t=!0)})}t&&(Zr(),(e||[]).forEach(n=>Kr(n)))}function e0(e){return typeof e!="function"?()=>{}:(rp.add(e),()=>{rp.delete(e)})}function RC(){const e={auto:!!ci},t={};return en.forEach((n,r)=>{t[r]={...n}}),e.channels=t,e}function t0(){return Ma(),!!ci}function zC(e){Ma();const t=!!e;return ci===t||(ci=t,Zr(),NC()),ci}function UC(e){return typeof e!="function"?()=>{}:(ip.add(e),()=>{ip.delete(e)})}function n0(e=[]){Ma();const t={};return Array.isArray(e)&&e.forEach(n=>{const r=kr(n);!r||r.value===null||r.source==="unset"||r.source==="default"||r.source==="pending"||(t[n]={value:r.value,source:r.source})}),t}Xe("channelDensities",{DEFAULT_CHANNEL_DENSITIES:fs,getResolvedChannelDensity:kr,setManualChannelDensity:Zy,setSolverChannelDensity:tc,clearChannelDensity:Jy,resetAllChannelDensities:GC,subscribeChannelDensities:e0,exportChannelDensityState:RC,isAutoDensityComputeEnabled:t0,setAutoDensityComputeEnabled:zC,subscribeAutoDensityCompute:UC,getDensityOverridesSnapshot:n0},{exposeOnWindow:typeof window<"u",windowAliases:["getResolvedChannelDensity","setManualChannelDensity","setAutoDensityComputeEnabled"]});const r0="quadgen.lightBlockingOverlayEnabled.v1",$C=256;let hh=!1,ap=null,gr=null;function Fr(e){return!Number.isFinite(e)||e<=0?0:e>=1?1:e}function i0(){if(hh)return;hh=!0;let e=null;try{typeof window<"u"&&window.localStorage&&(e=window.localStorage.getItem(r0))}catch(t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[light-blocking] Failed to load overlay preference:",t)}e==="true"?nt({showLightBlockingOverlay:!0}):e==="false"&&nt({showLightBlockingOverlay:!1})}function VC(e){try{typeof window<"u"&&window.localStorage&&window.localStorage.setItem(r0,e?"true":"false")}catch(t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[light-blocking] Failed to persist overlay preference:",t)}}function a0(e,t){if(!Array.isArray(e)||e.length===0)return Array.from({length:t},()=>0);if(e.length===t)return e.map(Fr);const n=new Array(t),r=e.length-1;for(let i=0;i<t;i+=1){if(t===1){n[i]=Fr(e[0]??0);continue}const a=i/(t-1)*r,o=Math.floor(a),s=Math.min(r,o+1),l=a-o,c=Fr(e[o]??0),u=Fr(e[s]??c);n[i]=Fr(c+(u-c)*l)}return n}function HC(e,t){if(!Array.isArray(e)||e.length===0)return Array.from({length:t},()=>0);const n=e.map(r=>Fr(Number(r)/ve));return a0(n,t)}function qC({resolution:e}){if(!m.rows)return[];const t=Array.from(m.rows.querySelectorAll("tr.channel-row[data-channel]")),n=[],r=!!(D?.globalApplied&&D?.globalData);return t.forEach(i=>{const a=i.getAttribute("data-channel");if(!a||i.id==="noChannelsRow")return;const o=i.querySelector(".percent-input"),s=i.querySelector(".end-input"),l=q.clampPercent(o?.dataset?.pendingCommitValue??o?.getAttribute?.("data-base-percent")??o?.value),c=q.clampEnd(s?.dataset?.pendingCommitValue??s?.getAttribute?.("data-base-end")??s?.value),u=l>0||c>0,d=kr(a),p=Number.isFinite(d?.value)?Math.max(0,d.value):0;let f=[];if(typeof Yt=="function"&&u&&c>0)try{f=Yt(c,a,r,{normalizeToEnd:Hr(a)})||[]}catch(g){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[light-blocking] make256 failed for channel",a,g)}const h=HC(f,e);n.push({channelName:a,enabled:u&&p>0,weight:p,normalizedSamples:h,endValue:c})}),n}function jC(e,t){return!e||typeof e!="object"?[]:Object.entries(e).map(([n,r])=>{const i=!!r?.enabled,a=Number(r?.weight)||0,o=Array.isArray(r?.samples)?a0(r.samples.map(l=>Fr(Number(l))),t):Array.from({length:t},()=>0),s=Number(r?.end)||0;return{channelName:n,enabled:i&&a>0,weight:a,normalizedSamples:o,endValue:s,normalizeToEnd:!!r?.normalizeToEnd}})}function WC(e,t){if(!e.length)return`${t}|`;const n=e.map(r=>{const i=r.normalizedSamples||[],a=Fr(i[0]??0),o=Fr(i[Math.floor(i.length/2)]??0),s=Fr(i[i.length-1]??0),l=Number.isFinite(r.weight)?r.weight:0;return[r.channelName,r.enabled?1:0,Math.round(Number(r.endValue)||0),l.toFixed(4),a.toFixed(4),o.toFixed(4),s.toFixed(4)].join(":")}).join("|");return`${t}|${n}`}function Hs(){ap=null,gr=null}function o0(e=!0){i0();const t=!!e;return nt({showLightBlockingOverlay:t}),VC(t),Hs(),t}function s0(){return i0(),!!gt().showLightBlockingOverlay}function l0(e={}){const t=Number.isInteger(e.resolution)&&e.resolution>1?e.resolution:$C,n=e.skipCache===!0;let r=[];e.channels?r=jC(e.channels,t):r=qC({resolution:t});const i=WC(r,t);if(!n&&!e.channels&&ap===i&&gr){const p=e.normalize===!0;return{curve:(p?gr.normalizedCurve:gr.rawCurve).slice(),maxValue:p?gr.normalizedMaxValue:gr.rawMaxValue,contributingChannels:gr.contributingChannels.slice(),rawCurve:gr.rawCurve.slice(),rawMaxValue:gr.rawMaxValue,normalizedCurve:gr.normalizedCurve.slice(),normalizedMaxValue:gr.normalizedMaxValue}}const a=Array.from({length:t},()=>0),o=[];for(const p of r){if(!p.enabled||!Number.isFinite(p.weight)||p.weight<=0)continue;const f=Array.isArray(p.normalizedSamples)?p.normalizedSamples:Array.from({length:t},()=>0);let h=!1;for(let g=0;g<t;g+=1){const b=Fr(f[g]??0);b>0&&(h=!0);const S=b*100*p.weight;a[g]+=Number.isFinite(S)?S:0}h&&o.push(p.channelName)}let s=0;for(let p=0;p<a.length;p+=1){const f=Math.max(0,Math.min(100,a[p]));a[p]=f,f>s&&(s=f)}const l=s>0?a.map(p=>Math.max(0,Math.min(100,p/s*100))):a.slice(),c=s>0?100:s,u=e.normalize===!0,d={curve:(u?l:a).slice(),maxValue:u?c:s,contributingChannels:o.slice(),rawCurve:a.slice(),rawMaxValue:s,normalizedCurve:l.slice(),normalizedMaxValue:c};return!e.channels&&!n&&(ap=i,gr={rawCurve:a.slice(),rawMaxValue:s,normalizedCurve:l.slice(),normalizedMaxValue:c,contributingChannels:o.slice()}),d}Sf(()=>{Hs()});typeof window<"u"&&Xe("lightBlockingOverlay",{computeLightBlockingCurve:l0,clearLightBlockingCache:Hs,isLightBlockingOverlayEnabled:s0,setLightBlockingOverlayEnabled:o0},{exposeOnWindow:!0,windowAliases:["computeLightBlockingCurve","clearLightBlockingOverlayCache","isLightBlockingOverlayEnabled","setLightBlockingOverlayEnabled"]});const c0="quadgen.inkLoadOverlayEnabled.v1",u0="quadgen.inkLoadThreshold.v1",KC=25,YC=10,XC=400,QC=256;let gh=!1;function tm(e){const t=Number(e);return Number.isFinite(t)?Math.max(YC,Math.min(XC,Math.round(t))):KC}function qs(){if(!gh){gh=!0;try{if(typeof window>"u"||!window.localStorage)return;const e=window.localStorage.getItem(c0);e==="true"?nt({showInkLoadOverlay:!0}):e==="false"&&nt({showInkLoadOverlay:!1});const t=window.localStorage.getItem(u0);if(t!=null){const n=tm(t);nt({inkLoadThreshold:n})}}catch(e){console.warn("[ink-load] preference load failed:",e)}}}function ZC(e){try{typeof window<"u"&&window.localStorage&&window.localStorage.setItem(c0,e?"true":"false")}catch(t){console.warn("[ink-load] overlay preference persist failed:",t)}}function JC(e){try{typeof window<"u"&&window.localStorage&&window.localStorage.setItem(u0,String(e))}catch(t){console.warn("[ink-load] threshold persist failed:",t)}}function js(){qs();const e=gt(),t=tm(e.inkLoadThreshold);return t!==e.inkLoadThreshold&&nt({inkLoadThreshold:t}),t}function d0(e,{persist:t=!0}={}){qs();const n=tm(e);return nt({inkLoadThreshold:n}),t&&JC(n),n}function p0(e=!0){qs();const t=!!e;return nt({showInkLoadOverlay:t}),ZC(t),t}function f0(){return qs(),!!gt().showInkLoadOverlay}function eA({resolution:e}){if(!m.rows)return[];const t=Array.from(m.rows.querySelectorAll("tr.channel-row[data-channel]"));if(t.length===0)return[];const n=!!(D?.globalApplied&&D?.globalData),r=[];return t.forEach(i=>{const a=i.getAttribute("data-channel");if(!a)return;const o=i.querySelector(".percent-input"),s=i.querySelector(".end-input"),l=q.clampPercent(o?.dataset?.pendingCommitValue??o?.getAttribute?.("data-base-percent")??o?.value),c=q.clampEnd(s?.dataset?.pendingCommitValue??s?.getAttribute?.("data-base-end")??s?.value);if(!(!(l>0||c>0)||c<=0))try{const u=Hr(a),d=Yt(c,a,n,{normalizeToEnd:u})||[];if(!Array.isArray(d)||d.length===0)return;r.push({channelName:a,endValue:c,samples:d.slice(0,e)})}catch(u){console.warn("[ink-load] make256 failed for",a,u)}}),r}function m0(e={}){const t=Number.isInteger(e.resolution)&&e.resolution>1?e.resolution:QC;qs();let n=[];if(Array.isArray(e.channels)&&e.channels.length>0?n=e.channels.map(a=>({channelName:a?.channelName??a?.name??"",endValue:Number(a?.endValue)||0,samples:Array.isArray(a?.samples)?a.samples.slice(0,t):[]})).filter(a=>a.channelName&&a.endValue>0&&a.samples.length>0):n=eA({resolution:t}),n.length===0)return null;const r=new Array(t).fill(0);let i=0;for(let a=0;a<t;a+=1){let o=0;for(const s of n){const l=s.samples[a]??0,c=Number(l)/ve*100;Number.isFinite(c)&&(o+=c)}r[a]=o,o>i&&(i=o)}return{curve:r,maxValue:i,threshold:js(),enabledChannels:n.map(a=>a.channelName)}}Xe("inkLoad",{compute:m0,setEnabled:p0,getEnabled:f0,getThreshold:js,setThreshold:d0});const re=typeof window<"u"?window:globalThis,tt=typeof document<"u";function bh(e){if(!Number.isFinite(e))return"0";const t=Math.round(e);return Math.abs(e-t)<.05?String(t):Number(e.toFixed(1)).toString()}const op=12,sp="quadgen.showLabSpotMarkers";let nc=!1;try{typeof localStorage<"u"&&(nc=localStorage.getItem(sp)==="1")}catch{nc=!1}const zl=gt();nc&&(zl.showLabSpotMarkers=!0);const yh="#ef4444",Sh="#4b5563",tA="#a855f7",nA="#10b981",h0="#047857",lp="#ef4444",cp="#0ea5e9",vh="rgba(255, 255, 255, 0.92)",rA="#111827",iA="#7c3aed",aA="#6d28d9",oA="#c084fc",g0="ðŸš©",up="#94A3B8",rc="#EF4444",sA="#1f2937",te={showCorrectionTarget:!!zl.showCorrectionOverlay,lastCorrectionOverlay:null,showLabSpotMarkers:!!zl.showLabSpotMarkers,lastLabSpotMarkers:null,showLightBlockingOverlay:!1,lastLightBlockingCurve:null,showInkLoadOverlay:!!zl.showInkLoadOverlay,lastInkLoadOverlay:null,lastOriginalOverlays:{},flaggedSnapshots:[],lastSelectionProbe:null,restoreLabSpotMarkerPreference:nc},lA=150;let ra=null,Ul=null;function b0(e){if(D&&typeof D.refreshMeasurementCorrectionsForGain=="function")try{D.refreshMeasurementCorrectionsForGain(e)}catch(t){console.warn("Failed to refresh measurement corrections after correction gain change:",t)}try{Be()}catch(t){console.warn("Failed to refresh chart after correction gain change:",t)}try{Pn()}catch(t){console.warn("Failed to refresh preview after correction gain change:",t)}try{yt()}catch(t){console.warn("Failed to refresh session status after correction gain change:",t)}Ul!==null&&(Z(`Correction gain set to ${Ul}%`),Ul=null)}function cA(e){ra!==null&&clearTimeout(ra),ra=setTimeout(()=>{ra=null,b0(e)},lA)}function uA(e){ra!==null&&(clearTimeout(ra),ra=null),b0(e)}function dA(e){const n=te.lastLightBlockingCurve?.curve;if(!Array.isArray(n)||n.length<2)return null;const i=Math.max(0,Math.min(100,e))/100,a=n.length-1,o=i*a,s=Math.floor(o),l=Math.min(a,s+1),c=o-s,u=Number(n[s])||0,d=Number(n[l])||u;return u+(d-u)*c}function pA(e){const t=te.lastLightBlockingCurve;if(!t)return null;const n=t.rawCurve;if(!Array.isArray(n)||n.length<2)return null;const i=Math.max(0,Math.min(100,e))/100,a=n.length-1,o=i*a,s=Math.floor(o),l=Math.min(a,s+1),c=o-s,u=Number(n[s])||0,d=Number(n[l])||u;return u+(d-u)*c}function fA(e){const n=te.lastInkLoadOverlay?.curve;if(!Array.isArray(n)||n.length<2)return null;const i=Math.max(0,Math.min(100,e))/100,a=n.length-1,o=i*a,s=Math.floor(o),l=Math.min(a,s+1),c=o-s,u=Number(n[s])||0,d=Number(n[l])||u;return u+(d-u)*c}function y0(e=!0){te.showCorrectionTarget=!!e,nt({showCorrectionOverlay:te.showCorrectionTarget});const t=m.correctionOverlayToggle;if(t&&(t.checked=te.showCorrectionTarget,t.setAttribute("aria-checked",String(te.showCorrectionTarget))),te.showCorrectionTarget||(te.lastCorrectionOverlay=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastCorrectionOverlay=null)),typeof Be=="function")try{Be()}catch(n){console.warn("[CHART DEBUG] Failed to refresh chart after toggling correction target debug:",n)}return te.showCorrectionTarget}function S0(){return!!te.showCorrectionTarget}function nm(e=!0){const t=o0(e);te.showLightBlockingOverlay=!!t;const n=m.lightBlockingOverlayToggle;if(n&&(n.checked=te.showLightBlockingOverlay,n.setAttribute("aria-checked",String(te.showLightBlockingOverlay))),te.showLightBlockingOverlay||(te.lastLightBlockingCurve=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastLightBlockingCurve=null)),Hs(),typeof Be=="function")try{Be()}catch(r){console.warn("[LightBlocking] Failed to refresh chart after toggle:",r)}return te.showLightBlockingOverlay}function v0(){return te.showLightBlockingOverlay||(te.showLightBlockingOverlay=!!s0()),!!te.showLightBlockingOverlay}function mA(e=!0){const t=p0(e);te.showInkLoadOverlay=!!t;const n=m.inkLoadOverlayToggle;if(n&&(n.checked=te.showInkLoadOverlay,n.setAttribute("aria-checked",String(te.showInkLoadOverlay))),te.showInkLoadOverlay||(te.lastInkLoadOverlay=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastInkLoadOverlay=null)),typeof Be=="function")try{Be()}catch(r){console.warn("[InkLoad] Failed to refresh chart after toggle:",r)}return te.showInkLoadOverlay}function hA(){return te.showInkLoadOverlay||(te.showInkLoadOverlay=!!f0()),!!te.showInkLoadOverlay}function E0(){try{if(typeof D?.getLabMeasurementCorrections=="function"){const t=D.getLabMeasurementCorrections({skipEndpoints:!1,clone:!1});return Array.isArray(t)&&t.length>0}const e=D?.globalMeasurementCorrections;return Array.isArray(e)&&e.length>0}catch(e){return console.warn("[Chart Debug] Failed to inspect LAB measurement corrections:",e),!1}}function rm(){const e=m.labSpotMarkersToggle;if(!e)return;const t=E0();if(e.disabled=!t,e.setAttribute("aria-disabled",String(!t)),t&&te.restoreLabSpotMarkerPreference){te.restoreLabSpotMarkerPreference=!1,im(!0);return}t||(e.checked=!1,e.setAttribute("aria-checked","false"),te.showLabSpotMarkers&&(te.showLabSpotMarkers=!1,nt({showLabSpotMarkers:!1}),te.lastLabSpotMarkers=null))}function im(e=!0){const t=!!e;if(t&&!E0()){Z("Load LAB measurement data to enable measurement spot markers.");const r=m.labSpotMarkersToggle;return r&&(r.checked=!1,r.setAttribute("aria-checked","false")),te.showLabSpotMarkers=!1,nt({showLabSpotMarkers:!1}),!1}te.showLabSpotMarkers=t,nt({showLabSpotMarkers:t});try{typeof localStorage<"u"&&(t?localStorage.setItem(sp,"1"):localStorage.removeItem(sp))}catch(r){console.warn("[Chart Debug] Failed to persist spot marker preference:",r)}const n=m.labSpotMarkersToggle;if(n&&(n.checked=t,n.setAttribute("aria-checked",String(t))),t||(te.lastLabSpotMarkers=null),typeof Be=="function")try{Be()}catch(r){console.warn("[Chart Debug] Failed to refresh chart after toggling spot markers:",r)}return te.showLabSpotMarkers}function am(){return!!te.showLabSpotMarkers}function w0(e,t={}){const{announce:n=!1,forceImmediate:r=!1}=t||{},i=On(),a=Number(e),o=Number.isFinite(a)?Math.max(0,Math.min(1,a)):i,s=ZE(o);if(Math.abs(s-i)<=5e-4)return s;const l=Math.round(s*100);return m.correctionGainSlider&&(m.correctionGainSlider.value=String(l),m.correctionGainSlider.setAttribute("aria-valuenow",String(l)),m.correctionGainSlider.setAttribute("aria-valuetext",`${l}%`)),m.correctionGainInput&&(m.correctionGainInput.value=String(l)),m.correctionGainValue&&(m.correctionGainValue.textContent=`${l}%`),Ul=n?l:null,r?uA(s):cA(s),s}function om(e,t={}){const n=Number(e),r=Number.isFinite(n)?Math.max(0,Math.min(100,Math.round(n))):Math.round(On()*100);return w0(r/100,t)}if(tt){const e=Xe("chartDebug",{setShowCorrectionTarget:y0,isShowCorrectionTargetEnabled:S0,getLastCorrectionOverlay:()=>te.lastCorrectionOverlay,setLabSpotMarkerOverlayEnabled:im,isLabSpotMarkerOverlayEnabled:am,getLabSpotMarkers:()=>Array.isArray(te.lastLabSpotMarkers)?te.lastLabSpotMarkers.map(t=>({...t})):null,syncLabSpotMarkerToggleAvailability:rm,getLastOriginalOverlays:()=>({...te.lastOriginalOverlays}),getFlaggedSnapshots:()=>te.flaggedSnapshots.slice(),setLightBlockingOverlayEnabled:nm,isLightBlockingOverlayEnabled:v0,getLastLightBlockingCurve:()=>te.lastLightBlockingCurve,getLastSelectionProbe:()=>te.lastSelectionProbe,setCorrectionGainPercent:(t,n={})=>om(t,n),getCorrectionGainPercent:()=>Math.round(On()*100),getCurveSamplesForChannel:(t,n)=>Zo(t,n),simulateSmartPointSelection:(t,n,r={})=>Ss(t,n,{description:r?.description||`Debug select ${t} point ${n}`,silent:r?.silent!==void 0?r.silent:!0,skipHistory:!0})},{exposeOnWindow:!0,windowAliases:["setChartDebugShowCorrectionTarget","isChartDebugShowCorrectionTarget","getChartDebugFlaggedSnapshots","setLabSpotMarkerOverlayEnabled","isLabSpotMarkerOverlayEnabled","syncLabSpotMarkerToggleAvailability","setLightBlockingOverlayEnabled","isLightBlockingOverlayEnabled","setCorrectionGainPercent","getCorrectionGainPercent","getCurveSamplesForChannel"]});e&&(Object.defineProperty(e,"lastCorrectionOverlay",{configurable:!0,enumerable:!0,get(){return te.lastCorrectionOverlay},set(t){te.lastCorrectionOverlay=t}}),Object.defineProperty(e,"lastOriginalOverlays",{configurable:!0,enumerable:!0,get(){return te.lastOriginalOverlays},set(t){t&&typeof t=="object"?te.lastOriginalOverlays={...t}:te.lastOriginalOverlays={}}}),Object.defineProperty(e,"lastLightBlockingCurve",{configurable:!0,enumerable:!0,get(){return te.lastLightBlockingCurve},set(t){te.lastLightBlockingCurve=t}}))}let Qo={index:null,percent:null},Eh=null,ma=[],wh="";function gA(e){return!e||typeof e!="object"?null:{index:e.index,percent:e.percent,kind:e.flag?.kind||null,magnitude:e.flag?.magnitude??null,channels:Array.isArray(e.flag?.channels)?e.flag.channels.slice():[]}}function bA(e){const t=e?.flags&&typeof e.flags=="object"?e.flags:{},n=Array.isArray(e?.snapshots)?e.snapshots:[],r=[];Object.entries(t).forEach(([o,s])=>{const l=Number.parseInt(o,10);if(!Number.isInteger(l)||!s||typeof s!="object")return;const c=n[l]&&n[l]?.index===l?n[l]:n.find(p=>p&&p.index===l)||null,u=Number.isFinite(s.inputPercent)?s.inputPercent:c&&Number.isFinite(c.inputPercent)?c.inputPercent:null;if(!Number.isFinite(u))return;const d={kind:s.kind==="drop"?"drop":"rise",magnitude:Number.isFinite(s.magnitude)?s.magnitude:null,channels:Array.isArray(s.channels)?s.channels.slice():[],details:Array.isArray(s.details)?s.details.map(p=>({...p})):[]};r.push({index:l,percent:u,flag:d})}),r.sort((o,s)=>o.index-s.index);const i=JSON.stringify(r.map(o=>({i:o.index,p:Math.round(o.percent*1e3)/1e3,k:o.flag.kind,m:o.flag.magnitude!=null?Math.round(o.flag.magnitude*1e3)/1e3:null,c:o.flag.channels}))),a=i!==wh;return a&&(ma=r,wh=i,te.flaggedSnapshots=r.map(gA).filter(Boolean),tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.flaggedSnapshots=te.flaggedSnapshots)),!r.length&&te.flaggedSnapshots.length&&(te.flaggedSnapshots=[],tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.flaggedSnapshots=[])),a}function Ch(e){const t=Number.isFinite(e?.selection?.percent)?e.selection.percent:null,n=Number.isInteger(e?.selection?.index)?e.selection.index:null,r=Qo.percent!==t||Qo.index!==n;Qo={index:n,percent:t};const i=bA(e);return r||i}function yA(){tt&&(Eh||(Ch(xo()),Eh=em(e=>{if(Ch(e))try{Be()}catch(t){console.warn("[CHART] composite debug refresh failed:",t)}})))}function SA(){return Number.isFinite(Qo.percent)?Qo.percent:null}function vA(e,t,n){if(!Array.isArray(ma)||!ma.length)return;e.save();const r=Math.max(12,Math.round(14*Math.max(1,n)));e.font=`${r}px "Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji","Twemoji Mozilla",sans-serif`,e.textAlign="center",e.textBaseline="bottom",e.fillStyle="#ef4444";const i=Math.max(Number(t?.padding)||0,0)+r+4;ma.forEach(a=>{const o=Math.max(0,Math.min(100,Number(a?.percent)||0)),s=nr(o,t);e.fillText(g0,s,i)}),e.restore()}function EA(e,t,n){const r=[];if(Number.isInteger(n)&&r.push(`Snapshot #${n}`),Number.isFinite(t)&&r.push(`Input ${t.toFixed(1)}%`),e&&Array.isArray(e.channels)&&e.channels.length)if(Array.isArray(e.details)&&e.details.length){const i=e.details.map(a=>{if(!a||typeof a.channel!="string"||!a.channel)return null;if(Number.isFinite(a.delta)){const o=Math.abs(a.delta).toFixed(1),s=a.delta>=0?"+":"âˆ’";return`${a.channel}: ${s}${o}%`}if(Number.isFinite(a.magnitude)){const o=Math.abs(a.magnitude).toFixed(1),s=a.direction==="drop"?"âˆ’":"+";return`${a.channel}: ${s}${o}%`}return a.channel}).filter(Boolean);i.length?r.push(`Channels: ${i.join(", ")}`):r.push(`Channels: ${e.channels.join(", ")}`)}else r.push(`Channels: ${e.channels.join(", ")}`);return e&&Number.isFinite(e.threshold)&&r.push(`Threshold â‰¥ ${e.threshold.toFixed(1)}%`),r.join(`
`)}function wA(e,t=1){const n=m.snapshotFlagOverlay,r=m.inkChart;if(!n||!r)return;if(n.innerHTML="",!Array.isArray(ma)||!ma.length){n.classList.add("hidden");return}n.classList.remove("hidden");const i=r.width||1,a=r.height||1,o=Math.max(Number(e?.padding)||0,0)+Math.max(12,14*Math.max(1,t))+4;ma.forEach(s=>{const l=document.createElement("span");l.textContent=g0,l.className="absolute pointer-events-auto select-none text-base font-semibold drop-shadow-sm",l.style.color="#ef4444",l.style.cursor="help",l.dataset.flaggedSnapshot=String(s.index),l.dataset.flagKind=s.flag?.kind||"rise";const c=Math.max(0,Math.min(100,Number(s?.percent)||0)),u=nr(c,e),d=o;l.style.left=`${u/i*100}%`,l.style.top=`${d/a*100}%`,l.style.transform="translate(-50%, -60%)";const p=EA(s.flag,c,s.index);p?(l.title=p,l.setAttribute("aria-label",p.replace(/\n/g,", "))):l.setAttribute("aria-hidden","true"),n.appendChild(l)})}const Oe={geom:null,pointerId:null,active:!1,channel:null,ordinal:0,moved:!1,suppressClick:!1,hoverOrdinal:null};let br=null;function Ah(){Oe.pointerId=null,Oe.active=!1,Oe.channel=null,Oe.ordinal=0,Oe.moved=!1,Oe.hoverOrdinal=null,br=null}function Mh(){return!tt||!Fc()||typeof re.isEditModeEnabled=="function"&&!re.isEditModeEnabled()?!1:!!(re.EDIT&&re.EDIT.selectedChannel)}function Lh(){return re.EDIT?.selectedChannel||null}function fl(e){return!m.rows||!e?null:Array.from(m.rows.children).filter(n=>n.id!=="noChannelsRow").find(n=>n.getAttribute("data-channel")===e)||null}function CA(e){if(!e)return 100;const t=e.querySelector(".percent-input");if(!t)return 100;const n=t.value??t.getAttribute("data-base-percent"),r=q.clampPercent(n);return Number.isFinite(r)&&r>0?r:100}function Zo(e,t){if(!t)return null;const n=t.querySelector(".end-input"),r=q.clampEnd(n?.value||n?.getAttribute("data-base-end")||0);if(!Number.isFinite(r)||r<=0)return null;const i=D.globalApplied&&D.globalData,a=Hr(e);try{return{values:Yt(r,e,i,{normalizeToEnd:a}),endValue:r}}catch(o){return console.warn("[CHART] Failed to sample curve during drag prep:",o),null}}function C0(e,t){const n=t.getBoundingClientRect(),r=t.width/n.width,i=t.height/n.height;return{canvasX:(e.clientX-n.left)*r,canvasY:(e.clientY-n.top)*i,scaleX:r,scaleY:i}}function Tn(e,t){e&&e.style.cursor!==t&&(e.style.cursor=t||"")}let ml=null,Ih=!1;function dp(){if(!tt)return;if(ml){try{ml()}catch(n){console.warn("Failed to unsubscribe chart scaling listener",n)}ml=null}if(!!!re.__USE_SCALING_STATE)return;let t;try{t=at()}catch(n){console.warn("Unable to obtain state manager for chart scaling subscription",n);return}if(!(!t||typeof t.subscribe!="function")){ml=t.subscribe(["scaling.globalPercent"],()=>{try{Be()}catch(n){console.warn("Failed to refresh chart after scaling state change",n)}});try{Be()}catch(n){console.warn("Initial chart refresh after scaling state subscription failed",n)}}}const kh=4/3,Zu=320,AA=48;let Ju=!1,ed=null;tt&&!Ih&&(re.addEventListener(Jl,()=>{dp()}),Ih=!0,re.__USE_SCALING_STATE&&(typeof queueMicrotask=="function"?queueMicrotask:t=>Promise.resolve().then(t))(()=>dp()));function A0(){return m.inkChart?m.inkChart.closest("[data-chart-wrapper]"):null}function M0(){return typeof document>"u"?null:document.querySelector("[data-linearization-column]")}function MA(){return typeof document>"u"?null:document.querySelector("[data-chart-region]")}function si(){const e=A0();if(!e)return;const t=MA();if(!t)return;const n=e.clientWidth;if(!n)return;const r=e.getBoundingClientRect(),i=tt?re.innerHeight:0,a=Number.isFinite(i)&&i>0?Math.max(Zu,i-r.top-AA):n/kh,o=n/kh;let s=1/0;const l=M0();if(l){const u=l.getBoundingClientRect(),d=l.offsetHeight,p=tt?re.getComputedStyle(l):null,f=b=>{const S=Number.parseFloat(b);return Number.isFinite(S)?S:0},h=p?f(p.marginTop)+f(p.marginBottom):0,g=Number.isFinite(d)&&d>0?d+h:u&&Number.isFinite(u.height)?u.height+h:0;g>=0&&(s=Math.max(Zu,g))}const c=Math.max(Zu,Math.min(o,a,s));t.style.setProperty("--chart-max-height",`${Math.round(c)}px`)}const Dn=[10,20,30,40,50,60,70,80,90,100];let lr=null;const Ka={width:0,height:0,dpr:0};let td=null,nd=null,rd=null;const L0="quadgen_chart_zoom_v1";function LA(){try{localStorage.removeItem(L0)}catch(e){console.warn("Could not clear chart zoom storage:",e)}I0(100,{persist:!1,refresh:!1})}function Bo(){const e=gt();return Dn[e.chartZoomIndex]||100}function Ws(){return gt().chartZoomIndex||0}function IA(){try{localStorage.removeItem(L0)}catch(e){console.warn("Could not clear chart zoom storage:",e)}}function sm(){const e=gt(),t=!!e.loadedQuadData,n=!!e.linearizationData||e.linearizationApplied===!0;if(!t&&!n)return 0;let r=0;try{(m.rows?.children?Array.from(m.rows.children):[]).forEach(a=>{if(!a||a.id==="noChannelsRow")return;const s=a.querySelector(".end-input")?.value??0,l=q.clampEnd(s);if(l<=0)return;const c=q.computePercentFromEnd(l);Number.isFinite(c)&&(r=Math.max(r,c))})}catch(i){console.warn("Error calculating highest active percent:",i)}return Math.max(0,Math.min(100,r))}function Jc(){const e=sm();if(!Number.isFinite(e)||e<=0)return 0;const t=Math.min(100,Math.max(0,Math.ceil(e/10)*10));let n=Dn.findIndex(r=>r>=t);return n===-1&&(n=Dn.length-1),t>=100&&n>=Dn.length-1&&(n=Math.max(0,n-1)),n}function eu(e,t={}){const{persist:n=!0,refresh:r=!0}=t,i=Jc(),a=Math.max(i,Math.min(Dn.length-1,e)),o=Ws(),s=a!==o;if(nt({chartZoomIndex:a}),n&&IA(),k0(),s&&typeof yt<"u")try{yt()}catch(l){console.warn("Error updating session status after zoom change:",l)}if(r&&s)try{Be()}catch(l){console.warn("Error refreshing chart after zoom change:",l)}return Bo()}function I0(e,t={}){const n=Number(e);if(!Number.isFinite(n))return Bo();let r=Dn[0],i=Math.abs(n-r);for(const a of Dn){const o=Math.abs(n-a);o<i&&(r=a,i=o)}return eu(Dn.indexOf(r),t)}function pp(e,t={}){const n=Ws(),r=Jc(),i=n+(e>=0?-1:1);if(e>=0&&i<r){const a=Dn[r]??Dn[Dn.length-1],o=sm(),s=Number.isFinite(o)?Math.round(o*10)/10:null;if(typeof ho=="function"){const l=s!=null?`Zoom stops at ${a}% â€” active channel peaks at ${s}%`:`Zoom stops at ${a}%`;ho(l,2600)}}return eu(i,t)}function k0(){const e=Ws(),t=Bo(),n=Jc(),r=sm(),i=Number.isFinite(r)?Math.round(r):null,a=Number.isFinite(r)?Math.round(r*10)/10:null;if(m.chartZoomInBtn){const o=e<=n;if(m.chartZoomInBtn.disabled=o,m.chartZoomInBtn.setAttribute("aria-disabled",o?"true":"false"),o){const s=Dn[Math.min(Dn.length-1,n+1)],l=i!=null&&s!=null&&i>=s,c=a??i;m.chartZoomInBtn.title=l?`Zoom limited to ${Dn[n]}% â€” active channel peaks at ${c??100}%`:"Already at maximum zoom"}else m.chartZoomInBtn.title=`Zoom in from ${t}%`}if(m.chartZoomOutBtn){const o=e>=Dn.length-1;m.chartZoomOutBtn.disabled=o,m.chartZoomOutBtn.setAttribute("aria-disabled",o?"true":"false"),m.chartZoomOutBtn.title=o?"Cannot zoom out further":`Zoom out from ${t}%`}}let id=null;function ho(e,t=2e3){console.log("ðŸ“Š setChartStatusMessage:",e);let n=m.status;if(!n)if(console.warn("âš ï¸ Status element not found in elements object, trying direct DOM lookup..."),n=document.getElementById("status"),n)console.log("âœ… Found status element via direct DOM lookup"),m.status=n;else{console.error("âŒ Status element not found in DOM!");return}n.textContent=e,n.style.opacity="1";const r=n.closest("[data-status-container]");r&&(r.style.display="block"),console.log("âœ… Status message displayed:",e),id&&clearTimeout(id),id=setTimeout(()=>{console.log("ðŸ“Š Clearing status message"),n&&(n.style.opacity="0",setTimeout(()=>{n&&(n.textContent="Â ");const i=n?.closest("[data-status-container]");i&&(i.style.display="none")},500))},t)}const sn={canvas:null,ctx:null,geom:null,colors:null};function kA(e,t){return e===t?!0:!e||!t?!1:e.width===t.width&&e.height===t.height&&e.padding===t.padding&&e.bottomPadding===t.bottomPadding&&e.leftPadding===t.leftPadding&&e.rightPadding===t.rightPadding&&e.displayMax===t.displayMax&&e.dpr===t.dpr}function DA(e,t){return e===t?!0:!e||!t?!1:e.grid===t.grid&&e.axis===t.axis&&e.text===t.text&&e.bg===t.bg&&e.border===t.border}function Be(){if(!m.inkChart||!m.rows)return;const e=m.inkChart;rm(),si();const t=re.devicePixelRatio||1,n=e.getBoundingClientRect(),r=n.width,i=Math.min(Math.max(t,1),3),a=300,o=Math.max(0,Math.min(1,(r-a)/a)),s=1+(i-1)*o;if(!n.width||!n.height)return;const l=Math.round(n.width*t),c=Math.round(n.height*t);if((e.width!==l||e.height!==c)&&(e.width=l,e.height=c,sn.geom=null),m.inkChartOverlay){const v=m.inkChartOverlay;(v.width!==l||v.height!==c)&&(v.width=l,v.height=c,v.style.width=e.style.width||`${n.width}px`,v.style.height=e.style.height||`${n.height}px`)}Ka.width=l,Ka.height=c,Ka.dpr=t;const u=e.getContext("2d",{alpha:!1}),d=wE(),p=Jc();Ws()<p&&eu(p,{persist:!1,refresh:!1});const h=Bo(),g=Bb(e,h,i);YA(g);let b=!1;if(sn.canvas&&sn.ctx&&kA(sn.geom,g)&&DA(sn.colors,d)&&(b=!0),!b){sn.canvas||(sn.canvas=document.createElement("canvas")),(sn.canvas.width!==e.width||sn.canvas.height!==e.height)&&(sn.canvas.width=e.width,sn.canvas.height=e.height),sn.ctx||(sn.ctx=sn.canvas.getContext("2d",{alpha:!1}));const v=sn.ctx;v.fillStyle="#ffffff",v.fillRect(0,0,e.width,e.height),d.bg&&d.bg!=="transparent"&&(v.save(),v.fillStyle=d.bg,v.fillRect(g.leftPadding,g.padding,g.chartWidth,g.chartHeight),v.restore()),CE(v,g,d),mC(v,g,d);const A=hC(v,g,d),w=gC(v,g,d),M=SC(g.displayMax);bC(v,g,d,M,A,w),yC(v,g),sn.geom=g,sn.colors=d}u.drawImage(sn.canvas,0,0);const S=Array.from(m.rows.children).reduce((v,A)=>{if(A.id==="noChannelsRow")return v;const w=A.querySelector(".end-input");if(!w)return v;const M=q.clampEnd(w.value);return v+(M>0?1:0)},0),E=gt();if(m.aiLabelToggle&&(S>1?m.aiLabelToggle.checked&&!E.overlayAutoToggledOff&&(m.aiLabelToggle.checked=!1,nt({overlayAutoToggledOff:!0})):nt({overlayAutoToggledOff:!1})),te.showCorrectionTarget&&OA(u,g),FA(u,g,d,s),te.showLightBlockingOverlay)try{const v=l0({resolution:256,normalize:!0,skipCache:!0});v&&Array.isArray(v.curve)&&v.curve.length>1&&(UA(u,g,v),te.lastLightBlockingCurve={curve:v.curve.slice(),maxValue:v.maxValue,contributingChannels:v.contributingChannels.slice(),rawCurve:Array.isArray(v.rawCurve)?v.rawCurve.slice():null,rawMaxValue:Number.isFinite(v.rawMaxValue)?v.rawMaxValue:null,normalizedCurve:Array.isArray(v.normalizedCurve)?v.normalizedCurve.slice():null,normalizedMaxValue:Number.isFinite(v.normalizedMaxValue)?v.normalizedMaxValue:null},tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastLightBlockingCurve=te.lastLightBlockingCurve))}catch(v){console.warn("[LightBlocking] Failed to compute overlay curve:",v)}else te.lastLightBlockingCurve&&(te.lastLightBlockingCurve=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastLightBlockingCurve=null));if(te.showInkLoadOverlay)try{const v=m0({resolution:256});v&&Array.isArray(v.curve)&&v.curve.length>1?($A(u,g,v),te.lastInkLoadOverlay={curve:v.curve.slice(),maxValue:v.maxValue,threshold:v.threshold,enabledChannels:Array.isArray(v.enabledChannels)?v.enabledChannels.slice():[]},tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastInkLoadOverlay=te.lastInkLoadOverlay)):te.lastInkLoadOverlay&&(te.lastInkLoadOverlay=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastInkLoadOverlay=null))}catch(v){console.warn("[InkLoad] Failed to compute overlay curve:",v)}else te.lastInkLoadOverlay&&(te.lastInkLoadOverlay=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastInkLoadOverlay=null));te.showLabSpotMarkers?_A(u,g,d):te.lastLabSpotMarkers&&(te.lastLabSpotMarkers=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastLabSpotMarkers=null)),vA(u,g,s),wA(g,i);const y=SA();if(y!=null){const v=Math.max(0,Math.min(100,y)),A=nr(v,g),w=g.padding,M=g.height-(g.bottomPadding||g.padding);u.save(),u.strokeStyle="#16a34a",u.lineWidth=2,u.setLineDash([4,4]),u.beginPath(),u.moveTo(A,w),u.lineTo(A,M),u.stroke(),u.restore()}KA(g),k0(),Us()}Uw(Be);function Dh(){if(console.log("ðŸ“Š Initializing chart system..."),dp(),yA(),m.inkChart){const e=A0();e&&(e.dataset.chartResponsive="true",e.style.removeProperty("--chart-fixed-height"),si(),PA(),tt&&(re.addEventListener("resize",si,{passive:!0}),document.fonts&&typeof document.fonts.ready=="object"&&document.fonts.ready.then(()=>{si(),Be(),ad()}).catch(()=>{}),re.addEventListener("load",()=>{si(),Be(),ad()},{once:!0})))}if(LA(),m.inkChart){if(xA(),!m.inkChartOverlay){const e=document.createElement("canvas");e.id="inkChartOverlay",e.style.cssText="position:absolute;top:0;left:0;pointer-events:none;z-index:10;";const t=m.inkChart.parentElement;t&&(re.getComputedStyle(t).position==="static"&&(t.style.position="relative"),t.appendChild(e),m.inkChartOverlay=e)}Be(),!Ju&&tt&&typeof re.requestAnimationFrame=="function"&&(Ju=!0,re.requestAnimationFrame(()=>{Ju=!1,si(),Be(),ad()}))}console.log("âœ… Chart system initialized")}function ad(){!tt||typeof re.requestAnimationFrame!="function"||re.requestAnimationFrame(()=>{si(),Be()})}function PA(){if(!tt)return;const e=M0();!e||!("ResizeObserver"in re)||(ed||(ed=new ResizeObserver(()=>{si(),Be()})),ed.observe(e))}function xA(){const e=m.inkChart;if(!e||!tt)return;const t=()=>{if(!m.inkChart)return;si();const n=re.devicePixelRatio||1,r=m.inkChart.getBoundingClientRect();if(!r.width||!r.height)return;const i=Math.round(r.width*n),a=Math.round(r.height*n);i===Ka.width&&a===Ka.height&&n===Ka.dpr||rd||(rd=re.requestAnimationFrame(()=>{rd=null,Be()}))};"ResizeObserver"in window&&!td?(td=new ResizeObserver(t),td.observe(e)):nd||(nd=()=>t(),re.addEventListener("resize",nd,{passive:!0}))}function BA(e,t){if(!Array.isArray(e)||e.length===0)return[];const n=Number(t),r=Number.isFinite(n)?Math.max(0,Math.min(1,n)):1,i=e.length-1;if(r>=.999)return e.slice();const a=new Array(e.length);for(let o=0;o<e.length;o+=1){const s=i>0?o/i:0,l=Number(e[o]),c=Number.isFinite(l)?Math.max(0,Math.min(1,l)):s;if(r<=.001)a[o]=s;else{const u=s+(c-s)*r;a[o]=Math.max(0,Math.min(1,u))}}return a}function TA(e,t,n,r,i){try{const a=D.hasAnyLinearization()||D.getPerChannelData(r),o=Ni(r),s=!!Ee()?.curves;if(!(a||o||s))return;const c=ni[r]||"#000000",u=[],d=256;for(let h=0;h<d;h++){const g=h/(d-1);let b;typeof re.getTargetRelAt=="function"?b=Math.max(0,Math.min(1,re.getTargetRelAt(g))):b=Math.max(0,Math.min(1,g)),u.push(Math.round(b*i))}e.save(),e.strokeStyle=c;const p=typeof re.isEditModeEnabled=="function"&&re.isEditModeEnabled(),f=p&&re.EDIT&&re.EDIT.selectedChannel===r;e.globalAlpha=p&&!f?.125:.25,e.lineWidth=1,e.setLineDash([2,2]),e.beginPath();for(let h=0;h<u.length;h++){const g=t.leftPadding+h/(u.length-1)*t.chartWidth,b=u[h]/ve*100,S=Math.max(0,Math.min(t.displayMax,b)),E=Qt(S,t);h===0?e.moveTo(g,E):e.lineTo(g,E)}e.stroke(),e.setLineDash([]),e.restore()}catch(a){console.warn(`Error drawing reference curve for ${r}:`,a)}}function D0(e,t=100){if(!e||typeof e!="object")return t;let n=0,r=!1;if(e.baselineEnd&&typeof e.baselineEnd=="object"&&Object.values(e.baselineEnd).forEach(a=>{const o=Math.max(0,Number(a)||0);o>0&&(n+=o,r=!0)}),!r&&e.curves&&typeof e.curves=="object"&&Object.values(e.curves).forEach(a=>{if(Array.isArray(a)&&a.length){const o=Math.max(0,Number(a[a.length-1])||0);n+=o,r=r||o>0}}),!r||n<=0)return t;const i=n/ve*100;return!Number.isFinite(i)||i<=0?t:Math.max(.01,i)}function OA(e,t){try{const n=typeof D.getGlobalData=="function"?D.getGlobalData():D.globalData;if(!n){te.lastCorrectionOverlay=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastCorrectionOverlay=null);return}const i=Rn(n)?.samples;if(!Array.isArray(i)||i.length<2){te.lastCorrectionOverlay=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastCorrectionOverlay=null);return}const a=typeof Ee=="function"?Ee():null;let o=D0(a,t.displayMax||100);!Number.isFinite(o)||o<=0?o=Math.min(t.displayMax||100,100):t.displayMax&&o>t.displayMax&&(o=t.displayMax);const s=On(),l=BA(i,s),c={color:yh,samples:[],baseline:null,effectiveMaxPercent:o,gain:s};let u=null;const d=typeof D?.getGlobalBaselineCurves=="function"?D.getGlobalBaselineCurves():null,p=m?.channelTable?Array.from(m.channelTable.querySelectorAll("[data-channel]")):[];let f=null,h=ve;for(const b of p){const S=b.getAttribute("data-channel"),E=b.querySelector(".percent-input");if((E?q.clampPercent(E.value):0)>0&&d?.[S]){f=d[S],h=Math.max(...f.filter(v=>Number.isFinite(v)));break}}if(f&&f.length===256&&h>0){u=new Array(256);for(let b=0;b<256;b++){const S=b/255*h;let E=0,y=1/0;for(let v=0;v<256;v++){const A=f[v];if(!Number.isFinite(A))continue;const w=Math.abs(A-S);w<y&&(y=w,E=v)}u[b]=E}}e.save(),e.strokeStyle=yh,e.lineWidth=2,e.globalAlpha=.85,e.setLineDash([8,6]),e.beginPath();for(let b=0;b<l.length;b+=1){let S;if(u){const A=i.length===256?b:Math.round(b/(i.length-1)*255);A<u.length?S=u[A]/255*100:S=b/(i.length-1)*100}else S=b/(i.length-1)*100;const E=Math.max(0,Math.min(o,l[b]*o)),y=nr(S,t),v=Qt(E,t);c.samples.push({input:S,output:E}),b===0?e.moveTo(y,v):e.lineTo(y,v)}e.stroke(),e.setLineDash([]);const g=Math.max(0,Math.min(o,t.displayMax||100));e.save(),e.strokeStyle=tA,e.lineWidth=1.5,e.globalAlpha=.75,e.setLineDash([4,4]),e.beginPath(),e.moveTo(nr(0,t),Qt(0,t)),e.lineTo(nr(100,t),Qt(g,t)),e.stroke(),e.restore(),c.baseline=[{input:0,output:0},{input:100,output:g}],te.lastCorrectionOverlay=c,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastCorrectionOverlay=c),e.restore()}catch(n){console.warn("[CHART DEBUG] Failed to draw correction target overlay:",n),te.lastCorrectionOverlay=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastCorrectionOverlay=null)}}function _A(e,t,n){try{let r=[];if(typeof D?.getLabMeasurementCorrections=="function"?r=D.getLabMeasurementCorrections({skipEndpoints:!0}):Array.isArray(D?.globalMeasurementCorrections)&&(r=D.globalMeasurementCorrections.filter(P=>!P?.isEndpoint)),!Array.isArray(r)||r.length===0){te.lastLabSpotMarkers=null;return}if(r.length>256){te.lastLabSpotMarkers=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastLabSpotMarkers=null);return}const i=typeof Ee=="function"?Ee():null;let a=D0(i,t.displayMax||100);(!Number.isFinite(a)||a<=0)&&(a=Math.min(t.displayMax||100,100));const o=t.dpr||re.devicePixelRatio||1,s=Math.max(4*o,Math.min(t.chartHeight*.02,9*o)),l=Math.max(s*.7,2.5*o),c=Math.max(l*1.4,Math.min(t.chartHeight*.25,60*o))/8,u=Math.max(l*.9,5*o),d=Math.max(11*o,Math.min(14*o,t.chartHeight*.035)),p=n?.text||rA,f={...t,displayMax:100},h=t.padding,g=t.height-(t.bottomPadding||t.padding);let S=Qt(70,f);Number.isFinite(S)||(S=g-l);const E=h+l,y=g-l;S<E?S=E:S>y&&(S=y),e.save(),e.lineCap="round",e.font=`${Math.round(d)}px Inter, ui-sans-serif`,e.textBaseline="middle";const v=g,A=Math.max(4*o,4),w=Math.max(2*o,2),M=t.padding||0,I=(t.width||t.chartWidth+(t.leftPadding||0)+(t.rightPadding||0))-(t.rightPadding||t.padding||0),_=0,C=Math.max(2*o,2),x=[];r.forEach(P=>{if(!P||!Number.isFinite(P.inputPercent))return;const k=Number.isFinite(P.measuredPercent)?P.measuredPercent:Number.isFinite(P.measuredNormalized)?P.measuredNormalized*100:null;if(!Number.isFinite(k))return;const N=Math.max(0,Math.min(a,k)),F=nr(P.inputPercent,t),U=Qt(N,t),j=Number(P.correctionGain),B=Number(P.appliedDeltaPercent),G=Number(P.baseDeltaPercent),V=Number(P.residualDeltaPercent),K=Number.isFinite(B)?B:Number(P.deltaPercent)||0,se=Math.abs(K),W={inputPercent:P.inputPercent,measuredPercent:N,lab:Number.isFinite(P.lab)?P.lab:null,deltaPercent:K,action:P.action||"within",withinTolerance:P.withinTolerance===!0,tolerancePercent:Number(P.tolerancePercent)||1,magnitudePercent:Number.isFinite(P.magnitudePercent)?Math.abs(P.magnitudePercent):se,normalizedMagnitude:Number(P.normalizedMagnitude)||0,direction:Number(P.direction)||(K>=0?1:-1),canvasX:F,canvasY:S,measuredCanvasY:U,radius:l,correctionGain:Number.isFinite(j)?j:null,appliedDeltaPercent:K,residualDeltaPercent:Number.isFinite(V)?V:Number.isFinite(G)?G-K:0,baseDeltaPercent:Number.isFinite(G)?G:K};if(W.withinTolerance){e.save(),e.beginPath(),e.arc(F,S,l,0,Math.PI*2),e.fillStyle=nA,e.fill(),e.lineWidth=Math.max(1.5*o,1.5),e.strokeStyle=h0,e.stroke(),e.strokeStyle="#ffffff",e.lineWidth=Math.max(2*o,2),e.lineCap="round",e.beginPath(),e.moveTo(F-l*.55,S),e.lineTo(F-l*.12,S+l*.55),e.lineTo(F+l*.6,S-l*.6),e.stroke(),e.restore(),W.label="Within tolerance",x.push(W);return}e.save(),e.beginPath(),e.arc(F,S,l,0,Math.PI*2),e.fillStyle=vh,e.fill(),e.lineWidth=Math.max(1.25*o,1.5),e.strokeStyle=n?.axis||"#1f2937",e.stroke(),e.restore();const fe=W.direction>=0?-1:1,Se=W.direction>=0?lp:cp,we=Number(P.clampedMagnitudePercent),Ne=Number.isFinite(we)?we:W.magnitudePercent,ct=Math.max(c*Math.max(Ne,.25),u*.75),mt=l+C,Vt=S+(fe>=0?mt:-mt);let xt=Vt+fe*ct;fe<0&&xt<t.padding?xt=t.padding:fe>0&&xt>v&&(xt=v),e.save(),e.strokeStyle=Se,e.lineWidth=Math.max(2*o,2),e.beginPath(),e.moveTo(F,Vt),e.lineTo(F,xt),e.stroke();const Un=xt,Bt=Un-fe*u;e.beginPath(),e.moveTo(F,Un),e.lineTo(F-u*.6,Bt),e.lineTo(F+u*.6,Bt),e.closePath(),e.fillStyle=Se,e.fill(),e.restore(),e.save(),e.beginPath(),e.arc(F,U,Math.max(2*o,2.5),0,Math.PI*2),e.fillStyle=`${Se}33`,e.fill(),e.restore();const Gt=`${W.deltaPercent>=0?"+":""}${W.deltaPercent.toFixed(1)}%`,Lt=e.measureText(Gt).width+A*2,rt=d+w*2;let wt=F-Lt/2+_;wt<M?wt=M:wt+Lt>I&&(wt=I-Lt);let Ct;fe<0?(Ct=Math.min(S-l-rt-C,xt-rt-C),Ct<t.padding&&(Ct=t.padding)):(Ct=S-l-rt-C,Ct<t.padding&&(Ct=t.padding)),e.save(),e.fillStyle=vh,e.fillRect(wt,Ct,Lt,rt),e.lineWidth=Math.max(1*o,1),e.strokeStyle=n?.axis||"#1f2937",e.strokeRect(wt,Ct,Lt,rt),e.fillStyle=p,e.fillText(Gt,wt+A,Ct+rt/2),e.restore(),W.label=Gt,W.labelBounds={x:wt,y:Ct,width:Lt,height:rt},x.push(W)}),e.restore(),te.lastLabSpotMarkers=x,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastLabSpotMarkers=x.map(P=>({...P})))}catch(r){console.warn("[CHART DEBUG] Failed to draw LAB spot markers:",r),te.lastLabSpotMarkers=null,tt&&re.__quadDebug?.chartDebug&&(re.__quadDebug.chartDebug.lastLabSpotMarkers=null)}}function NA(e,t,n,r,i){try{const a=D.hasAnyLinearization()||D.getPerChannelData(r),o=Ee(),s=typeof D?.getGlobalBaselineCurves=="function"?D.getGlobalBaselineCurves():null,l=o?.originalCurves?.[r],c=l&&l.length?l:s?.[r]||null;if(!(Array.isArray(c)||ArrayBuffer.isView(c)||c&&typeof c.length=="number")||!c||c.length===0){te.lastOriginalOverlays[r]&&(delete te.lastOriginalOverlays[r],tt&&re.__quadDebug?.chartDebug?.lastOriginalOverlays&&delete re.__quadDebug.chartDebug.lastOriginalOverlays[r]);return}if(!(a||!!o)){te.lastOriginalOverlays[r]&&(delete te.lastOriginalOverlays[r],tt&&re.__quadDebug?.chartDebug?.lastOriginalOverlays&&delete re.__quadDebug.chartDebug.lastOriginalOverlays[r]);return}const p={channelName:r,color:Sh,samples:[],percentSamples:[]};e.save(),e.strokeStyle=Sh,e.globalAlpha=.9,e.lineWidth=1.75,e.setLineDash([4,2]),e.beginPath();const f=Math.max(1,c.length-1);for(let h=0;h<c.length;h++){const g=h/f*100,b=Number(c[h])||0,S=Math.max(0,Math.min(ve,Math.round(b)));p.samples.push(S);const E=S/ve*100;p.percentSamples.push(E);const y=Math.max(0,Math.min(t.displayMax,E)),v=nr(g,t),A=Qt(y,t);h===0?e.moveTo(v,A):e.lineTo(v,A)}if(e.stroke(),e.setLineDash([]),e.restore(),te.lastOriginalOverlays[r]=p,tt&&re.__quadDebug?.chartDebug){const h=re.__quadDebug.chartDebug.lastOriginalOverlays||(re.__quadDebug.chartDebug.lastOriginalOverlays={});h[r]=p}}catch(a){console.warn(`Error drawing original overlay for ${r}:`,a),te.lastOriginalOverlays[r]&&(delete te.lastOriginalOverlays[r],tt&&re.__quadDebug?.chartDebug?.lastOriginalOverlays&&delete re.__quadDebug.chartDebug.lastOriginalOverlays[r])}}function FA(e,t,n,r){try{if(!m.rows)return;const i=Array.from(m.rows.children).filter(l=>l.id!=="noChannelsRow"),a=[],o=[];tt&&(re.__chartDrawMeta=o);const s=typeof bs=="function"&&bs();for(const l of i){const c=l.getAttribute("data-channel");if(!c)continue;const u=l.querySelector(".percent-input"),d=l.querySelector(".end-input");if(!u||!d)continue;const p=q.clampPercent(u.getAttribute("data-base-percent")??u.value),f=q.clampEnd(d.getAttribute("data-base-end")??d.value);if(p===0||f===0){const P=u.dataset.userEditing==="true"||u.dataset.pendingCommitValue!=null,k=d.dataset.userEditing==="true"||d.dataset.pendingCommitValue!=null;P||(u.value=bh(p)),k||(d.value=String(f));continue}const h=D.globalApplied&&D.globalData,g=Hr(c),b=Yt(f,c,h,{normalizeToEnd:g});TA(e,t,n,c,f);const S=RA(e,t,n,c,b,f);NA(e,t,n,c,f),S&&o.push({channelName:c,alpha:S.strokeAlpha,lineWidth:S.strokeWidth,isSelected:S.isSelectedChannel,editMode:S.isEditMode});const E=ni[c]||"#000000";let y=0;for(let P=0;P<b.length;P++){const k=b[P];Number.isFinite(k)&&k>y&&(y=k)}const v=q.clampEnd(f),A=q.computePercentFromEnd(v),w=A,M=g?v:f,I=Qt(Math.max(0,Math.min(100,w)),t),_=u.dataset.userEditing==="true"||u.dataset.pendingCommitValue!=null,C=d.dataset.userEditing==="true"||d.dataset.pendingCommitValue!=null,x=!s;!_&&x&&(u.value=bh(A)),x&&u.setAttribute("data-base-percent",String(A)),!C&&x&&(d.value=String(M)),x&&d.setAttribute("data-base-end",String(M)),a.push({channelName:c,percent:Math.round(w),inkColor:E,endY:I})}a.length>0&&zA(e,t,a,r)}catch(i){console.error("Error rendering channel curves:",i)}}function GA(e,t,n,r,i){const a=nr(r,t),o=Qt(i,t),s=Math.max(6,Math.min(12,t.chartHeight*.035));e.save(),e.beginPath(),e.moveTo(a,o-s),e.lineTo(a-s*.75,o-s*.2),e.lineTo(a+s*.75,o-s*.2),e.closePath(),e.fillStyle=n,e.fill(),e.lineWidth=1.5,e.strokeStyle="#ffffff",e.stroke(),e.restore()}function RA(e,t,n,r,i,a){try{const o=ni[r]||"#000000",s=typeof re.isEditModeEnabled=="function"&&re.isEditModeEnabled(),l=s&&re.EDIT&&re.EDIT.selectedChannel===r,c=s&&!l,u=c?.45:.95,d=c?2:3;e.save(),e.strokeStyle=o,e.lineWidth=d,e.globalAlpha=u,e.beginPath();let p=-1,f=-1/0;const h=Math.max(1,i.length-1);for(let g=0;g<i.length;g++){const b=Number(i[g])||0;b>f&&(f=b,p=g);const S=g/h*100,E=b/ve*100,y=nr(S,t),v=Qt(E,t);g===0?e.moveTo(y,v):e.lineTo(y,v)}if(e.stroke(),e.restore(),p>=0&&f>0){const g=p/h*100,b=f/ve*100;GA(e,t,o,g,b);const S=typeof Ee=="function"?Ee():null;S&&((!S.channelPeaks||typeof S.channelPeaks!="object")&&(S.channelPeaks={}),S.channelPeaks[r]=p)}else{const g=typeof Ee=="function"?Ee():null;g?.channelPeaks&&r in g.channelPeaks&&delete g.channelPeaks[r]}try{if(console.log(`[OVERLAY DEBUG] ${r}: editMode=${s}, selectedChannel=${re.EDIT?.selectedChannel}, isSelectedChannel=${l}`),l){const g=Te.get(r);if(console.log(`[OVERLAY DEBUG] ${r}: smartPoints exist=${!!g?.points}, count=${g?.points?.length||0}`),g?.points&&console.log(`[OVERLAY DEBUG] ${r}: points=`,g.points.slice(0,3)),g&&g.points&&g.points.length>0){const b=re.EDIT.selectedOrdinal||1,S=Oe.active&&Oe.channel===r;vC(e,t,n,r,g.points,i,ve,b,o,{drawMarkers:!0,showLabels:m.aiLabelToggle?m.aiLabelToggle.checked:!0,boxSize:S?9:6,isDragging:S})}}}catch(g){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn(`Smart key point overlay error for ${r}:`,g)}return{isEditMode:s,isSelectedChannel:l,strokeAlpha:u,strokeWidth:d}}catch(o){return console.error(`Error drawing curve for ${r}:`,o),null}}function zA(e,t,n,r){try{const i=f=>Math.max(1,Math.round(f*r)),a=f=>f*r;n.sort((f,h)=>f.endY-h.endY);const o=Math.max(10,Math.round(11*r*10)/10);e.font=`bold ${o}px system-ui`,e.textAlign="left";const s=i(20),l=t.leftPadding+t.chartWidth,c=getComputedStyle(document.documentElement),u=(c.getPropertyValue("--bg-elevated")||"#ffffff").trim(),d=(c.getPropertyValue("--border")||"#e5e7eb").trim(),p=(c.getPropertyValue("--text")||"#111827").trim();for(let f=0;f<n.length;f++){let h=n[f].endY+a(4);if(f>0){const U=n[f-1].adjustedY||n[f-1].endY+a(4);h-U<s&&(h=U+s)}n[f].adjustedY=h;const g=`${n[f].channelName} ${n[f].percent}%`,b=e.measureText(g),S=i(8),E=i(12),y=i(6),v=i(16),A=S+y+Math.ceil(b.width)+y,w=v+i(2),M=i(4),I=Math.min(l,t.width-t.rightPadding+i(4)),_=t.width-A-M,C=Math.min(I,_),x=h-v+a(5);e.fillStyle=u,e.fillRect(C,x,A,w),e.strokeStyle=d,e.lineWidth=1,e.strokeRect(C+.5,x+.5,A-1,w-1);const P=C+y/2,k=x+Math.round((w-E)/2);e.fillStyle=n[f].inkColor,e.fillRect(Math.round(P)+.5,Math.round(k)+.5,S,E),e.strokeStyle="rgba(0,0,0,0.2)",e.strokeRect(Math.round(P)+.5,Math.round(k)+.5,S,E);const N=C+S+y,F=x+Math.round(w/2)+a(5)-a(2);e.fillStyle=p,e.fillText(g,N,F)}}catch(i){console.error("Error drawing ink labels:",i)}}function UA(e,t,n){const r=Array.isArray(n?.curve)?n.curve:n?.normalizedCurve;if(!Array.isArray(r)||r.length<2)return;const i=r.length-1,a=Number.isFinite(t?.displayMax)&&t.displayMax>0?t.displayMax:100;e.save(),e.strokeStyle=iA,e.lineWidth=Math.max(2,Math.min(4,t.chartHeight*.005)),e.beginPath();for(let o=0;o<r.length;o+=1){const s=i===0?0:o/i*100,l=Number(r[o])||0,c=Math.max(0,Math.min(a,l/100*a)),u=nr(s,t),d=Qt(c,t);o===0?e.moveTo(u,d):e.lineTo(u,d)}e.stroke(),e.restore(),qA(e,t),jA(e,t,n)}function $A(e,t,n){const r=Array.isArray(n?.curve)?n.curve:null;if(!Array.isArray(r)||r.length<2)return;const i=Number.isFinite(n?.threshold)?n.threshold:js(),a=hi(t),o=[6,6],s=r.length-1,l=d=>{const p=Math.max(0,Math.min(a,Number(d)||0));return Qt(p,t)};e.save(),e.lineWidth=Math.max(2,Math.min(4,t.chartHeight*.005)),e.globalAlpha=.8;let c=r[0]>i?rc:up,u=r[0]<=i;e.strokeStyle=c,e.setLineDash(u?o:[]),e.beginPath();for(let d=0;d<r.length;d+=1){const p=s===0?0:d/s*100,f=Number(r[d])||0,h=nr(p,t),g=l(f);if(d===0){e.moveTo(h,g);continue}const b=f>i?rc:up,S=f<=i;b!==c||S!==u?(e.lineTo(h,g),e.stroke(),e.beginPath(),e.moveTo(h,g),c=b,u=S,e.strokeStyle=c,e.setLineDash(u?o:[])):e.lineTo(h,g)}e.stroke(),e.restore(),VA(e,t,n)}function VA(e,t,n){const r=Number.isFinite(n?.maxValue)?n.maxValue:0,i=Number.isFinite(n?.threshold)?n.threshold:js(),a=r>i,o=typeof window<"u"?getComputedStyle(document.documentElement):{getPropertyValue:()=>""},s=(o.getPropertyValue?.("--bg-elevated")||"#ffffff").trim(),l=(o.getPropertyValue?.("--text")||sA).trim(),c=a?rc:up,u=t?.dpr||1,d=Math.max(11,Math.round(11*u)),p=6*u,f=4*u,h=`Max Ink Load ${Math.round(r*10)/10}%`;e.save(),e.font=`bold ${d}px system-ui`,e.textAlign="left";const g=t.leftPadding+10*u,b=t.padding+20*u,S=e.measureText(h),E=Math.ceil(S.width)+p*2,y=d+f*2,v=g,A=b-d-f;e.fillStyle=s,e.fillRect(v,A,E,y),e.strokeStyle=c,e.lineWidth=1,e.strokeRect(v+.5,A+.5,E-1,y-1),e.fillStyle=a?rc:l,e.fillText(h,v+p,b-2*u),e.restore()}function HA(){const e=zb();if(!e||!e.curves)return null;const t=256,n=Array.from({length:t},()=>0);let r=!1;const i=lt(),a=Array.isArray(i?.channels)?i.channels:[];for(const s of a){const l=e.curves[s];if(!Array.isArray(l)||l.length===0)continue;const c=kr(s),u=Number.isFinite(c?.value)?Math.max(0,c.value):0;if(u<=0)continue;const d=l.map(p=>{const f=Number(p);return Number.isFinite(f)?Math.max(0,Math.min(1,f/ve)):0});for(let p=0;p<t;p++){const f=d[p]??0;f>0&&(r=!0);const h=f*100*u;n[p]+=Number.isFinite(h)?h:0}}if(!r)return null;let o=0;for(let s=0;s<n.length;s++)n[s]=Math.max(0,Math.min(100,n[s])),n[s]>o&&(o=n[s]);if(o>0)for(let s=0;s<n.length;s++)n[s]=Math.max(0,Math.min(100,n[s]/o*100));return n}function qA(e,t){if(!vf())return;const n=HA();if(!n||n.length===0)return;const r=Number.isFinite(t?.displayMax)&&t.displayMax>0?t.displayMax:100;e.save(),e.strokeStyle=oA,e.lineWidth=1.5,e.setLineDash([6,4]),e.beginPath();const i=n.length-1;for(let a=0;a<n.length;a++){const o=a/i*100,s=n[a],l=Math.max(0,Math.min(r,s/100*r)),c=nr(o,t),u=Qt(l,t);a===0?e.moveTo(c,u):e.lineTo(c,u)}e.stroke(),e.restore()}function jA(e,t,n){const r=Number.isFinite(n?.maxValue)?n.maxValue:Number.isFinite(n?.normalizedMaxValue)?n.normalizedMaxValue:0,i=Number.isFinite(n?.rawMaxValue)?n.rawMaxValue:null;let a=`Light Block ${r.toFixed(1)}%`;i!=null&&Math.abs(i-r)>.05&&(a+=` (raw ${i.toFixed(1)}%)`),e.save();const o=Math.max(11,Math.min(16,t.chartHeight*.05));e.font=`600 ${o}px system-ui`,e.fillStyle=aA,e.textBaseline="top";const s=e.measureText(a).width,l=t.leftPadding+t.chartWidth-12,c=Math.max(t.leftPadding+12,l-s),u=Number.isFinite(t?.displayMax)&&t.displayMax>0?t.displayMax:100,p=Math.max(0,Math.min(100,r))/100*u,f=Qt(p,t)-o-8,h=t.padding+8,g=Math.max(h,f);if(e.fillText(a,c,g),Array.isArray(n?.contributingChannels)&&n.contributingChannels.length){const S=`Channels: ${n.contributingChannels.join(", ")}`,E=Math.max(9,Math.min(14,o-2));e.font=`500 ${E}px system-ui`,e.fillText(S,c,g+o+2)}e.restore()}function WA(e,t){const n=t.getBoundingClientRect(),r=t.width/n.width,i=t.height/n.height,a=(e.clientX-n.left)*r,o=(e.clientY-n.top)*i,s=Bb(t,Bo(),r),l=xb(a,s),c=bf(o,s);return{canvasX:a,canvasY:o,inputPercent:Math.round(l*10)/10,outputPercent:Math.round(c*10)/10}}function KA(e){lr=e;const t=m.inkChart,n=m.chartCursorTooltip;if(!(!t||!n)&&!t._cursorTooltipBound){const r=t.closest(".relative")||t.parentElement||document.body;let i=null;const a=(c,u)=>{if(Oe.active||!lr)return;const d=m.inkChartOverlay,p=d?.getContext("2d");p&&p.clearRect(0,0,d.width,d.height);const f=t.getBoundingClientRect(),h=t.width/f.width,g=t.height/f.height,b=(c-f.left)*h,S=(u-f.top)*g,{leftPadding:E,chartWidth:y}=lr;let v=(b-E)/y*100;v=Math.max(0,Math.min(100,v));let A=bf(S,lr),w=b,M=Qt(A,lr),I=!1;try{if(typeof re.isEditModeEnabled=="function"&&re.isEditModeEnabled()&&re.isEditModeEnabled()&&re.EDIT&&re.EDIT.selectedChannel){const F=re.EDIT.selectedChannel,U=Array.from(m.rows.children).find(j=>j.getAttribute("data-channel")===F);if(U){const j=Nt(F),B=q.clampEnd(U.querySelector(".end-input")?.value||0);if(!j&&B>0){I=!0;const G=Yt(B,F,!0,{normalizeToEnd:Hr(F)}),V=Math.max(0,Math.min(1,v/100))*(G.length-1),K=Math.floor(V),se=Math.min(G.length-1,K+1),W=V-K,fe=(1-W)*G[K]+W*G[se],Se=Math.max(0,Math.min(100,fe/ve*100));if(A=Se,M=Qt(Se,lr),p){const we=ni[F]||"#000000";p.save(),p.beginPath(),p.arc(Math.max(E,Math.min(E+y,w)),M,8,0,Math.PI*2),p.lineWidth=4,p.strokeStyle=we,p.stroke(),p.restore()}}}}}catch(N){console.warn("Edit mode tooltip integration failed:",N)}let _=null;if(te.showLabSpotMarkers&&Array.isArray(te.lastLabSpotMarkers)){const N=lr?.dpr||1,F=Math.max(10*N,12);for(const U of te.lastLabSpotMarkers){if(!U)continue;const j=b-U.canvasX,B=S-U.canvasY,G=(U.radius||8)+F;if(j*j+B*B<=G*G){_=U;break}if(U.labelBounds){const{x:V,y:K,width:se,height:W}=U.labelBounds;if(b>=V&&b<=V+se&&S>=K&&S<=K+W){_=U;break}}}}const C=[];if(_){if(p){if(p.save(),p.strokeStyle=_.action==="darken"?lp:_.action==="lighten"?cp:h0,p.lineWidth=Math.max((_.radius||8)*.35,2*(lr?.dpr||1)),p.setLineDash([6,4]),p.beginPath(),p.arc(_.canvasX,_.canvasY,(_.radius||8)+Math.max(4*(lr?.dpr||1),4),0,Math.PI*2),p.stroke(),Number.isFinite(_.measuredCanvasY)){const N=lr?.dpr||e.dpr||1,F=(lr?.height??e.height)-(lr?.bottomPadding??e.bottomPadding??0);p.lineWidth=Math.max(1.5*N,1.5),p.setLineDash([3,3]),p.beginPath(),p.moveTo(_.canvasX,_.canvasY+(_.radius||8)),p.lineTo(_.canvasX,F),p.stroke(),p.fillStyle=`${_.action==="darken"?lp:cp}66`,p.beginPath(),p.arc(_.canvasX,_.measuredCanvasY,Math.max(3*N,3),0,Math.PI*2),p.fill()}p.restore()}if(C.push(`Input ${_.inputPercent.toFixed(1)}%`),Number.isFinite(_.lab)&&C.push(`Measured L* ${_.lab.toFixed(2)}`),_.action==="within")C.push(`Action: within Â±${_.tolerancePercent?.toFixed?.(1)??"1"}% (âœ“)`);else{const N=_.action==="darken"?"Darken":"Lighten";C.push(`Action: ${N} ${Math.abs(_.deltaPercent).toFixed(1)}%`)}}else C.push(`${v.toFixed(1)}, ${A.toFixed(1)}`);if(te.showLightBlockingOverlay&&te.lastLightBlockingCurve){const N=dA(v);if(Number.isFinite(N)){let F=`Light Block: ${N.toFixed(1)}%`;const U=pA(v);Number.isFinite(U)&&U>0&&(F+=` (raw ${U.toFixed(1)}%)`),C.push(F)}}if(te.showInkLoadOverlay&&te.lastInkLoadOverlay){const N=fA(v);if(Number.isFinite(N)){const F=Number(te.lastInkLoadOverlay.threshold)||0,U=F>0&&N>F?" âš ï¸":"";C.push(`Ink Load: ${N.toFixed(1)}%${U}`)}}!_&&I&&C.push("click to add point"),n.innerHTML=C.join("<br>");const x=r.getBoundingClientRect(),P=c-x.left+12,k=u-x.top-24;n.style.left=`${P}px`,n.style.top=`${k}px`,n.classList.remove("hidden")},o=c=>{i&&cancelAnimationFrame(i);const u=c.clientX,d=c.clientY;i=requestAnimationFrame(()=>{i=null,a(u,d)})},s=()=>{i&&(cancelAnimationFrame(i),i=null),n.classList.add("hidden");const c=m.inkChartOverlay;if(c){const u=c.getContext("2d");u&&u.clearRect(0,0,c.width,c.height)}},l=c=>{if(te.lastSelectionProbe={reason:"start"},typeof console<"u"&&console.log("[CHART] canvas click detected"),Oe.suppressClick){Oe.suppressClick=!1,te.lastSelectionProbe={reason:"suppressed"};return}try{const u=typeof re.isEditModeEnabled=="function"&&re.isEditModeEnabled();if(!u||!re.quadGenActions||!re.EDIT||!re.EDIT.selectedChannel){te.lastSelectionProbe={reason:"editModeUnavailable",isEditMode:u,hasActions:!!re.quadGenActions,hasEditState:!!re.EDIT};return}const d=re.EDIT.selectedChannel,p=Array.from(m.rows.children).find(B=>B.getAttribute("data-channel")===d);if(!p){te.lastSelectionProbe={reason:"rowMissing",channel:d};return}const f=Zo(d,p),h=f?.values||null,g=f?.endValue??0,b=re.ControlPoints?.get(d)?.points||[],S=Oe.geom;let E=!1;if(S&&b.length>0&&h){const B=C0(c,t),G=op*(Number(S?.dpr)||1),V=vE({canvasX:B.canvasX,canvasY:B.canvasY,points:b,geom:S,tolerance:G,values:h,maxValue:ve});te.lastSelectionProbe={channel:d,coords:B,tolerance:G,geomAvailable:!!S,pointsCount:b.length,valuesAvailable:!!h,hit:V},V&&Number.isInteger(V.ordinal)&&Ss(d,V.ordinal,{description:`Select ${d} Smart point ${V.ordinal} (chart click)`})?.success&&(E=!0)}else te.lastSelectionProbe={channel:d,geomAvailable:!!S,pointsCount:b.length,valuesAvailable:!!h,hit:null};if(E){c.preventDefault();return}if(Nt(d)){Z(Vi(d,"inserting points")),te.lastSelectionProbe={reason:"channelLocked",channel:d};return}if(!h||!Number.isFinite(g)||g<=0){te.lastSelectionProbe={reason:"invalidSamples",channel:d,valuesAvailable:!!h,endValue:g};return}const y=t.getBoundingClientRect(),v=t.width/y.width,A=t.height/y.height,w=(c.clientX-y.left)*v,M=(c.clientY-y.top)*A,{leftPadding:I,chartWidth:_}=lr;let C=(w-I)/_*100;C=Math.max(0,Math.min(100,C));const x=Math.max(0,Math.min(1,C/100))*(h.length-1),P=Math.floor(x),k=Math.min(h.length-1,P+1),N=x-P,F=(1-N)*h[P]+N*h[k];let U=Math.max(0,Math.min(100,F/ve*100));const j=re.quadGenActions.insertSmartKeyPointAt(d,C,U);if(j&&j.success){console.log("Point inserted successfully at",C.toFixed(1),",",U.toFixed(1));try{const B=re.ControlPoints?.get(d)?.points||[];if(B.length>0&&re.ControlPoints?.nearestIndex){const G=re.ControlPoints.nearestIndex(B,C,100);G&&typeof G.index=="number"&&G.index>=0&&re.EDIT&&(re.EDIT.selectedOrdinal=G.index+1,console.log("Selected newly inserted point:",re.EDIT.selectedOrdinal),typeof re.edit_refreshPointIndex=="function"&&re.edit_refreshPointIndex())}}catch(B){console.warn("Failed to update point selection:",B)}try{Pn()}catch(B){console.warn("Failed to update preview after point insertion:",B)}}else j&&!j.success&&j.message&&Z(j.message)}catch(u){console.warn("Click-to-insert failed:",u)}};t.addEventListener("mousemove",o),t.addEventListener("mouseenter",o),t.addEventListener("mouseleave",s),t.addEventListener("click",l),t._cursorTooltipBound=!0,console.log("ðŸ“Š Chart cursor tooltip setup complete")}}function YA(e){const t=m.inkChart;if(!t||(e&&(Oe.geom=e),t._smartPointDragBound))return;const n=64;let r=null;const i=d=>{if(d.button!==0)return;br=null;const p=Lh();if(!p)return;const f=Oe.geom;if(!f){te.lastSelectionProbe={reason:"geomMissing"};return}const h=fl(p),b=Zo(p,h)?.values;if(!b||!Array.isArray(b)){te.lastSelectionProbe={reason:"noSamples",channel:p};return}const E=Te.get(p)?.points||[];if(E.length===0){te.lastSelectionProbe={reason:"noPoints",channel:p};return}const y=C0(d,t),v=op*(f?.dpr||1),A=zd(y.canvasX,y.canvasY,{points:E,geom:f,tolerance:v,values:b,maxValue:ve});if(!A){te.lastSelectionProbe={reason:"noHit",channel:p};return}const w=Nt(p),M=Mh();if(br={channel:p,ordinal:A.ordinal,pointerId:d.pointerId},te.lastSelectionProbe={reason:"pointerDownHit",channel:p,ordinal:A.ordinal,dragAvailable:M,locked:w},w){Z(`${p} ink limit is locked. Unlock before adjusting points.`),Tn(t,"");return}if(!(!M||!nS(p,A.ordinal).success)){Oe.pointerId=d.pointerId,Oe.active=!0,Oe.channel=p,Oe.ordinal=A.ordinal,Oe.moved=!1,m.chartCursorTooltip&&m.chartCursorTooltip.classList.add("hidden");try{t.setPointerCapture(d.pointerId)}catch(_){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CHART] Pointer capture failed:",_)}Tn(t,"grabbing"),Z(`Dragging ${p} point ${A.ordinal}`),d.preventDefault()}},a=(d,p,f)=>{if(!Oe.geom)return;const h=Oe.geom,g=t.getBoundingClientRect(),b=t.width/g.width,S=t.height/g.height,E=(d-g.left)*b,y=(p-g.top)*S,v={canvasX:E,canvasY:y};if(Oe.active&&Oe.pointerId===f){if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[CHART] Pointer move",{clientX:d,clientY:p,rect:g}),d<g.left-n||d>g.right+n||p<g.top-n||p>g.bottom+n){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[CHART] Cancelling drag: pointer outside",{clientX:d,clientY:p,rect:g});const fe=Oe.pointerId;if(fe!=null)try{t.releasePointerCapture(fe)}catch(Se){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CHART] Pointer release during cancel failed:",Se)}s(!1),Tn(t,"");return}const k=Oe.channel;if(Nt(k))return;const N=fl(k),F=Zo(k,N);if(!F||!Array.isArray(F.values))return;const j=Te.get(k)?.points||[];if(j.length===0)return;const B=xb(v.canvasX,h),G=bf(v.canvasY,h),V=EE(B,G,{points:j,ordinal:Oe.ordinal,geom:h}),K=hi(h),se=EC(V.outputPercent,K);rS(k,Oe.ordinal,{inputPercent:V.inputPercent,outputPercent:se})?.success&&(Oe.moved=!0,br=null);return}if(!Mh()){Tn(t,""),Oe.hoverOrdinal=null;return}const A=Lh();if(!A){Tn(t,""),Oe.hoverOrdinal=null;return}if(Nt(A)){Tn(t,""),Oe.hoverOrdinal=null;return}const w=fl(A),M=Zo(A,w);if(!M||!Array.isArray(M.values)){Tn(t,""),Oe.hoverOrdinal=null;return}const _=Te.get(A)?.points||[];if(_.length===0){Tn(t,""),Oe.hoverOrdinal=null;return}const C=op*(h?.dpr||1),x=zd(v.canvasX,v.canvasY,{points:_,geom:h,tolerance:C,values:M.values,maxValue:ve});x?(Tn(t,"grab"),Oe.hoverOrdinal=x.ordinal):Oe.hoverOrdinal!==null&&(Tn(t,""),Oe.hoverOrdinal=null)},o=d=>{if(!Oe.geom)return;r&&cancelAnimationFrame(r);const p=d.clientX,f=d.clientY,h=d.pointerId;r=requestAnimationFrame(()=>{r=null,a(p,f,h)})};function s(d){if(!Oe.active)return;const p=Oe.channel,f=Oe.ordinal;let h=!1;if(d){if(au()?.success){const E=(Te.get(p)?.points||[])[f-1];if(E){h=!0;const y=(E.input??0).toFixed(1),v=fl(p),A=CA(v),w=((E.output??0)*(A/100)).toFixed(1);Z(`Point ${f} set to ${y}% / ${w}% ink`)}}Oe.suppressClick=!0}else Bp(),Oe.suppressClick=!1,Oe.moved&&Z("Drag cancelled");!h&&d&&Z(`Point ${f} updated`),Ah()}const l=d=>{if(Oe.active&&Oe.pointerId===d.pointerId){try{t.releasePointerCapture(d.pointerId)}catch(f){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CHART] Pointer release failed:",f)}const p=Oe.moved;!p&&Oe.channel&&Number.isFinite(Oe.ordinal)&&(Ss(Oe.channel,Oe.ordinal,{description:`Select ${Oe.channel} Smart point ${Oe.ordinal} (pointer tap)`}),te.lastSelectionProbe={reason:"pointerTap",channel:Oe.channel,ordinal:Oe.ordinal,pointerId:d.pointerId}),s(p),br=null,Tn(t,"");return}if(br&&br.pointerId===d.pointerId){const{channel:p,ordinal:f}=br;p&&Number.isFinite(f)&&(Ss(p,f,{description:`Select ${p} Smart point ${f} (pointer click)`}),te.lastSelectionProbe={reason:"pointerClick",channel:p,ordinal:f,pointerId:d.pointerId}),br=null,Tn(t,"")}},c=d=>{if(r&&(cancelAnimationFrame(r),r=null),Oe.active){const p=Oe.pointerId;if(p!=null)try{t.releasePointerCapture(p)}catch(f){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CHART] Pointer release on leave failed:",f)}s(!1),Tn(t,""),br=null;return}Oe.hoverOrdinal!==null&&(Tn(t,""),Oe.hoverOrdinal=null),br=null},u=d=>{r&&(cancelAnimationFrame(r),r=null),!(!Oe.active||Oe.pointerId!==d.pointerId)&&(Bp(),Ah(),Oe.suppressClick=!1,Tn(t,""),br=null)};t.addEventListener("pointerdown",i),t.addEventListener("pointermove",o),t.addEventListener("pointerup",l),t.addEventListener("pointerleave",c),t.addEventListener("lostpointercapture",u),t._smartPointDragBound=!0}tt&&(re.updateInkChart=Be,re.setChartStatusMessage=ho,re.testChartStatusMessage=()=>{console.log("ðŸ” Testing chart status message..."),ho("Preview updated",3e3)});const XA=200,ms=[],fp=new Set;let Ph=0;function QA(){return new Date().toISOString()}function ZA(){for(;ms.length>XA;)ms.shift()}function JA(e){fp.forEach(t=>{try{t(e)}catch(n){console.warn("[scaling-telemetry] subscriber error",n)}})}function eM(e){if(!e)return;const{phase:t,error:n}=e;if(t==="flush"){const r=n?.reason?` (${n.reason})`:"";Z(`Scaling queue flushed${r}`)}}function P0(){return Ph+=1,`scale-${Ph}`}function x0(e){if(!e||!e.phase)return null;const t={timestamp:QA(),...e};return ms.push(t),ZA(),JA(t),eM(t),t}function tM(){return[...ms]}function nM(){ms.length=0}function rM(e){return typeof e!="function"?()=>{}:(fp.add(e),()=>{fp.delete(e)})}Xe("scalingTelemetry",{record:x0,getBuffer:tM,clear:nM,subscribe:rM,generateOperationId:P0},{exposeOnWindow:typeof window<"u",windowAliases:[]});const iM="ui",aM="normal";function xa(){return typeof performance<"u"&&typeof performance.now=="function"?performance.now():Date.now()}function oM(e){const t=Number(e);return Number.isFinite(t)?t:NaN}class sM{constructor(t={}){this.scaleFn=t.scaleFn||(n=>Ys(n)),this.beginTransaction=t.beginTransaction||Ep,this.commitTransaction=t.commitTransaction||wp,this.rollbackTransaction=t.rollbackTransaction||Cp,this.queue=[],this.processing=!1,this.metrics={enqueued:0,processed:0,failed:0,maxQueueLength:0,lastDurationMs:0,lastError:null,lastResult:null},this._enabledOverride=typeof window>"u"?!1:void 0}_snapshotMetrics(){return{...this.metrics,queueLength:this.queue.length,processing:this.processing}}_snapshotOperation(t,n={}){return t?{id:t.id,percent:t.percent,source:t.source,priority:t.priority,metadata:t.metadata||null,enqueuedAt:t.enqueuedAt,startedAt:t.startedAt||null,completedAt:t.completedAt||null,failedAt:t.failedAt||null,durationMs:t.durationMs||null,...n}:null}_recordTelemetry(t,n,r={}){try{const{operationExtras:i,...a}=r||{};x0({phase:t,operation:this._snapshotOperation(n,i),metrics:this._snapshotMetrics(),...a})}catch(i){console.warn("[scaling-coordinator] telemetry error",i)}}isEnabled(){return typeof window<"u"?!!window.__USE_SCALING_COORDINATOR:!!this._enabledOverride}setEnabled(t){const n=this.isEnabled(),r=!!t;typeof window<"u"?window.__USE_SCALING_COORDINATOR=r:this._enabledOverride=r;const i=this.isEnabled();return n&&!i&&this.flushQueue("disabled"),i}scale(t,n=iM,r={}){const i=oM(t);if(!Number.isFinite(i)||i<=0)return Promise.reject(new Error(`Invalid scale percent "${t}"`));const a={id:P0(),percent:i,source:n,priority:r.priority||aM,metadata:r.metadata||null,enqueuedAt:xa()},o=new Promise((s,l)=>{a.resolve=s,a.reject=l});return a.priority==="high"?this.queue.unshift(a):this.queue.push(a),this.metrics.enqueued+=1,this.metrics.maxQueueLength=Math.max(this.metrics.maxQueueLength,this.queue.length),this._recordTelemetry("enqueue",a),this._processQueue(),o}async _processQueue(){if(!this.processing){for(this.processing=!0;this.queue.length>0;){const t=this.queue.shift(),n=xa(),r=`Scale channels to ${Jn(t.percent)} (${t.source})`;let i,a=!1;const o=typeof DEBUG_LOGS<"u"&&DEBUG_LOGS;o&&console.log("[SCALING COORDINATOR] Processing operation",{percent:t.percent,source:t.source,queueLength:this.queue.length});try{i=this.beginTransaction(r),t.startedAt=xa(),this._recordTelemetry("start",t);const s=await Promise.resolve(this.scaleFn(t.percent,t.metadata||{}));if(!s||s.success===!1){const u=s?.message||"Failed to scale channels";Z(u),await this._rollbackTransactionSafe(i),this.metrics.failed+=1,this.metrics.lastError=u,t.failedAt=xa(),this._recordTelemetry("fail",t,{error:{message:u},result:s||null}),o&&console.warn("[SCALING COORDINATOR] Operation failed",{message:u}),t.reject(new Error(u));continue}this.commitTransaction(i),a=!0,this._afterSuccessfulScale(s);const l=xa(),c=l-n;t.completedAt=l,t.durationMs=c,this.metrics.processed+=1,this.metrics.lastDurationMs=c,this.metrics.lastResult=s,this._recordTelemetry("success",t,{durationMs:c,result:s}),o&&console.log("[SCALING COORDINATOR] Operation complete",{durationMs:c,result:s}),t.resolve({...s,durationMs:c})}catch(s){!a&&i&&await this._rollbackTransactionSafe(i),this.metrics.failed+=1,this.metrics.lastError=s instanceof Error?s.message:String(s),Z(this.metrics.lastError),t.failedAt=xa(),this._recordTelemetry("fail",t,{error:s instanceof Error?{message:s.message}:{message:String(s)}}),o&&console.error("[SCALING COORDINATOR] Operation threw",s),t.reject(s)}}this.processing=!1}}async _rollbackTransactionSafe(t){try{t&&await Promise.resolve(this.rollbackTransaction(t))}catch(n){console.warn("Scaling coordinator rollback failed:",n)}}_afterSuccessfulScale(t){if(!t)return;const n=t.details?.scalePercent,r=Jn(n??t.percent??"");t.message&&Z(t.message),ho("Preview updated",2e3),Je(),Pn(),Li(),typeof window<"u"&&window.dispatchEvent(new CustomEvent("scaling-coordinator:completed",{detail:{percent:n,formattedPercent:r,message:t.message||null}}))}flushQueue(t="manual"){const n=[];for(;this.queue.length>0;){const r=this.queue.shift();r.reject(new Error(`Scaling coordinator queue flushed (${t})`)),n.push(this._snapshotOperation(r))}this.metrics.maxQueueLength=0,this._recordTelemetry("flush",null,{error:{reason:t},operations:n})}getDebugInfo(){return{enabled:this.isEnabled(),queueLength:this.queue.length,processing:this.processing,...this.metrics}}}const tr=new sM;typeof window<"u"&&(typeof window.__USE_SCALING_COORDINATOR>"u"&&(window.__USE_SCALING_COORDINATOR=!1),typeof window.enableScalingCoordinator!="function"&&(window.enableScalingCoordinator=e=>{const t=tr.setEnabled(e);return console.info(`Scaling coordinator ${t?"ENABLED":"DISABLED"}`),t}));Xe("scalingCoordinator",{coordinator:tr,setEnabled:e=>tr.setEnabled(e),getDebugInfo:()=>tr.getDebugInfo(),flushQueue:e=>tr.flushQueue(e)},{exposeOnWindow:typeof window<"u",windowAliases:["scalingCoordinator"]});let Et=100,vt=null;const Yr=1e3;let Nn=typeof window<"u"?!!window.__USE_SCALING_STATE:!1,Jo=null;const _e={totalChecks:0,mismatchCount:0,lastMismatchDelta:0,lastMismatchDetail:null,lastCheckTimestamp:null,lastCheckReason:null,lastExpectedMaxAllowed:null,lastObservedMaxAllowed:null,lastReason:null,reasonCounts:Object.create(null)};function tu(){return(!_e.reasonCounts||typeof _e.reasonCounts!="object")&&(_e.reasonCounts=Object.create(null)),_e.reasonCounts}function lM(e){if(typeof e!="string")return;const t=e.trim();if(!t)return;const n=tu(),r=Number.isFinite(n[t])?n[t]:Number(n[t])||0;n[t]=r+1,_e.lastReason=t}function cM(){if(typeof structuredClone=="function")try{const e=structuredClone(_e);return e.lastCheckTimestampIso=e.lastCheckTimestamp?new Date(e.lastCheckTimestamp).toISOString():null,e}catch(e){typeof console<"u"&&typeof console.warn=="function"&&console.warn("[SCALE] structuredClone failed for audit snapshot",e)}try{const e=JSON.parse(JSON.stringify(_e));return e.lastCheckTimestampIso=_e.lastCheckTimestamp?new Date(_e.lastCheckTimestamp).toISOString():null,e}catch(e){typeof console<"u"&&typeof console.warn=="function"&&console.warn("[SCALE] JSON snapshot failed for audit state",e)}return{totalChecks:_e.totalChecks,mismatchCount:_e.mismatchCount,lastMismatchDelta:_e.lastMismatchDelta,lastMismatchDetail:_e.lastMismatchDetail?{..._e.lastMismatchDetail}:null,lastCheckTimestamp:_e.lastCheckTimestamp,lastCheckTimestampIso:_e.lastCheckTimestamp?new Date(_e.lastCheckTimestamp).toISOString():null,lastCheckReason:_e.lastCheckReason,lastExpectedMaxAllowed:_e.lastExpectedMaxAllowed,lastObservedMaxAllowed:_e.lastObservedMaxAllowed,lastReason:_e.lastReason,reasonCounts:{...tu()}}}function Ho(e,t,n={}){if(typeof window>"u"||typeof window.dispatchEvent!="function")return;const r={status:typeof e=="string"?e:null,reason:typeof t=="string"?t:null,audit:cM()};n&&typeof n=="object"&&(Object.prototype.hasOwnProperty.call(n,"result")?r.result=n.result:Object.keys(n).length>0&&(r.payload=n));try{let i;if(typeof window.CustomEvent=="function")i=new window.CustomEvent(oh,{detail:r});else if(typeof Event=="function"){i=new Event(oh);try{Object.defineProperty(i,"detail",{configurable:!0,enumerable:!0,value:r})}catch{i.detail=r}}i&&window.dispatchEvent(i)}catch(i){console.warn("[SCALE] Failed to dispatch scaling audit event",i)}}function B0(){typeof window>"u"||(window.scalingStateAudit=_e)}function T0(e="reset"){_e.totalChecks=0,_e.mismatchCount=0,_e.lastMismatchDelta=0,_e.lastMismatchDetail=null,_e.lastCheckTimestamp=null,_e.lastCheckReason=e||null,_e.lastExpectedMaxAllowed=null,_e.lastObservedMaxAllowed=null,_e.lastReason=null,_e.reasonCounts=Object.create(null),Ho("reset",e||null)}function mp(e){if(!e||typeof e!="object")return{};const t={};for(const[n,r]of Object.entries(e)){const i=Number(r);Number.isFinite(i)&&(t[n]=Math.round(i))}return t}function O0(e,t){const n=mp(e),r=mp(t),i=new Set([...Object.keys(n),...Object.keys(r)]),a=[];for(const o of i){const s=Object.prototype.hasOwnProperty.call(n,o)?n[o]:null,l=Object.prototype.hasOwnProperty.call(r,o)?r[o]:null;s!==l&&a.push({channel:o,legacy:s,state:l})}return a}function hp(e){const t=mp(e);return Object.keys(t).length>0?t:null}B0();function uM(){return tu(),_e}function dM(){const e={..._e,lastCheckTimestampIso:_e.lastCheckTimestamp?new Date(_e.lastCheckTimestamp).toISOString():null,reasonCounts:{...tu()}};return typeof console<"u"&&typeof console.table=="function"?console.table([e]):console.log("[ScalingStateAudit]",e),e}function cr(e={}){const t=e&&typeof e=="object"?e:{},n=typeof t.reason=="string"&&t.reason.trim()?t.reason:null,r=t.throwOnMismatch!==!1;if(lM(n||"parity-check"),!Nn){const w={ok:!0,skipped:!0};return Ho("disabled",n||"flag-disabled",{result:w}),w}const i=Date.now();_e.totalChecks+=1,_e.lastCheckTimestamp=i,_e.lastCheckReason=n;const a=nu();if(!a){_e.mismatchCount+=1,_e.lastMismatchDelta=Number.NaN,_e.lastMismatchDetail={reason:"stateManagerUnavailable"};const w={ok:!1,reason:"stateManagerUnavailable"};if(Ho("error","stateManagerUnavailable",{result:w}),r){const M=new Error("Scaling state mismatch detected");throw M.details=_e.lastMismatchDetail,M}return w}const o=Number(a.get("scaling.globalPercent")),s=Number.isFinite(o)?o:0,l=Number.isFinite(Et)?Et:0,c=Math.abs(s-l),u=a.get("scaling.baselines"),d=vt?{...vt}:null,p=O0(d,u),f=Number(a.get("scaling.maxAllowed")),h=Ks(d),g=Number.isFinite(f)?f:h,b=Math.abs(g-h);_e.lastExpectedMaxAllowed=h,_e.lastObservedMaxAllowed=g;const S=c>.01,E=p.length>0,y=b>1;if(S||E||y){_e.mismatchCount+=1,_e.lastMismatchDelta=c,_e.lastMismatchDetail={reason:n||"parity-check",percent:{legacy:l,state:s,delta:c},baselines:p,expectedMaxAllowed:h,stateMaxAllowed:g,maxAllowedDelta:b};const w={ok:!1,percentDelta:c,baselineDiffs:p,expectedMaxAllowed:h,stateMaxAllowed:g,maxAllowedDelta:b},M=_e.lastMismatchDetail&&_e.lastMismatchDetail.reason||n||"parity-check";if(Ho("mismatch",M,{result:w}),r){const I=new Error("Scaling state mismatch detected");throw I.details=_e.lastMismatchDetail,I}return w}_e.lastMismatchDelta=0,_e.lastMismatchDetail=null;const A={ok:!0,percentDelta:c,expectedMaxAllowed:h,stateMaxAllowed:g};return Ho("ok",n||"parity-check",{result:A}),A}function gp(){const e=Number.isFinite(Et)?Et:100,t=hp(vt),n=Ks(t);if(!Nn)return{percent:e,baselines:t,maxAllowed:n,statePercent:null,stateBaselines:null,stateMaxAllowed:null,parity:{status:"state-disabled",percentDelta:0,baselineDiffs:[],maxAllowedDelta:0}};const r=nu();if(!r)return{percent:e,baselines:t,maxAllowed:n,statePercent:null,stateBaselines:null,stateMaxAllowed:null,parity:{status:"state-unavailable",percentDelta:null,baselineDiffs:[],maxAllowedDelta:null}};const i=Number(r.get("scaling.globalPercent")),a=Number.isFinite(i)?i:null,o=r.get("scaling.baselines"),s=hp(o),l=Number(r.get("scaling.maxAllowed")),c=Number.isFinite(l)?l:null,u=O0(t,s),d=a==null?null:Math.abs(a-e),p=c==null?null:Math.abs(c-n);let f="ok";return(a==null||o===void 0||c==null)&&(f="state-partial"),((d??0)>.01||u.length>0||(p??0)>1)&&(f="mismatch"),{percent:e,baselines:t,maxAllowed:n,statePercent:a,stateBaselines:s,stateMaxAllowed:c,parity:{status:f,percentDelta:d??0,baselineDiffs:u,maxAllowedDelta:p??0}}}function _0(e){const t=e&&typeof e=="object"?hp(e.baselines):null;if(vt=t?{...t}:null,!Nn)return;const n=Number.isFinite(e?.statePercent)?e.statePercent:Number.isFinite(e?.percent)?e.percent:Et;xi({percent:n,baselines:t?{...t}:null,maxAllowed:Ks(t)})}function xh(e){if(!(typeof window>"u"||typeof window.dispatchEvent!="function"))try{let t;if(typeof window.CustomEvent=="function")t=new window.CustomEvent(Jl,{detail:{enabled:e}});else if(typeof Event=="function"){t=new Event(Jl);try{Object.defineProperty(t,"detail",{configurable:!0,enumerable:!0,value:{enabled:e}})}catch{t.detail={enabled:e}}}t&&window.dispatchEvent(t)}catch(t){console.warn("[SCALE] Failed to dispatch scaling state event",t)}}function nu(){try{return at()}catch(e){return console.warn("[SCALE] Unable to access state manager:",e),null}}function pM(e){return e?(Jo||(Jo=e.createSelector("scaling.globalPercent",t=>Math.abs((t||0)-100)>1e-6)),Jo):null}function Ks(e){if(!e||typeof e!="object")return Yr;let t=Yr;for(const n of Object.keys(e)){const r=Number(e[n]);if(!Number.isFinite(r)||r<=0)continue;const i=Math.floor(65535/r*100);t=Math.min(t,Number.isFinite(i)?i:Yr)}return t}function bp(e,t,n=1e-6){return Number.isNaN(e)&&Number.isNaN(t)?!0:!Number.isFinite(e)||!Number.isFinite(t)?e===t:Math.abs(e-t)<=n}function fM(e,t){if(e===t)return!0;if(!e||!t)return!e&&!t;const n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(const i of n){if(!(i in t))return!1;const a=Number(e[i]),o=Number(t[i]);if(!bp(a,o,.5))return!1}return!0}function xi(e){if(!Nn)return!1;const t=nu();if(!t)return!1;const n=pM(t);let r=!1;return t.batch(()=>{if(e.percent!==void 0){const i=t.get("scaling.globalPercent");bp(i,e.percent)||(t.set("scaling.globalPercent",e.percent,{skipHistory:!0}),r=!0)}if(e.baselines!==void 0){const i=t.get("scaling.baselines"),a=e.baselines?{...e.baselines}:null;fM(i,a)||(t.set("scaling.baselines",a,{skipHistory:!0}),r=!0)}if(e.maxAllowed!==void 0){const i=t.get("scaling.maxAllowed");bp(i,e.maxAllowed,.001)||(t.set("scaling.maxAllowed",e.maxAllowed,{skipHistory:!0}),r=!0)}if(n){const i=t.get("computed.scaling.isActive"),a=n();i!==a&&(t.set("computed.scaling.isActive",a,{skipHistory:!0}),r=!0)}},{skipHistory:!0}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SCALE STATE] updateScalingState",{partial:e,stateChanged:r,snapshot:{percent:t.get("scaling.globalPercent"),baselines:t.get("scaling.baselines"),maxAllowed:t.get("scaling.maxAllowed")}}),r}function es(e){if(Nn=!!e,typeof window<"u"&&(window.__USE_SCALING_STATE=Nn),T0(Nn?"enable":"disable"),B0(),!Nn){Jo=null,xh(!1),cr({reason:"flag:disable",throwOnMismatch:!1});return}Jo=null;const t=vt?{...vt}:null;xi({percent:Et,baselines:t,maxAllowed:Ks(t)}),cr({reason:"flag:enable",throwOnMismatch:!1}),xh(!0)}function gi(e){if(Math.abs(Et-100)<1e-6){vt=null,Nn&&xi({baselines:null,maxAllowed:Yr});return}vt||(vt={});const t=$r(e);if(!t)return;const n=t.querySelector(".end-input");if(!n)return;const r=q.clampEnd(n.getAttribute("data-base-end")??n.value),i=Math.max(1e-4,Et/100||1),a=q.clampEnd(Math.round(r/i));if(vt[e]=a,Nn){const o={...vt};xi({baselines:o,maxAllowed:Ks(o)})}}function Ys(e,t={}){const r=!!(typeof t=="object"&&t!==null?t:{}).skipHistory;console.log("ðŸ” [SCALE CORE DEBUG] scaleChannelEndsByPercent called:",{percent:e,timestamp:Date.now(),currentScaleAllPercent:Et,scaleBaselineEnds:vt,callStack:new Error().stack.split(`
`).slice(1,3)});try{const i=Number(e);if(console.log("ðŸ” [SCALE CORE DEBUG] Raw percent validation:",{percent:e,rawPercent:i,isFinite:Number.isFinite(i),isPositive:i>0}),!Number.isFinite(i)||i<=0)return console.log("ðŸ” [SCALE CORE DEBUG] Invalid percent - returning error"),{success:!1,message:`Invalid scale '${e}'. Enter a positive percent value.`};const a=Math.min(Yr,Math.max(0,i)),o=lt();if(!o||!Array.isArray(o.channels))return{success:!1,message:"No printer selected."};const s=Tc(o.channels);if(s.length>0)return{success:!1,message:Of(s),details:{lockedChannels:s}};vt||(vt={});const l=Et,c=Math.max(1e-4,l/100||1),u={},d=at(),p=Ft(),f=[];let h=Yr;for(const E of o.channels){const y=$r(E);if(!y)continue;if(Nt(E)){const M=ki(E),I=Number.isFinite(M.percentLimit)?M.percentLimit:100;h=Math.min(h,I),vt&&Object.prototype.hasOwnProperty.call(vt,E)&&delete vt[E];continue}const v=y.querySelector(".end-input");if(!v)continue;const A=q.clampEnd(v.getAttribute("data-base-end")??v.value);if(A<=0)continue;let w;if(vt[E]!=null)w=q.clampEnd(vt[E]),(c>1.000001&&A>=65535&&w>A||c<.999999&&A<=0&&w<A)&&(w=A);else{const M=q.clampEnd(Math.round(A/c)),I=c>1.000001&&A>=65535&&M<A,_=c<.999999&&A<=0&&M>A;w=I||_?A:M,vt[E]=w}if(u[E]=w,w>0){const M=Math.floor(65535/w*100);h=Math.min(h,M)}}const g=Math.min(a,h),b=Math.max(1e-4,g/100),S=[];if(Object.keys(u).forEach(E=>{const y=$r(E);if(!y)return;const v=y.querySelector(".end-input");if(!v)return;const A=u[E];if(A<=0)return;const w=q.clampEnd(v.getAttribute("data-base-end")??v.value),M=q.computePercentFromEnd(w),I=q.clampEnd(Math.round(A*b));if(I!==w){const _=w;v.value=I,v.setAttribute("data-base-end",String(I));const C=q.computePercentFromEnd(I),x=y.querySelector(".percent-input");x&&(x.value=Number(C.toFixed(1)).toString(),x.setAttribute("data-base-percent",String(C)),q.clearValidationStyling(x));const P=tl(E,M,C,{mode:"preserveRelative",historyExtras:{triggeredBy:"globalScale"}});S.push({channelName:E,row:y,newEnd:I,baseEnd:A,rescaled:P}),d.set(`printer.channelValues.${E}.percentage`,C,{skipHistory:!0}),f.push({channelName:E,type:"percentage",oldValue:M,newValue:C}),q.clearValidationStyling(v),d.set(`printer.channelValues.${E}.endValue`,I,{skipHistory:!0}),f.push({channelName:E,type:"endValue",oldValue:_,newValue:I}),Zl(E,{percent:C,endValue:I})}}),S.length===0){if(Et=g,Math.abs(Et-100)<1e-6)vt=null,Nn?(xi({percent:Et,baselines:null,maxAllowed:Yr}),cr({reason:"scaleChannelEndsByPercent:no-change"})):cr({reason:"legacy:no-change",throwOnMismatch:!1});else if(Nn){const y=vt?{...vt}:null;xi({percent:Et,baselines:y,maxAllowed:y?h:Yr}),cr({reason:"scaleChannelEndsByPercent:no-change"})}else cr({reason:"legacy:no-change",throwOnMismatch:!1});m.scaleAllInput&&(m.scaleAllInput.value=Jn(Et));const E=g>l?"already maxed at current ink limits":"already at minimum for active channels";return Bh(),{success:!0,message:`Scale unchanged â€” ${E}.`,details:{scalePercent:Et}}}if(Math.abs(g-100)<1e-6&&(vt=null),Et=g,Nn){const E=vt?{...vt}:null;xi({percent:g,baselines:E,maxAllowed:E?h:Yr}),cr({reason:"scaleChannelEndsByPercent:applied"})}else cr({reason:"legacy:apply",throwOnMismatch:!1});return m.scaleAllInput&&(m.scaleAllInput.value=Jn(Et)),!r&&p&&f.length>0&&p.recordBatchAction(`Scale channels to ${Jn(g)}%`,f),Bh(),{success:!0,message:`Scaled ${S.length} channel${S.length===1?"":"s"} by ${g}%`,details:{scalePercent:g,updates:S.length}}}catch(i){return console.error("Error in scaleChannelEndsByPercent:",i),{success:!1,message:`Error scaling channels: ${i.message}`}}}function N0(e){console.log("ðŸ” [APPLY DEBUG] applyGlobalScale called:",{rawPercent:e,timestamp:Date.now(),callStack:new Error().stack.split(`
`).slice(1,4)});const t=1,n=1e3;if(!m.scaleAllInput){console.log("ðŸ” [APPLY DEBUG] No scaleAllInput element found");return}let r=parseFloat(e);if(console.log("ðŸ” [APPLY DEBUG] Parsed value:",{rawPercent:e,parsed:r}),!Number.isFinite(r)){console.warn("ðŸ” [APPLY DEBUG] Invalid scale value:",e),m.scaleAllInput.value=Jn(Et);return}const i=r;r=Math.max(t,Math.min(n,r)),console.log("ðŸ” [APPLY DEBUG] After clamping:",{beforeClamp:i,afterClamp:r}),console.log(`ðŸ” [APPLY DEBUG] Calling scaleChannelEndsByPercent(${r})`);const a=Ys(r);if(console.log("ðŸ” [APPLY DEBUG] scaleChannelEndsByPercent result:",a),!a.success){m.scaleAllInput.value=Jn(Et),console.error("Scaling failed:",a.message),Z(a.message||"Unable to scale channel ends");return}const o=a.details?.scalePercent??r;Et=o,m.scaleAllInput.value=Jn(Et),a.message&&Z(a.message),ho("Preview updated",2e3),Je(),console.log("ðŸ“Š Calling updatePreview after scaling"),Pn(),console.log("ðŸ“Š Calling updateSessionStatus after scaling"),Li(),console.log(`âœ… Global scale applied: ${Jn(o)}%`)}function F0(){Et=100,vt=null,m.scaleAllInput&&(m.scaleAllInput.value=Jn(Et)),Nn&&(xi({percent:Et,baselines:null,maxAllowed:Yr}),cr({reason:"resetGlobalScale",throwOnMismatch:!1}))}function Ut(){if(Nn){const e=nu();if(e&&typeof e.get=="function"){const t=Number(e.get("scaling.globalPercent"));if(Number.isFinite(t)&&t>0)return t}}return Et}function ic(e={}){const t=typeof e=="object"&&e!==null?e:{},{percent:n,...r}=t,i=Number.isFinite(n)?Number(n):Number(Et),a=Number.isFinite(i)&&i>0?i:100;return Ys(a,{skipHistory:!0,...r})}function G0(e,t,n={}){const r=n&&typeof n=="object"?n:{},{priority:i,...a}=r,o=typeof i=="string"?i:"normal";return tr.scale(e,"compat-window",{priority:o,metadata:{requestedBy:t,bridge:"scaling-utils-window",options:a}})}function mM(e,t){return G0(e,"window.applyGlobalScale",t)}function hM(e,t){return G0(e,"window.scaleChannelEndsByPercent",t)}Xe("scalingUtils",{applyGlobalScale:mM,scaleChannelEndsByPercent:hM,reapplyCurrentGlobalScale:ic,updateScaleBaselineForChannel:gi,resetGlobalScale:F0,getCurrentScale:Ut,legacyApplyGlobalScale:N0,legacyScaleChannelEndsByPercent:Ys,setScalingStateEnabled:es,validateScalingStateSync:cr,getScalingStateAudit:uM,dumpScalingStateAudit:dM,resetScalingStateAudit:T0,getLegacyScalingSnapshot:gp,restoreLegacyScalingState:_0},{exposeOnWindow:typeof window<"u",windowAliases:["applyGlobalScale","scaleChannelEndsByPercent","reapplyCurrentGlobalScale","updateScaleBaselineForChannel","resetGlobalScale","getCurrentScale","legacyApplyGlobalScale","legacyScaleChannelEndsByPercent","setScalingStateEnabled","validateScalingStateSync","getScalingStateAudit","dumpScalingStateAudit","resetScalingStateAudit","getLegacyScalingSnapshot","restoreLegacyScalingState"]});typeof window<"u"&&typeof window.setScalingStateEnabled!="function"&&(window.setScalingStateEnabled=es);function Bh(){const e=typeof window<"u"?window:typeof globalThis<"u"?globalThis:null,t=e&&typeof e.setGlobalBakedState=="function"?e.setGlobalBakedState:null;if(t)try{t.call(e,null,{skipHistory:!0})}catch(n){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SCALE] Failed to clear baked state after scaling:",n)}}const We=typeof window<"u"?window:globalThis,Si=typeof document<"u",od=2;class lm{constructor(t){this.stateManager=t,this.history=[],this.redoStack=[],this.maxHistorySize=20,this.isRestoring=!1,this.isBatchOperation=!1,this._pendingKeyPoints={},this._transactionIdCounter=0,this.activeTransaction=null,this._transactionWarnTimer=null,this.setupStateSubscriptions()}cloneEntry(t){try{return JSON.parse(JSON.stringify(t))}catch(n){return console.warn("HistoryManager.cloneEntry failed:",n),t}}setupStateSubscriptions(){this.stateManager.subscribe(["printer.channelValues","printer.channelStates"],(t,n,r,i)=>{if(this.isRestoring||i?.skipHistory)return;const a=t.split(".");if(a.length>=3){const o=a[2],s=a[3];if(s&&o){let l=s;s==="percentage"?l="percentage":s==="endValue"?l="endValue":s==="enabled"&&(l="enabled"),this.recordChannelAction(o,l,r,n)}}}),this.stateManager.subscribe(["linearization"],(t,n,r,i)=>{this.isRestoring||i?.skipHistory||this.recordLinearizationAction(t,r,n)}),this.stateManager.subscribe(["app.editSelection"],(t,n,r,i={})=>{if(this.isRestoring||i.skipHistory||!t.endsWith("__meta")||!n||typeof n!="object")return;const a=i.previousSelection||{channel:null,ordinal:1},o=this.stateManager.getEditSelection();if(a.channel===o.channel&&a.ordinal===o.ordinal)return;const s=n.description||(o.channel?`Select channel ${o.channel} (point ${o.ordinal})`:"Clear edit selection");this.recordUIAction("editSelection",{...a},{...o},s),this.stateManager.set("app.editSelection.__meta",null,{skipHistory:!0})})}_pushHistoryEntry(t,n={}){if(!(this.isRestoring&&!n.force)){if(this.activeTransaction&&!n.force&&!n.allowDuringTransaction){this.activeTransaction.entries.push(this.cloneEntry(t));return}this.history.push(this.cloneEntry(t)),this.history.length>this.maxHistorySize&&this.history.shift(),n.preserveRedo||(this.redoStack=[]),this.updateButtons()}}_pushRedoEntry(t){this.redoStack.push(this.cloneEntry(t)),this.redoStack.length>this.maxHistorySize&&this.redoStack.shift(),this.updateButtons()}recordKeyPointsChange(t,n,r,i,a){try{this._pendingKeyPoints[t]={oldKeyPoints:Array.isArray(n)?n.map(o=>({input:o.input,output:o.output})):void 0,newKeyPoints:Array.isArray(r)?r.map(o=>({input:o.input,output:o.output})):void 0,oldInterpolation:i,newInterpolation:a}}catch(o){console.warn("recordKeyPointsChange failed:",o)}}recordChannelAction(t,n,r,i,a=null){if(this.isRestoring)return;const o={timestamp:Date.now(),type:n,channelName:t,oldValue:r,newValue:i,description:`${n} ${t}: ${r} â†’ ${i}`};if(a&&typeof a=="object"&&Object.assign(o,a),!((n==="percentage"||n==="endValue")&&Number.isFinite(Number(r))&&Number.isFinite(Number(i))&&Number(r)===Number(i))){if(this._pendingKeyPoints[t]&&(Object.assign(o,this._pendingKeyPoints[t]),delete this._pendingKeyPoints[t]),n==="curve"){const s=Array.isArray(o.newKeyPoints)?o.newKeyPoints.length:void 0,l=o.newInterpolation||o.oldInterpolation||void 0,c=[`curve ${t}`];s!==void 0?c.push(`(${s} key points${l?`, ${l}`:""})`):Array.isArray(i)&&c.push(`(${i.length} pts)`),o.description=c.join(" ")}else{const s=l=>Array.isArray(l)?`${l.length} items`:l&&typeof l=="object"?"updated":String(l);o.description=`${n} ${t}: ${s(r)} â†’ ${s(i)}`}this._pushHistoryEntry({kind:"channel",action:o})}}recordUIAction(t,n,r,i){if(this.isRestoring)return;const a={timestamp:Date.now(),type:"ui",uiType:t,oldValue:n,newValue:r,description:i||`${t}: ${String(n)} â†’ ${String(r)}`};this._pushHistoryEntry({kind:"ui",action:a})}recordBatchAction(t,n){if(this.isRestoring)return;const r={timestamp:Date.now(),type:"batch",description:t,channelActions:n};this._pushHistoryEntry({kind:"batch",action:r})}recordLinearizationAction(t,n,r){if(this.isRestoring)return;const i={timestamp:Date.now(),type:"linearization",path:t,oldValue:n,newValue:r,description:`Linearization: ${t.split(".").pop()}`};this._pushHistoryEntry({kind:"linearization",action:i})}captureState(t="Curve modification"){if(this.isRestoring)return;const n=this.stateManager.getState();typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&(console.log(`[SNAPSHOT DEBUG] Capturing "${t}"`),console.log("[SNAPSHOT DEBUG] printer.channelValues:",n.printer?.channelValues),console.log("[SNAPSHOT DEBUG] printer.channelStates:",n.printer?.channelStates));const r=Ee(),i=r?JSON.parse(JSON.stringify(r)):null;n.curves||(n.curves={}),n.curves.loadedQuadData=i;const a=(()=>{try{if(typeof gp=="function")return gp()}catch(l){console.warn("history-manager: getLegacyScalingSnapshot failed during snapshot capture",l)}try{return{percent:typeof Ut=="function"?Ut():null,baselines:null,maxAllowed:null,statePercent:null,stateBaselines:null,stateMaxAllowed:null,parity:{status:"legacy-only",percentDelta:0,baselineDiffs:[],maxAllowedDelta:0}}}catch(l){return console.warn("history-manager: getCurrentScale fallback failed during snapshot capture",l),{percent:null,baselines:null,maxAllowed:null,statePercent:null,stateBaselines:null,stateMaxAllowed:null,parity:{status:"legacy-only",percentDelta:null,baselineDiffs:[],maxAllowedDelta:null}}}})(),o=a.statePercent!=null||a.stateBaselines&&Object.keys(a.stateBaselines).length>0||a.stateMaxAllowed!=null?{percent:a.statePercent,baselines:a.stateBaselines,maxAllowed:a.stateMaxAllowed}:null,s={version:od,timestamp:Date.now(),action:t,stateSnapshot:n,legacyScaling:{percent:a.percent,baselines:a.baselines,maxAllowed:a.maxAllowed},scalingStateSnapshot:o,scalingParity:a.parity};this._pushHistoryEntry({kind:"snapshot",state:s,action:t})}undo(){if(this.history.length===0)return{success:!1,message:"No actions to undo"};try{this.isRestoring=!0;const t=this.history.pop();let n;if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("ðŸ”„ UNDO: Processing entry:",t),t.kind==="channel")this.undoChannelAction(t.action),n=`Undid: ${t.action.description}`,this._pushRedoEntry({kind:"channel",action:t.action});else if(t.kind==="ui")this.undoUIAction(t.action),n=`Undid: ${t.action.description}`,this._pushRedoEntry({kind:"ui",action:t.action});else if(t.kind==="batch")this.undoBatchAction(t.action),n=`Undid: ${t.action.description}`,this._pushRedoEntry({kind:"batch",action:t.action});else if(t.kind==="linearization")this.undoLinearizationAction(t.action),n=`Undid: ${t.action.description}`,this._pushRedoEntry({kind:"linearization",action:t.action});else if(t.kind==="transaction"){const i=t.action||{},a=i.description||"Transaction",o=Array.isArray(i.entries)?i.entries:[];for(let s=o.length-1;s>=0;s-=1)this.undoTransactionEntry(o[s]);n=`Undid: ${a}`,this._pushRedoEntry({kind:"transaction",action:this.cloneEntry(i)})}else if(t.kind==="snapshot"){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[HistoryManager] Undo snapshot entry:",t.action);let i=t.state,a={kind:"snapshot",state:t.state,action:t.action};if(typeof t.action=="string"&&t.action.startsWith("After:")){const o=t.action.replace("After:","Before:");typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[HistoryManager] Checking for paired snapshot:",o);for(let s=this.history.length-1;s>=0;s--){const l=this.history[s];if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[HistoryManager] Candidate for pairing:",l.kind,l.action),l.kind==="snapshot"&&l.action===o){this.history.splice(s,1),i=l.state,a={kind:"snapshot_pair",before:l,after:t},typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[HistoryManager] Paired snapshot found");break}}}this.restoreSnapshot(i),n=`Undid: ${t.action}`,this._pushRedoEntry(a)}else return{success:!1,message:"Unknown action type"};const r={success:!0,message:n};try{cr({reason:"history:undo",throwOnMismatch:!1})}catch(i){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("HistoryManager undo parity validation failed",i)}return r}catch(t){return console.error("Undo failed:",t),{success:!1,message:`Undo failed: ${t.message}`}}finally{this.isRestoring=!1,this.updateButtons()}}redo(){if(this.redoStack.length===0)return{success:!1,message:"No actions to redo"};try{this.isRestoring=!0;const t=this.redoStack.pop();let n;if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("ðŸ”„ REDO: Processing entry:",t),t.kind==="channel")this.redoChannelAction(t.action),n=`Redid: ${t.action.description}`,this._pushHistoryEntry({kind:"channel",action:t.action},{preserveRedo:!0,force:!0});else if(t.kind==="ui")this.redoUIAction(t.action),n=`Redid: ${t.action.description}`,this._pushHistoryEntry({kind:"ui",action:t.action},{preserveRedo:!0,force:!0});else if(t.kind==="batch")this.redoBatchAction(t.action),n=`Redid: ${t.action.description}`,this._pushHistoryEntry({kind:"batch",action:t.action},{preserveRedo:!0,force:!0});else if(t.kind==="linearization")this.redoLinearizationAction(t.action),n=`Redid: ${t.action.description}`,this._pushHistoryEntry({kind:"linearization",action:t.action},{preserveRedo:!0,force:!0});else if(t.kind==="transaction"){const i=t.action||{},a=i.description||"Transaction",o=Array.isArray(i.entries)?i.entries:[];for(const s of o)this.redoTransactionEntry(s);n=`Redid: ${a}`,this._pushHistoryEntry({kind:"transaction",action:this.cloneEntry(i)},{preserveRedo:!0,force:!0})}else if(t.kind==="snapshot")this.restoreSnapshot(t.state),n=`Redid: ${t.action}`,this._pushHistoryEntry({kind:"snapshot",state:t.state,action:t.action},{preserveRedo:!0,force:!0});else if(t.kind==="snapshot_pair"){const i=t.before,a=t.after;i&&(this.history.push(this.cloneEntry(i)),this.history.length>this.maxHistorySize&&this.history.shift()),a?(this.history.push(this.cloneEntry(a)),this.history.length>this.maxHistorySize&&this.history.shift(),this.restoreSnapshot(a.state),n=`Redid: ${a.action}`):i?(this.restoreSnapshot(i.state),n=`Redid: ${i.action}`):n="Redid snapshot"}else return{success:!1,message:"Unknown action type"};const r={success:!0,message:n};try{cr({reason:"history:redo",throwOnMismatch:!1})}catch(i){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("HistoryManager redo parity validation failed",i)}return r}catch(t){return console.error("Redo failed:",t),{success:!1,message:`Redo failed: ${t.message}`}}finally{this.isRestoring=!1,this.updateButtons()}}undoTransactionEntry(t){if(t)switch(t.kind){case"channel":this.undoChannelAction(t.action);break;case"batch":this.undoBatchAction(t.action);break;case"ui":this.undoUIAction(t.action);break;case"linearization":this.undoLinearizationAction(t.action);break;case"snapshot":this.restoreSnapshot(t.state);break;case"snapshot_pair":t.before&&this.restoreSnapshot(t.before.state);break;default:console.warn("Unknown transaction entry kind during undo:",t.kind)}}redoTransactionEntry(t){if(t)switch(t.kind){case"channel":this.redoChannelAction(t.action);break;case"batch":this.redoBatchAction(t.action);break;case"ui":this.redoUIAction(t.action);break;case"linearization":this.redoLinearizationAction(t.action);break;case"snapshot":this.restoreSnapshot(t.state);break;case"snapshot_pair":t.after&&this.restoreSnapshot(t.after.state);break;default:console.warn("Unknown transaction entry kind during redo:",t.kind)}}undoChannelAction(t){const{channelName:n,type:r,oldValue:i}=t;switch(r){case"enabled":this.stateManager.setChannelEnabled(n,i);break;case"percentage":case"value":this.stateManager.setChannelValue(n,"percentage",i);break;case"endValue":this.stateManager.setChannelValue(n,"endValue",i);break;case"lock":{const a=t&&typeof t.beforeLock=="object"?{...t.beforeLock}:null,o=typeof i=="boolean"?i:a?!!a.locked:!1,s={};a&&(Number.isFinite(a.percentLimit)&&(s.percentLimit=a.percentLimit),Number.isFinite(a.endValue)&&(s.endValue=a.endValue)),Ql(n,o,s);break}case"curve":{typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[HISTORY] undo curve",{channelName:n,hasOldPoints:Array.isArray(t.oldKeyPoints)?t.oldKeyPoints.length:null,hasNewPoints:Array.isArray(t.newKeyPoints)?t.newKeyPoints.length:null});const a=Array.isArray(t.oldKeyPoints)&&t.oldKeyPoints.length>0;if(a)Gi(n,t.oldKeyPoints,t.oldInterpolation||"smooth",{skipHistory:!0,skipMarkEdited:!0,allowWhenEditModeOff:!0});else{this.clearSmartCurve(n);const o=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{}}));o.curves=o.curves||{},o.sources=o.sources||{},Array.isArray(i)?o.curves[n]=i.slice():o.curves[n]&&delete o.curves[n],t.oldSource===void 0||t.oldSource===null?delete o.sources[n]:o.sources[n]=t.oldSource}this.stateManager.batch({[`curves.keyPoints.${n}`]:a?t.oldKeyPoints:null,[`curves.keyPointsMeta.${n}.interpolationType`]:a?t.oldInterpolation||"smooth":null,[`curves.sources.${n}`]:t.oldSource!==void 0?t.oldSource:null},{skipHistory:!0}),this.refreshCurveUI(n,t.selectedOrdinalBefore,t.selectedChannelBefore);break}}}redoChannelAction(t){const{channelName:n,type:r,newValue:i}=t;switch(r){case"enabled":this.stateManager.setChannelEnabled(n,i);break;case"percentage":case"value":this.stateManager.setChannelValue(n,"percentage",i);break;case"endValue":this.stateManager.setChannelValue(n,"endValue",i);break;case"lock":{const a=t&&typeof t.afterLock=="object"?{...t.afterLock}:null,o=typeof i=="boolean"?i:a?!!a.locked:!1,s={};a&&(Number.isFinite(a.percentLimit)&&(s.percentLimit=a.percentLimit),Number.isFinite(a.endValue)&&(s.endValue=a.endValue)),Ql(n,o,s);break}case"curve":{const a=Array.isArray(t.newKeyPoints)&&t.newKeyPoints.length>0;if(a)Gi(n,t.newKeyPoints,t.newInterpolation||"smooth",{skipHistory:!0,skipMarkEdited:!0,allowWhenEditModeOff:!0});else{this.clearSmartCurve(n);const o=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{}}));o.curves=o.curves||{},o.sources=o.sources||{},Array.isArray(i)?o.curves[n]=i.slice():o.curves[n]&&delete o.curves[n],t.newSource===void 0||t.newSource===null?delete o.sources[n]:o.sources[n]=t.newSource}this.stateManager.batch({[`curves.keyPoints.${n}`]:a?t.newKeyPoints:null,[`curves.keyPointsMeta.${n}.interpolationType`]:a?t.newInterpolation||"smooth":null,[`curves.sources.${n}`]:t.newSource!==void 0?t.newSource:null},{skipHistory:!0}),this.refreshCurveUI(n,t.selectedOrdinalAfter,t.selectedChannelAfter);break}}}undoUIAction(t){const{uiType:n,oldValue:r}=t;switch(n){case"editMode":this.stateManager.setEditMode(r);break;case"editSelection":this.updateEditSelection(r?.channel??null,r?.ordinal??1);break;default:this.stateManager.set(`ui.${n}`,r);break}}redoUIAction(t){const{uiType:n,newValue:r}=t;switch(n){case"editMode":this.stateManager.setEditMode(r);break;case"editSelection":this.updateEditSelection(r?.channel??null,r?.ordinal??1);break;default:this.stateManager.set(`ui.${n}`,r);break}}undoBatchAction(t){for(let n=t.channelActions.length-1;n>=0;n--)this.undoChannelAction(t.channelActions[n])}redoBatchAction(t){for(const n of t.channelActions)this.redoChannelAction(n)}undoLinearizationAction(t){this.stateManager.set(t.path,t.oldValue,{skipHistory:!0})}redoLinearizationAction(t){this.stateManager.set(t.path,t.newValue,{skipHistory:!0})}restoreSnapshot(t){const n=this.ensureSnapshotVersion(t);if(n&&n.stateSnapshot){const r=JSON.parse(JSON.stringify(n.stateSnapshot));this.stateManager.state=r,this.restoreDomFromSnapshot(r),m.rows&&Array.from(m.rows.children).filter(i=>i&&i.id!=="noChannelsRow").forEach(i=>{const a=i.getAttribute("data-channel");a&&this.ensureChannelEnabledState(a)}),this.applyLegacyScaling(n.legacyScaling)}else this.restoreLegacySnapshot(n);Je()}restoreLegacySnapshot(t){if(t.loadedQuadData?na(JSON.parse(JSON.stringify(t.loadedQuadData))):na(null),t.channels)for(const[n,r]of Object.entries(t.channels))this.stateManager.batch({[`printer.channelValues.${n}.percentage`]:r.percentage,[`printer.channelValues.${n}.endValue`]:r.endValue,[`printer.channelStates.${n}.enabled`]:r.enabled},{skipHistory:!0});t.globalLinearization&&this.stateManager.batch({"linearization.global.data":t.globalLinearization.data,"linearization.global.applied":t.globalLinearization.applied,"linearization.global.enabled":t.globalLinearization.enabled,"ui.filenames.globalLinearization":t.globalLinearization.filename},{skipHistory:!0}),t.perChannelLinearization&&this.stateManager.set("linearization.perChannel.data",t.perChannelLinearization,{skipHistory:!0}),t.perChannelEnabled&&this.stateManager.set("linearization.perChannel.enabled",t.perChannelEnabled,{skipHistory:!0})}getSnapshotVersion(t){return!t||typeof t!="object"?1:Number.isFinite(t.version)?t.version:1}ensureSnapshotVersion(t){return!t||typeof t!="object"||this.getSnapshotVersion(t)>=od?t:t.stateSnapshot?{...t,version:od,legacyScaling:t.legacyScaling??null}:t}applyLegacyScaling(t){if(!t||typeof t.percent!="number")return;const n=typeof We.applyGlobalScale=="function"?We.applyGlobalScale:We.__quadDebug?.scalingUtils?.applyGlobalScale?We.__quadDebug.scalingUtils.applyGlobalScale:null;if(n)try{_0(t),n(t.percent,{priority:"history-restore",metadata:{trigger:"historyRestore"}})}catch(r){console.warn("history-manager: failed to reapply legacy scaling percent",r)}}restoreDomFromSnapshot(t){const n=t.curves?.loadedQuadData;na(n?JSON.parse(JSON.stringify(n)):null);const r=t.printer?.channelValues||{},i=t.printer?.channelStates||{},a=t.linearization?.perChannel?.data||{},o=t.linearization?.perChannel?.enabled||{},s=t.ui?.filenames?.perChannelLinearization||{};m.rows&&Array.from(m.rows.children).forEach(b=>{if(!b||b.id==="noChannelsRow")return;const S=b.getAttribute("data-channel");if(!S)return;r[S]||(r[S]={}),i[S]||(i[S]={});const E=r[S],y=i[S];let v=Number(E.percentage??0);Number.isFinite(v)||(v=0);const A=E.endValue;let w;if(A!=null){const k=Number(A);w=Number.isFinite(k)?k:q.computeEndFromPercent(v)}else w=q.computeEndFromPercent(v);const M=b.querySelector(".percent-input");M&&(M.value=String(v),M.setAttribute("data-base-percent",String(v)),q.clearValidationStyling(M));const I=b.querySelector(".end-input");I&&(I.value=String(w),I.setAttribute("data-base-end",String(w)),q.clearValidationStyling(I));const _=y.enabled!==void 0?!!y.enabled:w>0||v>0;typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[UNDO DEBUG] Restoring ${S}:`,{percentValue:v,resolvedEndValue:w,enabledFlag:_,fromSnapshot:{enabled:y.enabled,percent:E.percentage,end:E.endValue}}),E.percentage=v,E.endValue=w,y.enabled=_;const C=b._virtualCheckbox;C&&(C.checked=_);const x=b.querySelector(".per-channel-toggle");if(x){const k=!!a[S];x.disabled=!k,x.checked=k&&o[S]!==!1}const P=b.querySelector(".per-channel-btn");if(P){const k=s[S];k?P.setAttribute("data-tooltip",`Loaded: ${k}`):P.setAttribute("data-tooltip","Load LUT.cube, LABdata.txt, or .acv curve files")}if(gi(S),b.refreshDisplayFn&&typeof b.refreshDisplayFn=="function")try{b.refreshDisplayFn()}catch(k){console.warn("restoreDomFromSnapshot refreshDisplayFn failed:",k)}});const l=t.app?.editSelection||{},c=l.channel??null,u=Number.isFinite(l.ordinal)?l.ordinal:1;if(typeof t.app?.editMode=="boolean")try{_s(!!t.app.editMode)}catch(b){console.warn("restoreDomFromSnapshot edit mode flag sync failed:",b)}if(Si&&We.EDIT&&(We.EDIT.selectedChannel=c,We.EDIT.selectedOrdinal=u),m.editChannelSelect)try{const b=m.editChannelSelect;c&&Array.from(b.options).some(S=>S.value===c)?b.value=c:c||(b.value="")}catch(b){console.warn("restoreDomFromSnapshot edit dropdown sync failed:",b)}if(D){const b=t.linearization?.global||{};D.globalData=b.data||null,D.globalApplied=!!b.applied,D.globalBakedMeta=b.baked||null;const S=t.linearization?.perChannel?.data||{},E=t.linearization?.perChannel?.enabled||{};D.perChannelData=JSON.parse(JSON.stringify(S)),D.perChannelEnabled={...E};const y=b.baked||null;try{this.stateManager&&this.stateManager.set("linearization.global.baked",y,{skipHistory:!0})}catch(A){console.warn("HistoryManager: failed to restore baked meta in state manager:",A)}if(Si&&typeof We.__quadSetGlobalBakedState=="function")try{We.__quadSetGlobalBakedState(y,{skipHistory:!0})}catch(A){console.warn("HistoryManager: failed to apply baked UI state during restore:",A)}const v=t.ui?.filenames?.perChannelLinearization||{};nt({perChannelLinearization:JSON.parse(JSON.stringify(S)),perChannelEnabled:{...E},perChannelFilenames:{...v}}),Si&&(We.perChannelLinearization=JSON.parse(JSON.stringify(S)),We.perChannelEnabled={...E},We.perChannelFilenames={...v},typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[RESTORE DEBUG] Synced per-channel maps:",{dataChannels:Object.keys(S),enabledChannels:Object.keys(E).filter(A=>E[A])}))}const d=t.linearization?.global||{},p=t.ui?.filenames?.globalLinearization||"",f=!!d.data,h=!!d.enabled,g=p||d.filename||"";if(m.globalLinearizationToggle&&(m.globalLinearizationToggle.disabled=!f,m.globalLinearizationToggle.checked=f&&h),m.globalLinearizationFilename&&(m.globalLinearizationFilename.textContent=g),m.globalLinearizationDetails)if(f&&Array.isArray(d.data?.samples)){const b=d.data.samples.length;m.globalLinearizationDetails.textContent=b?` - ${b} samples`:""}else m.globalLinearizationDetails.textContent="";m.globalLinearizationInfo&&(f?m.globalLinearizationInfo.classList.remove("hidden"):m.globalLinearizationInfo.classList.add("hidden")),m.globalLinearizationHint&&(f?m.globalLinearizationHint.classList.add("hidden"):m.globalLinearizationHint.classList.remove("hidden"));try{Er(),Pn(),Je(),Si&&typeof We.refreshEditState=="function"&&We.refreshEditState()}catch(b){console.warn("restoreDomFromSnapshot global refresh failed:",b)}}updateButtons(){this.updateUndoButton(),this.updateRedoButton()}updateUndoButton(){const t=m.undoBtn||document.getElementById("undoBtn");if(t){const n=this.history.length>0;if(t.disabled=!n,n&&this.history.length>0){const r=this.history[this.history.length-1],i=r.action?.description||r.action||"Undo last action";t.title=`Undo: ${i}`}else t.title="Nothing to undo"}}updateRedoButton(){const t=m.redoBtn||document.getElementById("redoBtn");if(t){const n=this.redoStack.length>0;if(t.disabled=!n,n&&this.redoStack.length>0){const r=this.redoStack[this.redoStack.length-1],i=r.action?.description||r.action||"Redo last action";t.title=`Redo: ${i}`}else t.title="Nothing to redo"}}refreshCurveUI(t,n,r){if(Si){try{this.updateEditSelection(t,n,r),this.ensureChannelEnabledState(t),r&&r!==t&&this.ensureChannelEnabledState(r),Ur(t)}catch(i){console.warn("refreshCurveUI updateProcessingDetail failed:",i)}try{Pn()}catch(i){console.warn("refreshCurveUI updatePreview failed:",i)}try{Je()}catch(i){console.warn("refreshCurveUI updateInkChart failed:",i)}try{Si&&typeof We.refreshEditState=="function"&&We.refreshEditState()}catch(i){console.warn("refreshCurveUI refreshEditState failed:",i)}}}ensureChannelEnabledState(t){if(!m.rows||!t)return;const n=Array.from(m.rows.children).find(c=>c.getAttribute("data-channel")===t);if(!n)return;const r=n.querySelector(".percent-input"),i=n.querySelector(".end-input"),a=r?q.clampPercent(r.value):0;let o=i?q.clampEnd(i.value):0;if(a>0&&o===0){o=q.computeEndFromPercent(a),i&&(i.value=String(o));try{this.stateManager.setChannelValue(t,"endValue",o)}catch(c){console.warn("Failed to sync fallback end value during undo:",c)}}const s=a>0||o>0;s&&n.removeAttribute("data-user-disabled");const l=n._virtualCheckbox;if(l&&(l.checked=s),n.refreshDisplayFn&&typeof n.refreshDisplayFn=="function")try{n.refreshDisplayFn()}catch(c){console.warn("ensureChannelEnabledState refresh failed:",c)}}updateEditSelection(t,n,r){if(!Si||!We.EDIT||typeof ht!="function"||!ht())return;r&&We.EDIT.selectedChannel!==r&&(We.EDIT.selectedChannel=r),We.EDIT.selectedChannel!==t&&We.EDIT.selectedChannel!==r&&(We.EDIT.selectedChannel=t);const i=We.EDIT.selectedChannel;if(m.editChannelSelect)try{const l=m.editChannelSelect;i&&Array.from(l.options).some(c=>c.value===i)&&(l.value=i)}catch(l){console.warn("updateEditSelection dropdown sync failed:",l)}const a=Te.get(t)?.points||[],o=We.EDIT.selectedOrdinal||1;let s=Number.isFinite(n)?n:o;if(a.length>0?s=Math.max(1,Math.min(s,a.length)):s=1,We.EDIT.selectedOrdinal=s,this.stateManager&&typeof this.stateManager.setEditSelection=="function")try{this.stateManager.setEditSelection(i,s,{skipHistory:!0})}catch(l){console.warn("updateEditSelection state sync failed:",l)}if(typeof We.edit_refreshPointIndex=="function")try{We.edit_refreshPointIndex()}catch(l){console.warn("updateEditSelection edit_refreshPointIndex failed:",l)}if(typeof We.refreshEditState=="function")try{We.refreshEditState()}catch(l){console.warn("updateEditSelection refreshEditState failed:",l)}try{Je()}catch(l){console.warn("updateEditSelection updateInkChart failed:",l)}if(i)try{Ur(i)}catch(l){console.warn("updateEditSelection updateProcessingDetail failed:",l)}}clearSmartCurve(t){const n=Ee();n&&(n.keyPoints&&n.keyPoints[t]&&delete n.keyPoints[t],n.keyPointsMeta&&n.keyPointsMeta[t]&&delete n.keyPointsMeta[t],n.sources&&n.sources[t]&&delete n.sources[t])}clear(){this.history=[],this.redoStack=[],this._pendingKeyPoints={},this._clearActiveTransaction(),this.updateButtons()}_clearActiveTransaction(){this._transactionWarnTimer&&(clearTimeout(this._transactionWarnTimer),this._transactionWarnTimer=null),this.activeTransaction=null}beginTransaction(t="History transaction"){if(this.activeTransaction)throw new Error("History transaction already active");const n=`tx_${Date.now()}_${++this._transactionIdCounter}`;return this.activeTransaction={id:n,description:t,startedAt:Date.now(),snapshot:this.captureSnapshotState(),entries:[]},this._transactionWarnTimer=setTimeout(()=>{console.warn(`History transaction "${t}" (${n}) has not been committed after 5s`)},5e3),n}commit(t){if(!this.activeTransaction)throw new Error("No active history transaction to commit");if(this.activeTransaction.id!==t)throw new Error("Mismatched history transaction id");const n=this.activeTransaction;if(this._clearActiveTransaction(),!Array.isArray(n.entries)||n.entries.length===0)return{success:!0,message:"Transaction committed (no changes)"};const r={timestamp:Date.now(),type:"transaction",description:n.description,entries:n.entries.map(i=>this.cloneEntry(i))};return this._pushHistoryEntry({kind:"transaction",action:r},{force:!0}),{success:!0,message:n.description||"Transaction committed"}}rollback(t){if(!this.activeTransaction)throw new Error("No active history transaction to rollback");if(this.activeTransaction.id!==t)throw new Error("Mismatched history transaction id");const n=this.activeTransaction;if(this._clearActiveTransaction(),n.snapshot)try{this.isRestoring=!0,this.restoreSnapshot(n.snapshot)}finally{this.isRestoring=!1}return{success:!0,message:n.description?`Rolled back: ${n.description}`:"Transaction rolled back"}}captureSnapshotState(){try{const t=this.stateManager.getState(),n=JSON.parse(JSON.stringify(t)),r=Ee();return n.curves||(n.curves={}),n.curves.loadedQuadData=r?JSON.parse(JSON.stringify(r)):null,{stateSnapshot:n}}catch(t){return console.warn("Failed to capture history transaction snapshot:",t),null}}getDebugInfo(){return{historyLength:this.history.length,redoLength:this.redoStack.length,isRestoring:this.isRestoring,pendingKeyPoints:Object.keys(this._pendingKeyPoints),transactionActive:!!this.activeTransaction,transactionDescription:this.activeTransaction?.description||null,recentActions:this.history.slice(-5).map(t=>({kind:t.kind,description:t.action?.description||t.action}))}}}let sd=null;function Ft(){if(!sd){const e=at();sd=new lm(e)}return sd}function yp(e,t,n,r,i=null){return Ft().recordChannelAction(e,t,n,r,i)}function Sp(e,t,n,r){return Ft().recordUIAction(e,t,n,r)}function vp(e,t){return Ft().recordBatchAction(e,t)}function hs(e="Curve modification"){return Ft().captureState(e)}function Ep(e){return Ft().beginTransaction(e)}function wp(e){return Ft().commit(e)}function Cp(e){return Ft().rollback(e)}function Ap(){return Ft().undo()}function Mp(){return Ft().redo()}function Lp(){return Ft().clear()}Si&&(We.HistoryManager=lm,We.getHistoryManager=Ft,We.recordChannelAction=yp,We.recordUIAction=Sp,We.recordBatchAction=vp,We.captureState=hs,We.beginHistoryTransaction=Ep,We.commitHistoryTransaction=wp,We.rollbackHistoryTransaction=Cp,We.undo=Ap,We.redo=Mp,We.clearHistory=Lp,We.CurveHistory={recordChannelAction:yp,recordUIAction:Sp,recordBatchAction:vp,captureState:hs,undo:Ap,redo:Mp,clear:Lp,beginTransaction:Ep,commitTransaction:wp,rollbackTransaction:Cp,updateUndoButton:()=>Ft().updateUndoButton(),updateRedoButton:()=>Ft().updateRedoButton()});function R0(){const e={},t=m.editMaxError||document.getElementById?.("editMaxError");if(t){const r=Number(t.value);Number.isFinite(r)&&r>0&&(e.maxErrorPercent=r)}const n=m.editMaxPoints||document.getElementById?.("editMaxPoints");if(n){const r=Number(n.value);Number.isInteger(r)&&r>=2&&(e.maxPoints=r)}return e}const z0=.5;function gM(e,t,n,r){if(typeof _i=="function"&&!_i())return;const i=Te.get(e);if(!i?.points||i.points.length<2){try{Fi(e,{...R0()})}catch(c){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[BELL SHIFT] Fallback resimplify failed:",c)}return}const a=i.points.map(c=>({...c})),o=(()=>{const c=Number.isFinite(r?.bellShift?.apexSpanPercent)?r.bellShift.apexSpanPercent:Number.isFinite(r?.apexSpanPercent)?r.apexSpanPercent:25;return Math.max(2,c*.4)})(),s=Sn?.minGap||.01;for(let c=1;c<a.length-1;c+=1){const u=a[c],d=Math.abs(u.input-n),p=Math.exp(-d/o);u.input=u.input+t*p}a[0].input=0;const l=a.length-1;a[l].input=100;for(let c=1;c<l;c+=1){const u=a[c-1].input,p=100-(l-c)*s,f=a[c].input,h=Math.min(Math.max(f,u+s),p);a[c].input=h}try{const c=i.interpolation||"smooth";Te.persist(e,a,c),cu(e,{points:a,interpolation:c})}catch(c){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[BELL SHIFT] Failed to persist Smart key points after shift:",c)}}function bM(e,t){if(!e||!t)return null;const n=e.curves;return!n||!Array.isArray(n[t])?null:n[t]}function yM(e,t){const n=Number(t).toFixed(1).replace(/\.0$/,"");return`Shifted ${e} bell apex to ${n}% input`}function U0(e,t,n={}){if(!e)return{success:!1,reason:"invalid_channel"};const r=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{},bellCurveShift:{}})),i=bM(r,e);if(!i)return{success:!1,reason:"no_curve"};if(Nt(e)){const d=Vi(e)||`${e} is locked. Unlock to shift bell apex.`;return n.silent||Z(d),{success:!1,reason:"locked",message:d}}const a=Vr(e);if(!a||a.classification!=="bell"||typeof a.peakIndex!="number")return{success:!1,reason:"not_bell"};const o=Number.isFinite(a.bellShift?.shiftedApexInputPercent)?a.bellShift.shiftedApexInputPercent:a.peakInputPercent,s=Jw(Number(t));if(!Number.isFinite(s))return{success:!1,reason:"invalid_target"};if(Number.isFinite(o)&&Math.abs(s-o)<.001)return{success:!0,noOp:!0,targetInputPercent:s};const l=Number.isFinite(o)?o:a.peakInputPercent,c=s-l,u=Ly(i,a.peakIndex,c,{apexInputPercent:a.peakInputPercent});r.curves[e]=u,yf(r),WE(r,e,s),gM(e,c,l,a);try{cu(e)}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[BELL SHIFT] Failed to regenerate Smart curve samples after shift:",d)}return hs(`Bell apex shift â€¢ ${e}`),Je(),Pn(),Ur(e),n.silent||Z(yM(e,s)),{success:!0,targetInputPercent:s}}function SM(e,t=z0,n={}){const r=Vr(e),i=Number.isFinite(r?.bellShift?.shiftedApexInputPercent)?r.bellShift.shiftedApexInputPercent:r?.peakInputPercent;if(!Number.isFinite(i))return{success:!1,reason:"no_apex"};const a=i+Number(t||0);return U0(e,a,n)}function vM(){return z0}let Th=!1;function $0(){return{container:m.editBellShiftContainer||document.getElementById("editBellShiftContainer"),input:m.editBellShiftInput||document.getElementById("editBellShiftInput"),dec:m.editBellShiftDec||document.getElementById("editBellShiftDec"),inc:m.editBellShiftInc||document.getElementById("editBellShiftInc")}}function V0(){return(m.editChannelSelect||document.getElementById("editChannelSelect"))?.value?.trim()||null}function Oh(e,t){e?.input&&(e.input.value="",e.input.placeholder=t||"â€”",e.input.disabled=!0,e.dec&&(e.dec.disabled=!0),e.inc&&(e.inc.disabled=!0))}function EM(e){e?.input&&(e.input.placeholder="",e.input.disabled=!1,e.dec&&(e.dec.disabled=!1),e.inc&&(e.inc.disabled=!1))}function wM(e,t){if(!e||!t)return;const n=Number(t.value);if(!Number.isFinite(n)){ac(e);return}U0(e,n)}function H0(){if(Th)return;const e=$0();if(!e.container||!e.input)return;const t=()=>V0(),n=()=>{const i=t();wM(i,e.input)};e.input.addEventListener("keydown",i=>{i.key==="Enter"&&(i.preventDefault(),n())}),e.input.addEventListener("blur",n);const r=(i,a)=>{const o=t();if(!o)return;const s=a.shiftKey?4:1,l=vM()*i*s;SM(o,l)};e.dec?.addEventListener("click",i=>{i.preventDefault(),r(-1,i)}),e.inc?.addEventListener("click",i=>{i.preventDefault(),r(1,i)}),Th=!0}function CM(){H0()}function ac(e=null){if(typeof document>"u")return;H0();const t=$0();if(!t.container)return;const n=e||V0();if(!_i()||!n){t.container.classList.add("hidden"),Oh(t,"Enable Edit Mode to shift bell apex");return}const i=Vr(n);if(!i||i.classification!=="bell"||!i.bellShift){t.container.classList.add("hidden"),Oh(t,"Select a bell-classified channel");return}t.container.classList.remove("hidden"),EM(t);const a=Number.isFinite(i.bellShift.shiftedApexInputPercent)?i.bellShift.shiftedApexInputPercent:i.apexInputPercent;Number.isFinite(a)&&t.input&&(t.input.value=a.toFixed(1)),Number.isFinite(a)||(t.input.value="",t.input.placeholder="â€”")}const AM=4,MM=4,_h=.4,Nh=2.5,LM=1e-4;function qo(e){return Number.isFinite(e)?e<_h?_h:e>Nh?Nh:e:1}function Wi(e){return Math.abs(e-1)<LM}function Fh(e,t,n){return Number.isFinite(e)?e:Number.isFinite(t)&&n>1?t/100*(n-1):null}function Gh(e,t,n,r){if(Number.isFinite(r))return Yf(r,e);if(Number.isFinite(n)){const i=Xw(n,e);if(Number.isFinite(i))return i}return t}function cm(e,t,n={},r={},i=null){const a=Cy(e),o=a.length;if(o<8||!Number.isFinite(t))return a.slice();const s=AM,l=o-1-MM,c=Rr(t,s,l),u=qo(Number.isFinite(n.leftFactor)?n.leftFactor:1),d=qo(Number.isFinite(n.rightFactor)?n.rightFactor:1);if(Wi(u)&&Wi(d))return a.slice();const p=Yf(Number.isFinite(r.fallbackFalloff)?r.fallbackFalloff:My(a,c),o),f=Fh(r.leftSpanSamples,r.leftSpanPercent,o),h=Fh(r.rightSpanSamples,r.rightSpanPercent,o),g=Gh(o,p,f,r.falloffLeft),b=Gh(o,p,h,r.falloffRight),S=a.slice(),E=Number.isFinite(i?.leftFactor)?qo(i.leftFactor):1,y=Number.isFinite(i?.rightFactor)?qo(i.rightFactor):1;for(let v=1;v<o-1;v+=1){if(v===c){S[v]=a[v];continue}const A=v-c,w=A<0,M=w?u:d,I=w?E:y;if(Wi(M)&&Wi(I)){S[v]=a[v];continue}const _=w?g:b,C=Math.exp(-(A*A)/(2*_*_)),x=1+(I-1)*C,P=1+(M-1)*C;if(Wi(x)&&Wi(P)){S[v]=a[v];continue}if(Wi(x/P)){S[v]=a[v];continue}const k=x/P,N=A*k,F=Rr(c+N,0,o-1);S[v]=Math.round(Ay(a,F))}return S[0]=a[0],S[o-1]=a[o-1],S}function dr(e){return qo(e)}const Ip=100,IM=dr(.4)*100,kM=dr(2.5)*100,DM=2,q0=.001;function ld(e){if(!Number.isFinite(e))return Ip;const t=Math.min(Math.max(e,IM),kM);return dr(t/100)*100}function PM(e,t){if(!e||!t)return null;const n=e.curves;return!n||!Array.isArray(n[t])?null:n[t]}function j0(e){return e?.bellWidthScale?{leftFactor:dr(e.bellWidthScale.leftFactor??1),rightFactor:dr(e.bellWidthScale.rightFactor??1),linked:typeof e.bellWidthScale.linked=="boolean"?e.bellWidthScale.linked:!0}:{leftFactor:1,rightFactor:1,linked:!0}}function hl(e){return dr(e??1)*100}function Rh(e,t,n){return Number.isFinite(e)?dr(e/100):Number.isFinite(t)?dr(t):Number.isFinite(n)?dr(n):1}function Ga(e,t){return Math.abs(e-t)<q0}function xM(e,t,n){const r=Math.round(t*100),i=Math.round(n*100);return Math.abs(r-i)<=1?`Scaled ${e} bell width to ${r}%`:`Scaled ${e} bell width (L ${r}%, R ${i}%)`}function BM(e,t,n,r,i){if(!_i())return;const a=Te.get(e);if(!a?.points||a.points.length<2){try{Fi(e,{...R0()})}catch(E){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[BELL WIDTH] Failed to resimplify Smart points:",E)}return}const o=a.points.map(E=>({...E})),s=dr(n?.leftFactor??1),l=dr(n?.rightFactor??1),c=dr(t?.leftFactor??1),u=dr(t?.rightFactor??1);if(Ga(s,c)&&Ga(l,u))return;const d=Sn?.minGap||.01,p=Number.isFinite(i?.apexSpanPercent)?i.apexSpanPercent:25,f=Number.isFinite(i?.apexSpanLeftPercent)?i.apexSpanLeftPercent:p,h=Number.isFinite(i?.apexSpanRightPercent)?i.apexSpanRightPercent:p,g=Math.max(2,f*.5),b=Math.max(2,h*.5);for(let E=1;E<o.length-1;E+=1){const y=o[E],v=y.input-r;if(Math.abs(v)<.001)continue;const A=v<0,w=A?s:l,M=A?c:u;if(Ga(w,M))continue;const I=A?g:b,_=Math.exp(-Math.abs(v)/Math.max(1,I)),C=1+(w-1)*_,x=1+(M-1)*_;if(Ga(C,x))continue;const P=Math.abs(C)>q0?v/C:v;y.input=r+P*x}o[0].input=0;const S=o.length-1;o[S].input=100;for(let E=1;E<S;E+=1){const y=o[E-1].input,A=100-(S-E)*d,w=o[E].input;o[E].input=Math.min(Math.max(w,y+d),A)}try{const E=a.interpolation||"smooth";Te.persist(e,o,E),cu(e,{points:o,interpolation:E})}catch(E){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[BELL WIDTH] Failed to persist Smart key points:",E)}}function TM(e){return{leftSpanSamples:e?.apexSpanLeftSamples,rightSpanSamples:e?.apexSpanRightSamples,leftSpanPercent:e?.apexSpanLeftPercent,rightSpanPercent:e?.apexSpanRightPercent,fallbackFalloff:e?.apexSpanSamples}}function ia(e,t={},n={}){if(!e)return{success:!1,reason:"invalid_channel"};const r=$t(()=>({curves:{},sources:{},bellCurveShift:{}})),i=PM(r,e);if(!i)return{success:!1,reason:"no_curve"};if(Nt(e)){const h=Vi(e)||`${e} is locked. Unlock to adjust bell width.`;return n.silent||Z(h),{success:!1,reason:"locked",message:h}}const a=Vr(e);if(!a||a.classification!=="bell"||!Number.isFinite(a.peakIndex))return{success:!1,reason:"not_bell"};const o=j0(a),s={...o},l=typeof t.linked=="boolean"?t.linked:o.linked;let c=Rh(t.leftPercent,t.leftFactor,o.leftFactor),u=Rh(t.rightPercent,t.rightFactor,o.rightFactor);if(l){const h=Number.isFinite(t.leftPercent)||Number.isFinite(t.leftFactor)?c:Number.isFinite(t.rightPercent)||Number.isFinite(t.rightFactor)?u:o.leftFactor;c=h,u=h}if(Ga(c,o.leftFactor)&&Ga(u,o.rightFactor))return typeof t.linked=="boolean"&&t.linked!==o.linked&&Vd(r,e,{linked:l}),{success:!0,noOp:!0};let d=qm(r,e);(!Array.isArray(d)||d.length!==i.length)&&(qE(r,e,i),d=qm(r,e)||i);const p=cm(d,a.peakIndex,{leftFactor:c,rightFactor:u},TM(a),s);r.curves[e]=p,r.rebasedCurves&&typeof r.rebasedCurves=="object"&&(r.rebasedCurves[e]=p.slice()),r.plotBaseCurves&&typeof r.plotBaseCurves=="object"&&(r.plotBaseCurves[e]=p.slice()),Vd(r,e,{leftFactor:c,rightFactor:u,linked:l});const f=Number.isFinite(a?.bellShift?.shiftedApexInputPercent)?a.bellShift.shiftedApexInputPercent:a?.apexInputPercent??50;BM(e,{leftFactor:c,rightFactor:u},s,f,a);try{cu(e)}catch(h){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[BELL WIDTH] Failed to regenerate Smart curve samples:",h)}return hs(`Bell width scale â€¢ ${e}`),Je(),Pn(),Ur(e),n.silent||Z(xM(e,c,u)),{success:!0,leftFactor:c,rightFactor:u,linked:l}}function OM(e,t="both",n=DM,r={}){const i=Vr(e);if(!i||i.classification!=="bell")return{success:!1,reason:"not_bell"};const a=j0(i),o=typeof r.linked=="boolean"?r.linked:a.linked,s=hl(a.leftFactor),l=hl(a.rightFactor),c=ld(s+(t==="right"?0:n)),u=ld(l+(t==="left"?0:n));if(o||t==="both"){const d=ld(s+n);return ia(e,{leftPercent:d,rightPercent:d,linked:o},r)}return t==="left"?ia(e,{leftPercent:c,rightPercent:l,linked:o},r):t==="right"?ia(e,{rightPercent:u,leftPercent:s,linked:o},r):ia(e,{leftPercent:hl(a.leftFactor),rightPercent:hl(a.rightFactor),linked:o},r)}function _M(e,t={}){return ia(e,{leftPercent:Ip,rightPercent:Ip},t)}function NM(e,t){if(typeof t!="boolean")return{success:!1,reason:"invalid_link_flag"};const n=$t(()=>({curves:{},sources:{},bellCurveShift:{}})),r=Vr(e);return!r||r.classification!=="bell"?{success:!1,reason:"not_bell"}:(Vd(n,e,{linked:t}),Ur(e),{success:!0,linked:t})}const oc=100,FM=2,GM=40,RM=250,zM=180;let zh=!1,go=!1;const kp=new Map,ts={left:null,right:null};function W0(){return{container:m.editBellWidthContainer||document.getElementById("editBellWidthContainer"),leftInput:m.bellWidthLeftInput||document.getElementById("bellWidthLeftInput"),rightInput:m.bellWidthRightInput||document.getElementById("bellWidthRightInput"),leftDec:m.bellWidthLeftDec||document.getElementById("bellWidthLeftDec"),leftInc:m.bellWidthLeftInc||document.getElementById("bellWidthLeftInc"),rightDec:m.bellWidthRightDec||document.getElementById("bellWidthRightDec"),rightInc:m.bellWidthRightInc||document.getElementById("bellWidthRightInc"),linkToggle:m.bellWidthLinkToggle||document.getElementById("bellWidthLinkToggle"),resetBtn:m.bellWidthResetBtn||document.getElementById("bellWidthResetBtn"),channelSelect:m.editChannelSelect||document.getElementById("editChannelSelect")}}function Xs(e){return e.channelSelect?.value?.trim()||null}function um(e){return e.linkToggle?.getAttribute("aria-pressed")!=="false"}function Uh(e){return Number.isFinite(e)?Math.min(RM,Math.max(GM,e)):oc}function $h(e){return Number.isFinite(e)?Math.abs(e-Math.round(e))<.01?String(Math.round(e)):e.toFixed(1):String(oc)}function Vh(e){if(!e)return null;const t=Number(e.value);return Number.isFinite(t)?t:null}function UM(e){go=!0;try{e()}finally{go=!1}}function K0(e,t){if(!e.linkToggle)return;e.linkToggle.setAttribute("aria-pressed",t?"true":"false"),e.linkToggle.classList.toggle("bg-slate-600",t),e.linkToggle.classList.toggle("hover:bg-slate-500",t),e.linkToggle.classList.toggle("text-white",t),e.linkToggle.classList.toggle("border-slate-600",t),e.linkToggle.classList.toggle("bg-white",!t),e.linkToggle.classList.toggle("hover:bg-gray-50",!t),e.linkToggle.classList.toggle("text-gray-600",!t),e.linkToggle.classList.toggle("border-gray-300",!t);const n=e.linkToggle.querySelector('span[aria-hidden="true"]'),r=e.linkToggle.querySelector("span:not([aria-hidden])");n&&(n.textContent=t?"â›“":"â›“ï¸Ž"),r&&(r.textContent=t?"Linked":"Un-linked")}function Hh(e,t){e.container&&(gs("left"),gs("right"),e.container.classList.add("hidden"),e.leftInput&&(e.leftInput.value="",e.leftInput.placeholder=t||"â€”",e.leftInput.disabled=!0),e.rightInput&&(e.rightInput.value="",e.rightInput.placeholder=t||"â€”",e.rightInput.disabled=!0),[e.leftDec,e.leftInc,e.rightDec,e.rightInc,e.linkToggle,e.resetBtn].forEach(n=>{n&&(n.disabled=!0)}))}function $M(e){e.container&&(e.container.classList.remove("hidden"),[e.leftInput,e.rightInput,e.leftDec,e.leftInc,e.rightDec,e.rightInc,e.linkToggle,e.resetBtn].forEach(t=>{t&&(t.disabled=!1)}))}function qh(e,t){[e.leftDec,e.leftInc,e.rightDec,e.rightInc].forEach(n=>{n&&(n.disabled=t)}),t?e.container?.classList.add("opacity-90"):e.container?.classList.remove("opacity-90")}function dm(e,t,n){qh(t,!0);try{n()}finally{requestAnimationFrame(()=>{qh(t,!1),X0(e)})}}function Y0(e,t,n){UM(()=>{e.leftInput&&(e.leftInput.value=$h(t),e.leftInput.placeholder=""),e.rightInput&&(e.rightInput.value=$h(n),e.rightInput.placeholder="")})}function gs(e){ts[e]&&(clearTimeout(ts[e]),ts[e]=null)}function jh(e,t){go||(gs(e),ts[e]=setTimeout(()=>{ts[e]=null,Dp(t,e)},zM))}function Dp(e,t){if(go)return;const n=Xs(e);if(!n)return;const r=Vh(e.leftInput),i=Vh(e.rightInput),a=Uh(r??oc),o=Uh(i??oc);Y0(e,a,o);const s=um(e);dm(n,e,()=>{if(s){const l=t==="right"?o:a;ia(n,{leftPercent:l,rightPercent:l,linked:s})}else ia(n,{leftPercent:a,rightPercent:o,linked:s})})}function gl(e,t,n,r){const i=Xs(r);if(!i)return;const a=(n?.shiftKey?5:FM)*t,o=um(r);dm(i,r,()=>{OM(i,o?"both":e,a,{linked:o})})}function VM(e){const t=Xs(e);t&&dm(t,e,()=>{_M(t)})}function HM(e,t){kp.set(e,{linked:t,timestamp:Date.now()})}function qM(e,t){const n=kp.get(e);return n?t===n.linked||Date.now()-n.timestamp>1500?(kp.delete(e),t):n.linked:t}function X0(e=null){const t=W0();if(!t.container)return;const n=e||Xs(t);if(!_i()||!n){Hh(t,"Enable Edit Mode to adjust width");return}const i=Vr(n);if(!i||i.classification!=="bell"){Hh(t,"Select a bell-classified channel");return}$M(t);const a=Number.isFinite(i?.bellWidthScale?.leftFactor)?i.bellWidthScale.leftFactor:1,o=Number.isFinite(i?.bellWidthScale?.rightFactor)?i.bellWidthScale.rightFactor:1,s=typeof i?.bellWidthScale?.linked=="boolean"?i.bellWidthScale.linked:!0,l=qM(n,s);Y0(t,a*100,o*100),K0(t,l)}function jM(){if(zh)return;const e=W0();if(!e.container)return;const t=()=>{gs("left"),Dp(e,"left")},n=()=>{gs("right"),Dp(e,"right")};e.leftInput?.addEventListener("keydown",r=>{r.key==="Enter"&&(r.preventDefault(),t())}),e.leftInput?.addEventListener("blur",t),e.leftInput?.addEventListener("input",r=>{go||r.target?.value!==""&&jh("left",e)}),e.rightInput?.addEventListener("keydown",r=>{r.key==="Enter"&&(r.preventDefault(),n())}),e.rightInput?.addEventListener("blur",n),e.rightInput?.addEventListener("input",r=>{go||r.target?.value!==""&&jh("right",e)}),e.leftDec?.addEventListener("click",r=>{r.preventDefault(),gl("left",-1,r,e)}),e.leftInc?.addEventListener("click",r=>{r.preventDefault(),gl("left",1,r,e)}),e.rightDec?.addEventListener("click",r=>{r.preventDefault(),gl("right",-1,r,e)}),e.rightInc?.addEventListener("click",r=>{r.preventDefault(),gl("right",1,r,e)}),e.resetBtn?.addEventListener("click",r=>{r.preventDefault(),VM(e)}),e.linkToggle?.addEventListener("click",r=>{r.preventDefault();const i=Xs(e);if(!i)return;const a=!um(e);K0(e,a),HM(i,a),NM(i,a)}),zh=!0}function WM(){jM()}const xe=typeof globalThis<"u"?globalThis:{},ha=typeof document<"u",Mt={selectedChannel:null,selectedOrdinal:1};let ns=ha&&xe.__EDIT_MODE_PRIMED===!0,bl=null;function ru(){if(!bl)try{bl=at()}catch{bl=null}return bl}const qe={active:!1,channel:null,ordinal:0,originalPoints:null,originalInterpolation:"smooth",selectionBefore:null,originalCurve:null,originalSource:null,transactionId:null,historyDescription:null,originalInkLimits:null};function Pp(e){return Array.isArray(e)?e.map(t=>({input:Number(t.input),output:Number(t.output)})):null}const Xt=256,pm=.5;function yn(e,t=null){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&(t?console.warn(`[EDIT MODE] ${e}`,t):console.warn(`[EDIT MODE] ${e}`))}function iu(e){const t=typeof Ee=="function"?Ee():null;if(!t)return null;const n=[t.originalCurves?.[e],t.plotBaseCurves?.[e],t.rebasedCurves?.[e],t.curves?.[e]];for(let r=0;r<n.length;r+=1){const i=n[r];if((Array.isArray(i)||typeof ArrayBuffer<"u"&&ArrayBuffer.isView&&ArrayBuffer.isView(i))&&i&&i.length===Xt)return Array.from(i)}return null}function fm(e,t,n=pm){if(!Array.isArray(t)||t.length!==Xt)return!1;if(!Array.isArray(e)||e.length!==Xt)return!0;const r=t.reduce((a,o)=>Number.isFinite(o)&&o>a?o:a,0),i=Math.max(10,Math.round(r*n/100));for(let a=0;a<t.length;a+=1){const o=Number(e[a])||0,s=Number(t[a])||0,l=Math.abs(o-s);if(l>i||s===0&&o>0||s>0&&s<=i&&l>Math.max(5,s*2))return!0}return!1}function Q0(e,t=pm){if(!Array.isArray(e)||e.length!==Xt)return!0;const n=e.length-1;if(n<=0)return!0;const r=Number(e[0])||0,i=Number(e[n])||0,a=e.reduce((s,l)=>Number.isFinite(l)&&l>s?l:s,Math.max(r,i)),o=Math.max(10,Math.round(Math.max(1,a)*t/100));for(let s=1;s<n;s+=1){const l=r+(i-r)*(s/n);if(Math.abs((Number(e[s])||0)-l)>o)return!1}return!0}function Z0(e,t,n,r="default"){yn(`resolveSeedingSamples called for ${e}`,{endValue:t,contextLabel:r});let i=Ya(e,t,n);const a=iu(e),o=Array.isArray(a)&&a.length===Xt,s=typeof Ee=="function"?Ee():null,l=typeof r=="string"&&r.startsWith("ensure");return typeof xe<"u"&&(xe.__EDIT_LAST_SAMPLES={channel:e,context:r,hasFallback:o,usedFallback:!1,preview:o?a.slice(0,6):[]},xe.__EDIT_LAST_SAMPLES_LOG=xe.__EDIT_LAST_SAMPLES_LOG||{},xe.__EDIT_LAST_SAMPLES_LOG[e]={channel:e,context:r,hasFallback:o,preview:o?a.slice(0,6):[]}),l&&o?(yn(`Ensure-seed using fallback samples for ${e}`,{context:r}),s&&(s.curves=s.curves||{},s.curves[e]=a.slice(),s.sources&&s.sources[e]==="smart"&&(s.sources[e]="quad")),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES&&(xe.__EDIT_LAST_SAMPLES.usedFallback=!0),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES_LOG&&xe.__EDIT_LAST_SAMPLES_LOG[e]&&(xe.__EDIT_LAST_SAMPLES_LOG[e].usedFallback=!0),a.slice()):!Array.isArray(i)||i.length!==Xt?o?(yn(`Using fallback samples for ${e}`,{context:r,reason:"primary_missing"}),s&&(s.curves=s.curves||{},s.curves[e]=a.slice(),s.sources&&s.sources[e]==="smart"&&(s.sources[e]="quad")),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES&&(xe.__EDIT_LAST_SAMPLES.usedFallback=!0,xe.__EDIT_LAST_SAMPLES_LOG&&xe.__EDIT_LAST_SAMPLES_LOG[e]&&(xe.__EDIT_LAST_SAMPLES_LOG[e].usedFallback=!0)),bo(e,a,`${r}:fallback-primary-missing`),a):null:o&&fm(i,a)?(yn(`Fallback samples preferred for ${e}`,{context:r,reason:"mismatch"}),s&&(s.curves=s.curves||{},s.curves[e]=a.slice(),s.sources&&s.sources[e]==="smart"&&(s.sources[e]="quad")),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES&&(xe.__EDIT_LAST_SAMPLES.usedFallback=!0,xe.__EDIT_LAST_SAMPLES_LOG&&xe.__EDIT_LAST_SAMPLES_LOG[e]&&(xe.__EDIT_LAST_SAMPLES_LOG[e].usedFallback=!0)),bo(e,a,`${r}:fallback-mismatch`),a):i}function bo(e,t,n="default"){if(yn("seedChannelFromSamples invoked",{channelName:e,context:n,sampleCount:Array.isArray(t)?t.length:0}),!Array.isArray(t)||t.length!==Xt)return!1;const r=typeof n=="string"&&n.startsWith("ensure"),i=iu(e);r&&Array.isArray(i)&&i.length===Xt&&(t=i.slice(),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES&&(xe.__EDIT_LAST_SAMPLES.usedFallback=!0),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES_LOG&&xe.__EDIT_LAST_SAMPLES_LOG[e]&&(xe.__EDIT_LAST_SAMPLES_LOG[e].usedFallback=!0));const a=Array.isArray(i)&&i.length===Xt,o=a?i:t;!r&&Array.isArray(i)&&i.length===Xt&&fm(t,i)&&(yn(`Seed samples overridden by fallback for ${e}`,{context:n}),t=i.slice(),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES&&(xe.__EDIT_LAST_SAMPLES.usedFallback=!0),typeof xe<"u"&&xe.__EDIT_LAST_SAMPLES_LOG&&xe.__EDIT_LAST_SAMPLES_LOG[e]&&(xe.__EDIT_LAST_SAMPLES_LOG[e].usedFallback=!0));const s=t.reduce((I,_)=>Number.isFinite(_)&&_>I?_:I,0),l=m.rows?Array.from(m.rows.children).find(I=>I.getAttribute("data-channel")===e):null,c=l?.querySelector(".percent-input"),u=l?.querySelector(".end-input"),d=Number.parseInt(u?.value||"0",10),p=Math.max(1,Number.isFinite(d)&&d>0?d:s),f=Q0(t);let h=t,g=cd(e,h,{scaleMax:p});if((!g||!Array.isArray(g.points)||g.points.length<2)&&a){const I=cd(e,i,{scaleMax:p});I&&Array.isArray(I.points)&&I.points.length>(g?.points?.length||0)&&(g=I,h=i)}if(!g||!Array.isArray(g.points)||g.points.length<2)return console.warn("[EDIT MODE] seedChannelFromSamples failed",{channelName:e,context:n,samplePreview:h.slice(0,8),pointCount:g?.points?.length||0,scaleMax:p}),!1;if(g.points.length<=2&&!f)return yn(`Rejected 2-point Smart seed for ${e}`,{context:n,reason:"non_linear_source",peak:s,scaleMax:p}),!1;let b=Number.parseFloat(c?.value||"0");(!Number.isFinite(b)||b<=0)&&(b=q.computePercentFromEnd(Number.isFinite(d)&&d>0?d:ve));const S=a?i:h,E=S.length-1,y=Number.isFinite(ve)&&ve>0?ve:65535,v=I=>I.map(_=>{const C=Math.max(0,Math.min(100,Number(_.output))),x=Number(_.input);let P=null;if(E>=0){const k=Math.max(0,Math.min(E,Math.round(x/100*E))),N=Number(S[k]);Number.isFinite(N)&&y>0&&(P=N/y*100)}return Number.isFinite(P)||(P=Number.isFinite(b)&&b>0?C/100*b:C),{input:x,output:Math.max(0,Math.min(100,P))}}),A=v(g.points);ga(e,A,"smooth",{channelPercentOverride:b,pointsAreRelative:!1,smartTouched:!1,skipUiRefresh:!1,includeBakedFlags:!1});let w=A;const M=xp(e,o,.05);if(!M.ok){yn(`Smart seed mismatch detected for ${e}`,{context:n,...M});const I=cd(e,h,{scaleMax:p,maxErrorPercent:Math.max(.02,vn.maxErrorPercent*.5),maxPoints:vn.maxPoints});if(I&&Array.isArray(I.points)&&I.points.length>=2){const _=v(I.points);ga(e,_,"smooth",{channelPercentOverride:b,pointsAreRelative:!1,smartTouched:!1,skipUiRefresh:!1,includeBakedFlags:!1});const C=xp(e,o,.05);C.ok?w=_:yn(`Tightened reseed still mismatched for ${e}`,C)}}return yn(`Seeded ${w.length} Smart key points for ${e}`,{context:n}),typeof xe<"u"&&(xe.__EDIT_LAST_SEED={channelName:e,context:n,pointCount:w.length,linearSource:f,peak:g?.peak??s,scaleMax:p,preview:h.slice(0,8)},xe.__EDIT_SEED_AUDIT=xe.__EDIT_SEED_AUDIT||{},xe.__EDIT_SEED_AUDIT[e]={context:n,absolutePreview:A.slice(0,6),samplePreview:h.slice(0,6)}),!0}function J0(e,t="stored"){const n=iu(e);return!Array.isArray(n)||n.length!==Xt?(console.warn("[EDIT MODE] seedSmartPointsFromStoredCurve missing samples",{channelName:e,contextLabel:t}),!1):bo(e,n,t)}function eS(e,t=ve){if(!Array.isArray(e)||e.length!==Xt)return nl();const n=e.length-1,r=s=>{const l=t>0?s/t*100:0;return Math.max(0,Math.min(100,l))},i=[];let a=e[0];i.push({input:0,output:r(a)});for(let s=1;s<n;s+=1){const l=e[s];if(l!==a){const c=s/n*100,u=r(l);i.some(d=>Math.abs(d.input-c)<=.05)||i.push({input:c,output:u}),a=l}}const o=e[n];return i.push({input:100,output:r(o)}),Te.normalize(i)}function KM(e,t,n,r={}){if(!Array.isArray(t)||t.length!==Xt||!Array.isArray(n)||n.length>=3)return n;const{scaleMax:i=ve,peak:a=0}=r||{},o=t.length-1;if(o<2)return n;const s=Number(t[0])||0,l=Number(t[o])||0;if(!Number.isFinite(l)||l<=s)return n;let c=-1;for(let E=1;E<o;E+=1)if((Number(t[E])||0)>s){c=E;break}if(c<=0||c>=o)return n;const u=c/o;if(!Number.isFinite(u)||u<.05)return n;const d=Math.max(1,Number(i)||ve),p=E=>Math.max(0,Math.min(100,(Number(E)||0)/d*100)),f=c/o*100,h=p(t[c]),g=[],b=(E,y)=>{if(!Number.isFinite(E)||!Number.isFinite(y))return;n.some(A=>Math.abs(A.input-E)<=.05&&Math.abs(A.output-y)<=.1)||g.some(A=>Math.abs(A.input-E)<=.05&&Math.abs(A.output-y)<=.1)||g.push({input:E,output:y})};if(b(f,h),u>.25){const E=Math.min(o-1,Math.round((c+o)/2));if(E>c){const y=E/o*100,v=p(t[E]);b(y,v)}}if(g.length===0)return n;const S=Te.normalize([...n,...g]);return S.length>=3&&yn(`Plateau anchors injected for ${e}`,{plateauFraction:Number(u.toFixed(3)),added:S.length-n.length,peak:a}),S}function cd(e,t,n={}){if(!Array.isArray(t)||t.length!==Xt)return null;const r=t.reduce((l,c)=>Number.isFinite(c)&&c>l?c:l,0);if(r<=0)return{points:nl(),samples:t.slice(),peak:r};const i=Math.max(1,Number(n.scaleMax)||ve),a={maxErrorPercent:n.maxErrorPercent??vn.maxErrorPercent,maxPoints:n.maxPoints??vn.maxPoints,scaleMax:i};let o=Ar(t,a);const s=Q0(t);if((!Array.isArray(o)||o.length<=2)&&!s){const l=Ar(t,{maxErrorPercent:Math.max(.02,a.maxErrorPercent*.25),maxPoints:Math.max(16,a.maxPoints+10),scaleMax:i});Array.isArray(l)&&l.length>o.length&&(o=l)}return(!Array.isArray(o)||o.length<=2)&&!s&&(yn(`Adaptive extraction fallback for ${e}`,{pointCount:o?.length||0,peak:r,scaleMax:i}),o=eS(t,i)),Array.isArray(o)&&o.length<=2&&!s&&(o=KM(e,t,o,{scaleMax:i,peak:r})),{points:Te.normalize(o),samples:t.slice(),peak:r}}function xp(e,t,n=pm){if(!Array.isArray(t)||t.length!==Xt)return{ok:!0,maxDelta:0,tolerance:0,worstIndex:0};const i=(typeof Ee=="function"?Ee():null)?.curves?.[e];if(!Array.isArray(i)||i.length!==t.length)return{ok:!0,maxDelta:0,tolerance:0,worstIndex:0};const a=t.reduce((u,d)=>Number.isFinite(d)&&d>u?d:u,0),o=Math.max(10,Math.round(a*n/100));let s=0,l=0;for(let u=0;u<t.length;u+=1){const d=Math.abs(t[u]-i[u]);d>s&&(s=d,l=u)}const c=s<=o;return c||yn(`Smart curve mismatch for ${e}`,{maxDelta:s,tolerance:o,worstIndex:l}),{ok:c,maxDelta:s,tolerance:o,worstIndex:l}}function tS(e){if(!Number.isFinite(e))return"0";const t=Math.round(e);return Math.abs(e-t)<.05?String(t):Number(e.toFixed(1)).toString()}function YM(e,t){if(!e||!t)return;const n=$r(e);if(!n)return;const r=n.querySelector(".percent-input"),i=n.querySelector(".end-input"),a=Number.isFinite(t.percent)?t.percent:0,o=Number.isFinite(t.end)?t.end:0;if(r&&(r.value=tS(a),r.setAttribute("data-base-percent",String(a))),i){const s=Math.round(o);i.value=String(s),i.setAttribute("data-base-end",String(s))}try{const s=ru();s&&(s.setChannelValue(e,"percentage",a,{skipHistory:!0,allowDuringRestore:!0}),s.setChannelValue(e,"endValue",Math.round(o),{skipHistory:!0,allowDuringRestore:!0}))}catch(s){console.warn("[EDIT MODE] Failed to restore ink baseline in state manager:",s)}try{const s=$t?.(()=>({curves:{},baselineEnd:{},sources:{},keyPoints:{},keyPointsMeta:{},rebasedCurves:{},rebasedSources:{}}));s&&(s.baselineEnd||(s.baselineEnd={}),s.baselineEnd[e]=Math.round(o))}catch(s){console.warn("[EDIT MODE] Failed to restore baselineEnd data:",s)}}function bs(){return qe.active}function nS(e,t){if(!ht())return{success:!1,message:"Edit mode is off"};if(!e||!Number.isFinite(t)||t<1)return{success:!1,message:"Invalid drag target"};if(Nt(e))return Z(`${e} ink limit is locked. Unlock before adjusting points.`),{success:!1,message:"Channel is locked"};So(e);const n=Te.get(e),r=n?.points;if(!r||r.length<t)return{success:!1,message:"Smart key point unavailable"};qe.active=!0,qe.channel=e,qe.ordinal=t,qe.originalPoints=Pp(r),qe.originalInterpolation=n?.interpolation||"smooth",qe.selectionBefore={channel:Mt.selectedChannel,ordinal:Mt.selectedOrdinal};const i=Ee?.();qe.originalCurve=Array.isArray(i?.curves?.[e])?i.curves[e].slice():null,qe.originalSource=i?.sources?.[e]??null,qe.historyDescription=`Drag ${e} point ${t}`,qe.transactionId=null,qe.originalInkLimits=(()=>{const o=$r(e);if(!o)return null;const s=o.querySelector(".percent-input"),l=o.querySelector(".end-input");if(!s&&!l)return null;const c=s?.getAttribute("data-base-percent"),u=l?.getAttribute("data-base-end"),d=Number(c??s?.value??"0"),p=Number(u??l?.value??"0");return{percent:Number.isFinite(d)?d:0,end:Number.isFinite(p)?p:0}})();const a=Ft?.();if(a&&typeof a.beginTransaction=="function")try{qe.transactionId=a.beginTransaction(qe.historyDescription)}catch(o){console.warn("[EDIT MODE] Failed to start history transaction for drag:",o),qe.transactionId=null}return ei(e,t,{skipHistory:!0}),zn(),pi(),{success:!0}}function rS(e,t,n={}){if(!qe.active||qe.channel!==e||qe.ordinal!==t)return{success:!1,message:"Drag state mismatch"};if(Nt(e))return{success:!1,message:"Channel is locked"};const{inputPercent:r,outputPercent:i}=n||{},a={};Number.isFinite(r)&&(a.inputPercent=r),Number.isFinite(i)&&(a.outputPercent=i);const o=rl(e,t,a);return o.success&&(zn(),pi(),Je()),o}function XM(e){if(!e)return;const{channel:t,ordinal:n}=e;t&&(ei(t,n??1,{skipHistory:!0}),zn(),pi())}function QM(e,t,n,r){if(n!==r)return!0;if((!e||e.length===0)&&(!t||t.length===0))return!1;if(!e||!t||e.length!==t.length)return!0;for(let i=0;i<e.length;i++){const a=e[i],o=t[i];if(!o||Math.abs((a.input??0)-(o.input??0))>1e-4||Math.abs((a.output??0)-(o.output??0))>1e-4)return!0}return!1}function au(e={}){if(!qe.active)return{success:!1,message:"No drag in progress"};const t=Ft?.(),{commit:n=!0}=e||{},r=qe.channel,i=qe.ordinal;if(n&&Nt(r))return au({...e,commit:!1});const a=qe.originalPoints?Pp(qe.originalPoints):null,o=qe.originalInterpolation,s=qe.selectionBefore,l=Array.isArray(qe.originalCurve)?qe.originalCurve.slice():qe.originalCurve||null,c=qe.originalSource,u=qe.transactionId,d=qe.historyDescription,p=qe.originalInkLimits,f=()=>{qe.active=!1,qe.channel=null,qe.ordinal=0,qe.originalPoints=null,qe.originalInterpolation="smooth",qe.selectionBefore=null,qe.originalCurve=null,qe.originalSource=null,qe.transactionId=null,qe.historyDescription=null,qe.originalInkLimits=null};if(!n){if(a&&(Gi(r,a,o,{skipHistory:!0,skipMarkEdited:!0,allowWhenEditModeOff:!0}),XM(s),Je(),Pn()),u&&t&&typeof t.rollback=="function")try{t.rollback(u)}catch(A){console.warn("[EDIT MODE] Failed to rollback drag transaction:",A)}return p&&YM(r,p),f(),{success:!0,reverted:!0}}const h=Te.get(r),g=Pp(h?.points||[]),b=h?.interpolation||"smooth",S=Ee?.(),E=Array.isArray(S?.curves?.[r])?S.curves[r].slice():null,y=S?.sources?.[r]??null;if((a?QM(a,g,o,b):g.length>0)&&t)try{if(typeof t.recordKeyPointsChange=="function"&&t.recordKeyPointsChange(r,a,g,o,b),typeof t.recordChannelAction=="function"){const A={oldKeyPoints:a,newKeyPoints:g,oldInterpolation:o,newInterpolation:b,oldSource:c,newSource:y,selectedOrdinalBefore:s?.ordinal??i,selectedChannelBefore:s?.channel??r,selectedOrdinalAfter:i,selectedChannelAfter:r};d&&(A.description=d),t.recordChannelAction(r,"curve",l,E,A)}}catch(A){console.warn("[EDIT MODE] History recording failed after drag:",A)}if(u&&t&&typeof t.commit=="function")try{t.commit(u)}catch(A){console.warn("[EDIT MODE] Failed to commit drag transaction:",A)}return zn(),pi(),Je(),Pn(),f(),{success:!0,channel:r,ordinal:i}}function Bp(){return au({commit:!1})}function aa(){const e=D.getGlobalData?.();return e?.filename?e.filename:m.globalLinearizationFilename?.dataset?.originalFilename?m.globalLinearizationFilename.dataset.originalFilename:m.globalLinearizationFilename?.textContent?.trim()||""}function ZM(e){return`*BAKED* ${e||"correction"}`}function JM(e,t){return!e&&!t?!0:!e||!t?!1:e.filename===t.filename}function Sr(e,t={}){const n=D.getGlobalBakedMeta?.()||null;if(JM(n,e||null))return;if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] setGlobalBakedState",{previousMeta:n,meta:e,options:t}),e&&ha&&typeof xe.CurveHistory?.captureState=="function")try{xe.CurveHistory.captureState("Before: Bake global correction")}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to capture history before baking global correction:",o)}D.setGlobalBakedMeta?.(e||null);const r=ru();r&&(r.set("linearization.global.baked",e||null,t),e&&(r.set("linearization.global.applied",!1,{skipHistory:!0}),r.set("linearization.global.enabled",!1,{skipHistory:!0}))),m.globalLinearizationFilename&&D.getGlobalData?.()?.filename&&(m.globalLinearizationFilename.dataset.originalFilename=D.getGlobalData().filename);const i=!!e,a=i&&e?.filename||aa();if(m.globalLinearizationFilename&&(m.globalLinearizationFilename.textContent=i?ZM(a):a||""),m.globalLinearizationToggle){const o=m.globalLinearizationToggle;if(i)o.disabled=!0,o.setAttribute("aria-disabled","true"),o.dataset.baked="true",o.checked=!0,o.setAttribute("aria-checked","true"),o.title="Global correction baked into Smart curves. Undo or revert to modify.",D.globalApplied=!1,D.globalData&&(D.globalData.applied=!1);else{const s=!!D.getGlobalData?.();o.disabled=!s,o.removeAttribute("aria-disabled"),delete o.dataset.baked,o.title="",s||(o.checked=!1,o.setAttribute("aria-checked","false")),D.globalApplied=s,D.globalData&&(D.globalData.applied=s)}}if(!i)try{const o=Ee?.();o?.keyPointsMeta&&typeof o.keyPointsMeta=="object"&&Object.keys(o.keyPointsMeta).forEach(s=>{const l=o.keyPointsMeta[s];l&&typeof l=="object"&&l.bakedGlobal&&delete l.bakedGlobal})}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to clear bakedGlobal metadata while resetting state:",o)}i&&(!n||n.filename!==a)&&Z(`Global correction baked into Smart curves (${a||"correction"}). Use undo or revert to edit.`);try{yt()}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to update session status after baked state change:",o)}try{po()}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to refresh processing details after baked state change:",o)}try{const o=Array.from(document.querySelectorAll("tr[data-channel]")),s=xe?.graphStatus;o.forEach(l=>{const c=l.getAttribute("data-channel");c&&setTimeout(()=>{s&&typeof s.updateProcessingDetail=="function"?s.updateProcessingDetail(c):Ur(c)},0)})}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to refresh processing detail after baked state change:",o)}try{Er()}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to refresh revert buttons after baked state change:",o)}}ha&&(xe.__quadSetGlobalBakedState=Sr);function iS(e){const t=ru();t&&typeof t.setEditMode=="function"&&t.setEditMode(e)}function aS(e){ns=!!e,ha&&(xe.__EDIT_MODE_PRIMED=ns)}function ei(e,t=Mt.selectedOrdinal,n={}){const r=Mt.selectedChannel,i=Mt.selectedOrdinal,a=e??null,o=Number.isFinite(t)?t:1;Mt.selectedChannel=a,Mt.selectedOrdinal=o;const s=ru();s&&typeof s.setEditSelection=="function"&&s.setEditSelection(a,o,{...n,previousSelection:{channel:r,ordinal:i}})}function Qs(e){ei(Mt.selectedChannel,e,{skipHistory:!0})}let Wh=!1,Kh=!1;const Tp=64,Yh=.1,ud=42;function eL(){try{const n=$o()?.processingPipeline?.make256;if(typeof n=="function")return n}catch(t){console.warn("[EDIT MODE] Failed to resolve make256 from registry:",t)}const e=Cf("make256");return typeof e=="function"?e:null}function mm(e){const t=Te.get(e);return!t||!Array.isArray(t.points)?[]:t.points.map((n,r)=>({...n,rawOrdinal:r+1})).sort((n,r)=>n.input===r.input?n.rawOrdinal-r.rawOrdinal:n.input-r.input)}function yo(e){const t=mm(e);if(t.length===0)return{orderedPoints:t,sortedOrdinal:0,sortedIndex:-1,point:null,rawOrdinal:null};let n=Mt.selectedOrdinal||1;n=Math.max(1,Math.min(t.length,n)),Qs(n);const r=n-1,i=t[r];return{orderedPoints:t,sortedOrdinal:n,sortedIndex:r,point:i,rawOrdinal:i.rawOrdinal}}function tL(e){return e?.shiftKey?5:e?.altKey||e?.metaKey?.1:1}function nL(e,t,n){if(typeof console<"u"&&console.log("[EDIT MODE] applyNudgeToSelectedPoint invoked",{deltaInput:e,deltaOutput:t}),!ht()){Z("Edit mode is off");return}const r=Mt.selectedChannel;if(!r)return;if(Nt(r)){Z(Vi(r,"deleting points"));return}if(!Js(r)){Z("Channel disabled â€“ enable in Channels to edit");return}So(r);let i=yo(r);if(i.point||(Zs(r,{forceIfEditModeEnabling:!0}),So(r),Qs(1),i=yo(r)),typeof console<"u"&&console.log("[EDIT MODE] nudge context",i),!i.point){Z("No Smart key points available â€” add or recompute points first");return}const{point:a,rawOrdinal:o}=i,s={},l=tL(n);if(e!==0&&(s.deltaInput=e*l),t!==0){const d=Ea(r,a.output),p=Math.max(0,Math.min(100,d+t*l));s.outputPercent=p}ha&&(xe.__EDIT_LAST_NUDGE={channelName:r,rawOrdinal:o,params:{...s},before:Te.get(r)?.points||[]});const u=(ha&&xe.quadGenActions&&typeof xe.quadGenActions.adjustSmartKeyPointByIndex=="function"?xe.quadGenActions.adjustSmartKeyPointByIndex.bind(xe.quadGenActions):rl)(r,o,s);if(ha&&(xe.__EDIT_LAST_NUDGE_RESULT={...u,after:Te.get(r)?.points||[]}),!u?.success){Z(u?.message||"Edit failed");return}zn(),ou()}function sc(e){if(!Array.isArray(e)||e.length!==2)return!1;const[t,n]=e,r=a=>Math.abs(a)<=1e-4,i=a=>Math.abs(a-100)<=1e-4;return r(t?.input)&&r(t?.output)&&i(n?.input)&&i(n?.output)}function rL(e,t){const n=$t(()=>({keyPointsMeta:{}}));n.keyPointsMeta=n.keyPointsMeta||{};const r=n.keyPointsMeta[e]||{};if(t)n.keyPointsMeta[e]={...r,measurementSeed:t};else if(r.measurementSeed){const{measurementSeed:i,...a}=r;n.keyPointsMeta[e]=a}}function ga(e,t,n="smooth",r={}){const{measurementSeed:i,smartTouched:a=!1,skipUiRefresh:o=!0,pointsAreRelative:s=!1,channelPercentOverride:l=null,includeBakedFlags:c=!0}=r||{};typeof xe<"u"&&(xe.__PERSIST_TRIPPED=(xe.__PERSIST_TRIPPED||0)+1);let u={};if(c){const h=!!m?.autoWhiteLimitToggle?.checked,g=!!m?.autoBlackLimitToggle?.checked;u={bakedAutoLimit:h||g,bakedAutoWhite:h,bakedAutoBlack:g};const b=D.getGlobalData?.(),S=!!(D.globalApplied&&b),E=typeof D.getGlobalBakedMeta=="function"?D.getGlobalBakedMeta():null;if(S||E){u.bakedGlobal=!0;const y=E?.filename||b?.filename||aa();y&&(u.bakedFilename=y)}}const d=Number.isFinite(l)?l:getChannelPercent(e);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] persistSmartPoints channel percent",e,{override:l,resolved:d});const p=t.map(h=>{const g=Number(h.input),b=Number(h.output);let S;if(s)S=Math.max(0,Math.min(100,b));else{const E=Number.isFinite(d)&&d>0?b/d*100:b;S=Math.max(0,E)}return{input:g,output:S}});typeof xe<"u"&&(xe.__PERSIST_DEBUG=xe.__PERSIST_DEBUG||[],xe.__PERSIST_DEBUG.push({channelName:e,channelPercent:d,override:l,sample:p.slice(0,5)}));const f=Gi(e,p,n,{skipHistory:!0,skipMarkEdited:!0,skipUiRefresh:o,bakedFlags:u,includeBakedFlags:c,allowWhenEditModeOff:!0,smartTouched:a});if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] persistSmartPoints setSmartKeyPoints result",e,f),!f?.success){Te.persist(e,p,n);const h=$t(()=>({keyPointsMeta:{}}));h.keyPointsMeta=h.keyPointsMeta||{};const g={...h.keyPointsMeta[e]||{},interpolationType:n,...c?u:{}};if(c||(delete g.bakedGlobal,delete g.bakedFilename,delete g.bakedAutoLimit,delete g.bakedAutoWhite,delete g.bakedAutoBlack),"smartTouched"in g&&delete g.smartTouched,h.keyPointsMeta[e]=g,!o)try{Pn(),Ur(e),Je(),Er()}catch(b){console.warn("[EDIT MODE] Failed to refresh UI after persist fallback:",b)}}if(i){const h={...i,points:t.map(g=>({input:Number(g.input),output:Number(g.output)}))};rL(e,h)}if(!o)try{Ur(e)}catch(h){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to refresh processing detail after persistSmartPoints:",h)}}function iL(e){const t=D.getPerChannelData(e),n=(t?.format||"").toUpperCase();if(D.isPerChannelEnabled(e)&&t&&(n.includes("LAB")||n.includes("MANUAL"))&&Array.isArray(t.originalData)&&t.originalData.length>0)return{scope:"per",format:n,count:t.originalData.length,data:t};if(D.hasAnyLinearization()){const r=D.getGlobalData(),i=(r?.format||"").toUpperCase();if(r&&(i.includes("LAB")||i.includes("MANUAL"))&&Array.isArray(r.originalData)&&r.originalData.length>0)return{scope:"global",format:i,count:r.originalData.length,data:r}}return null}function Ya(e,t,n=!0){const r=eL(),i=[];typeof r=="function"&&i.push(r),typeof Yt=="function"&&Yt!==r&&i.push(Yt);for(let a=0;a<i.length;a+=1){const o=i[a];try{const s=o(t,e,n,{forceSmartApplied:!1});if(Array.isArray(s)&&s.length===Xt){const l=iu(e);return Array.isArray(l)&&l.length===Xt&&fm(s,l)?(yn(`Primary make256 samples deviated for ${e}`,{stage:"sampleLinearizedCurve"}),l.slice()):s}}catch(s){yn(`make256 execution failed for ${e}`,{error:s?.message})}}return yn(`make256 helper unavailable for ${e}`),null}function Op(){if(!ht()||!m.rows)return;Array.from(m.rows.children).filter(t=>t.id!=="noChannelsRow").forEach(t=>{const n=t.getAttribute("data-channel");if(n)try{Zs(n,{forceIfEditModeEnabling:!0})}catch(r){console.warn("[EDIT MODE] Measurement refresh failed for",n,r)}})}function aL(e,t,n){if(!e||!t||e.scope!==t.scope||e.format!==t.format)return!1;if(typeof t.count=="number"&&t.count>0){if(e.count!==t.count)return!1;const r=Array.isArray(e.points)&&e.points.length>0?e.points.length:t.count;if(typeof n=="number"&&n>0&&n!==r)return!1}return!0}function ht(){return _i()}function ys(e,t={}){const n=t||{},r=ht(),i=typeof e=="boolean"?e:!r;_s(i),iS(i),sL(i);const a=ns;if(i&&!ns)try{lL(),aS(!0)}catch(o){console.warn("[EDIT MODE] Initialization error:",o)}if(i&&ns&&a)try{if(D.hasAnyLinearization()){console.log("[EDIT MODE] LAB data detected - checking for Smart Curves regeneration...");const s=[];m.rows&&Array.from(m.rows.children).filter(d=>d.id!=="noChannelsRow").forEach(d=>{const p=d.getAttribute("data-channel");if(!p)return;const f=d.querySelector(".percent-input"),h=d.querySelector(".end-input"),g=parseFloat(f?.value||"0"),b=parseInt(h?.value||"0",10);(g>0||b>0)&&s.push(p)});const c=!!(D.getGlobalData()&&D.globalApplied);s.forEach(u=>{const d=D.isPerChannelEnabled(u);(d||c)&&(console.log(`[EDIT MODE] Regenerating Smart Curves for ${u} with ${d?"per-channel":"global"} LAB data`),Zs(u,{forceIfEditModeEnabling:!0}))})}}catch(o){console.warn("[EDIT MODE] LAB data reinitialize error:",o)}if(n.recordHistory){const o=Cf("CurveHistory");if(o&&typeof o.recordUIAction=="function")try{const s=e?"Enable Edit Mode":"Disable Edit Mode";o.recordUIAction("editMode",r,e,s)}catch(s){console.warn("[EDIT MODE] History recording failed:",s)}}e&&sS(),zn();try{Je(),Wd("updateInterpolationControls")}catch(o){console.warn("[EDIT MODE] Component update error:",o)}return!0}function oS(){sS()}function oL(e,t={}){const n=t.description||(e?`Select channel ${e}`:"Clear edit selection");ei(e,1,{...t,description:n}),e&&So(e),zn()}function Ss(e,t,n={}){if(!ht())return{success:!1,message:"Edit mode is off"};const r=e||Mt.selectedChannel;if(!r)return Z("No channel selected"),{success:!1,message:"No channel selected"};So(r);const a=Te.get(r)?.points||[];if(!Array.isArray(a)||a.length===0)return Z("No Smart key points available â€” add or recompute points first"),{success:!1,message:"No Smart key points available"};const o=Math.round(Number(t)||1),s=Math.max(1,Math.min(a.length,o)),l=n?.description||`Select ${r} Smart point ${s}`;if(ei(r,s,{description:l,skipHistory:n?.skipHistory??!1}),zn(),pi(),Je(),!n?.silent){const c=a[s-1]||null,u=c?tS(c.input??0):String(s);Z(`Selected ${r} point ${s} (${u}%)`)}return{success:!0,channel:r,ordinal:s}}function So(e){const{points:t}=Te.get(e);if(!t||t.length===0||sc(t)){const n=m.rows?Array.from(m.rows.children).find(l=>l.getAttribute("data-channel")===e):null,r=n?.querySelector(".percent-input"),i=n?.querySelector(".end-input");Number.parseFloat(r?.value||"0");const a=Number.parseInt(i?.value||"0",10),o=Z0(e,a,!0,"ensure");if(Array.isArray(o)&&o.length===Xt&&bo(e,o,"ensure")||J0(e,"ensure-stored"))return;const s=nl(0,100);Te.persist(e,s,"smooth"),console.log(`[EDIT MODE] Created default key points for ${e}`)}}function sL(e){try{const t=document.getElementById("editModeToggleBtn"),n=document.getElementById("editModeLabel");t&&(t.setAttribute("aria-pressed",String(!!e)),t.setAttribute("aria-checked",String(!!e)),t.classList.remove("bg-slate-600","hover:bg-slate-700","bg-black","hover:bg-gray-900","bg-orange-600","hover:bg-orange-700","bg-rose-800","hover:bg-rose-900","border","border-blue-200"),t.classList.add("text-white","font-bold","border-0"),e?t.classList.add("bg-black","hover:bg-gray-900"):t.classList.add("bg-slate-600","hover:bg-slate-700")),n&&(n.textContent=e?"â—ˆ Edit Mode: ON":"âŸ Edit Mode: OFF")}catch(t){console.warn("[EDIT MODE] Button update error:",t)}}function Zs(e,t={}){if(!ht()&&!t.forceIfEditModeEnabling){console.log(`[EDIT MODE] Skip reinitializing ${e} - edit mode not active`);return}if(!m.rows)return;const r=Te.get(e)?.points||null,i=Ee()?.keyPointsMeta?.[e]||{},a=sc(r);if(i.smartTouched&&!a){console.log(`[EDIT MODE] Skip reinitializing ${e} - Smart curve already edited`);return}const s=Array.from(m.rows.children).filter(g=>g.id!=="noChannelsRow").find(g=>g.getAttribute("data-channel")===e);if(!s){console.log(`[EDIT MODE] Channel row not found for ${e}`);return}const l=s.querySelector(".percent-input"),c=s.querySelector(".end-input"),u=parseFloat(l?.value||"0"),d=parseInt(c?.value||"0",10);if(u<=0&&d<=0){console.log(`[EDIT MODE] Skip reinitializing ${e} - channel not enabled`);return}console.log(`[EDIT MODE] Reinitializing Smart key points for ${e}...`);const p=D.hasAnyLinearization(),f=p?D.getGlobalData():null,h=(f?.format||"").toUpperCase();try{let g=null,b=null,S=null,E=null;if(p&&D.isPerChannelEnabled(e)){const y=D.getPerChannelData(e),v=(y?.format||"").toUpperCase(),A=25,w=Array.isArray(y?.originalData)?y.originalData.slice(0,Tp):null;if(w&&w.length>0&&w.length<=A){console.log(`[EDIT MODE] ðŸŽ¯ Directly mapping ${w.length} per-channel measurement points for ${e}`);const M=65535,I=Ya(e,d,!0);if(I&&I.length===256){const _=I.length-1;g=w.map(C=>{const x=Number(C.input??C.GRAY??C.gray??C.Gray??0),P=Math.max(0,Math.min(100,x)),k=P/100*_,N=Math.floor(k),F=Math.min(_,Math.ceil(k)),U=k-N,j=(1-U)*I[N]+U*I[F],B=Math.max(0,Math.min(100,j/M*100));return{input:P,output:B}}),b={measurementSeed:{scope:"per",format:v,count:y.originalData.length||0}}}}else if(y&&y.originalData&&Array.isArray(y.originalData)&&y.originalData.length<=A&&typeof y.getSmoothingControlPoints=="function"){console.log(`[EDIT MODE] ðŸŽ¯ Direct seeding ${e} from ${y.originalData.length} per-channel measurement points via getSmoothingControlPoints`);const M=65535;try{const I=y.getSmoothingControlPoints(0);I&&I.samples&&I.xCoords&&(g=I.xCoords.map((_,C)=>{const x=_*100,P=I.samples[C]*d,k=Math.max(0,Math.min(100,P/M*100));return{input:x,output:k}}),b={measurementSeed:{scope:"per",format:v,count:y.originalData.length||0}})}catch(I){console.warn(`[EDIT MODE] Per-channel getSmoothingControlPoints failed for ${e}:`,I)}}else if(y&&y.format==="ACV"&&Array.isArray(y.controlPointsTransformed)&&y.controlPointsTransformed.length>=2&&y.controlPointsTransformed.length<=A)console.log(`[EDIT MODE] ðŸŽ¯ Direct seeding ${e} from ${y.controlPointsTransformed.length} per-channel ACV anchor points`),g=y.controlPointsTransformed.map(M=>({input:M.input,output:M.output}));else{console.log(`[EDIT MODE] Creating measurement-based key points for ${e} from per-channel data`);const M=Ya(e,d,!0);if(M&&M.length===256){const _=M.length-1,C=Array.isArray(y?.originalData)?y.originalData:null;C&&C.length>0?(g=C.slice(0,Tp).map(P=>{const k=Number(P.input??P.GRAY??P.gray??P.Gray??0),N=Math.max(0,Math.min(100,k)),F=N/100*_,U=Math.floor(F),j=Math.min(_,Math.ceil(F)),B=F-U,G=(1-B)*M[U]+B*M[j],V=Math.max(0,Math.min(100,G/65535*100));return{input:N,output:V}}),keyPointsAreRelative=!1,b={measurementSeed:{scope:"per",format:v,count:y.originalData.length||0}},console.log(`[EDIT MODE] âœ… Directly mapped ${g.length} measurement points for ${e}`)):(g=Ar(M,{maxErrorPercent:vn.maxErrorPercent,maxPoints:vn.maxPoints}),console.log(`[EDIT MODE] âœ… Created ${g.length} adaptive key points for ${e} from measurement curve`))}}}else if(p&&D.globalApplied)if(f&&Array.isArray(f.originalData)&&f.originalData.length>0){const v=f.originalData.length,A=65535,w=Ya(e,d,!0);if(w&&w.length===256){const M=Array.from(w),I=M.length-1,_=x=>{const k=Math.max(0,Math.min(100,x))/100*I,N=Math.floor(k),F=Math.min(I,Math.ceil(k)),U=k-N,j=(1-U)*M[N]+U*M[F],B=A>0?j/A*100:0;return Math.max(0,Math.min(100,B))},C=f.originalData.map(x=>{const P=Number(x.input??x.GRAY??x.gray??x.Gray??0),k=Math.max(0,Math.min(100,P)),N=_(k),F={input:k,output:N};return typeof x.LAB_L=="number"&&(F.labL=x.LAB_L),F});if(v<=25)console.log(`[EDIT MODE] ðŸŽ¯ Directly mapping ${v} global measurement points for ${e}`),g=C,b={measurementSeed:{scope:"global",format:h,count:v,originalPoints:C}};else{const x=Math.max(25,Math.min(100,M.length)),P=[];for(let k=0;k<x;k+=1){const N=x===1?0:k/(x-1)*100,F=x===1?0:k/(x-1)*I,U=Math.floor(F),j=Math.min(I,Math.ceil(F)),B=F-U,G=M[U]??0,V=M[j]??G,K=(1-B)*G+B*V,se=d>0?K/d*100:0;P.push({input:N,output:Math.max(0,Math.min(100,se))})}g=P,b={measurementSeed:{scope:"global",format:h,count:v,originalPoints:C}},console.log(`[EDIT MODE] âœ… Extracted ${g.length} Smart key points for ${e} from corrected curve samples`),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] Global measurement fallback count (reinitialize)",g.length,e)}}}else if(f&&Array.isArray(f.originalData)&&f.originalData.length<=25&&typeof f.getSmoothingControlPoints=="function"){console.log(`[EDIT MODE] ðŸŽ¯ Direct seeding ${e} from ${f.originalData.length} global measurement points via getSmoothingControlPoints`);const v=65535;try{const A=f.getSmoothingControlPoints(0);A&&A.samples&&A.xCoords&&(g=A.xCoords.map((w,M)=>{const I=w*100,_=A.samples[M]*d,C=Math.max(0,Math.min(100,_/v*100));return{input:I,output:C}}),b={measurementSeed:{scope:"global",format:h,count:f.originalData.length||0}})}catch(A){console.warn(`[EDIT MODE] getSmoothingControlPoints failed for ${e}:`,A)}}else f&&f.format==="ACV"&&Array.isArray(f.controlPointsTransformed)&&f.controlPointsTransformed.length>=2&&f.controlPointsTransformed.length<=25&&(console.log(`[EDIT MODE] ðŸŽ¯ Direct seeding ${e} from ${f.controlPointsTransformed.length} global ACV anchor points`),g=f.controlPointsTransformed.map(v=>({input:v.input,output:v.output})));if(g&&g.length>=2){const y=Number.isFinite(u)&&u>0?u:null,v=g.map(M=>{const I=Number(M.output),_=y&&y>0?I/y*100:I;return{input:Number(M.input),output:Math.max(0,Math.min(100,_))}}),A=!!(b&&b.measurementSeed);A&&(S=null);const w={...b||{},channelPercentOverride:y,pointsAreRelative:!0,skipUiRefresh:!1,includeBakedFlags:!A};ga(e,v,"smooth",w),!A&&S&&Sr(S),console.log(`[EDIT MODE] âœ… Reinitialized ${g.length} Smart key points for ${e}`),Je()}else console.log(`[EDIT MODE] No measurement-based key points available for ${e}, keeping existing Smart Curves`)}catch(g){console.warn(`[EDIT MODE] Failed to reinitialize Smart key points for ${e}:`,g)}}function lL(){console.log("[EDIT MODE] Initializing Smart key points for enabled channels...");const e=D.hasAnyLinearization(),t=e?D.getGlobalData():null,n=(t?.format||"").toUpperCase();if(console.log(`[EDIT MODE] Measurement data active: ${e}`),e&&(console.log("[EDIT MODE] ðŸ“Š Measurement data detected - creating Smart key points from corrected curves"),console.log("[EDIT MODE] ðŸ’¡ This preserves LAB/measurement corrections in Edit Mode")),!m.rows)return;const r=[];if(Array.from(m.rows.children).filter(a=>a.id!=="noChannelsRow").forEach(a=>{const o=a.getAttribute("data-channel");if(!o)return;const s=a.querySelector(".percent-input"),l=a.querySelector(".end-input"),c=parseFloat(s?.value||"0"),u=parseInt(l?.value||"0",10);(c>0||u>0)&&r.push(o)}),console.log(`[EDIT MODE] Found ${r.length} enabled channels:`,r),console.log("[EDIT MODE] Enabled channel list for initialization:",r),typeof xe<"u"&&(xe.__EDIT_INIT_CONTEXT={hasMeasurementData:e,enabledChannels:r.slice()}),r.forEach(a=>{const s=Te.get(a).points,l=sc(s),c=Ee()?.keyPointsMeta?.[a]||{},u=iL(a),d=aL(c.measurementSeed,u,s?.length);let p=!1;if(c.smartTouched&&!l?p=!1:!s||s.length<2?p=!0:u&&(p=!d||l),!p&&l&&(p=!0),console.log(`[EDIT MODE] Channel ${a}: existing=${s?.length||0}, measurementContext=${u?`${u.scope}:${u.format}:${u.count}`:"none"}, needsSeed=${p}`),p){console.log(`[EDIT MODE] Creating Smart key points for ${a}...`);try{let f=null,h=null,g=null,b=!1,S=null,E=!1;const y=Array.from(m.rows.children).find(C=>C.getAttribute("data-channel")===a),v=y?.querySelector(".percent-input"),A=y?.querySelector(".end-input"),w=parseFloat(v?.value||"0"),M=parseInt(A?.value||"0",10),I=Z0(a,M,e,"initialize");if(Array.isArray(I)&&I.length===Xt&&bo(a,I,"initialize")&&(E=!0,S=I,b=!0,f=Te.get(a)?.points||null),!E&&e&&D.isPerChannelEnabled(a)){const C=D.getPerChannelData(a),x=(C?.format||"").toUpperCase();console.log(`[EDIT MODE] Creating measurement-like key points for ${a}`);const P=Ya(a,M,!0);if(P&&P.length===256){const N=P.length-1,F=Array.isArray(C?.originalData)?C.originalData:null;if(F&&F.length>0){const U=F.slice(0,Tp);f=Ar(P,{maxErrorPercent:Yh,maxPoints:ud,scaleMax:M>0?M:65535}).map(G=>({input:Math.max(0,Math.min(100,Number(G.input))),output:Math.max(0,Math.min(100,Number(G.output)))})),b=!0;const B=U.map(G=>{const V=Number(G.input??G.GRAY??G.gray??G.Gray??0),K=Math.max(0,Math.min(100,V)),se=K/100*N,W=Math.floor(se),fe=Math.min(N,Math.ceil(se)),Se=se-W,we=(1-Se)*P[W]+Se*P[fe],Ne=Math.max(0,Math.min(100,we/65535*100));return{input:K,output:Ne}});h={measurementSeed:{scope:"per",format:x,count:C.originalData.length||0,originalPoints:B}},console.log(`[EDIT MODE] âœ… Adaptive per-channel measurement points for ${a} (${f.length})`)}else f=Ar(P,{maxErrorPercent:Yh,maxPoints:ud,scaleMax:M>0?M:65535}).map(j=>({input:Math.max(0,Math.min(100,Number(j.input))),output:Math.max(0,Math.min(100,Number(j.output)))})),b=!0,console.log(`[EDIT MODE] âœ… Created ${f.length} adaptive key points for ${a} from measurement curve`)}}else if(!E&&e&&D.globalApplied){if(t&&Array.isArray(t.originalData)&&t.originalData.length>0){const x=t.originalData.length,P=65535,k=Ya(a,M,!0),N=Array.isArray(t.samples)?t.samples:null;if(k&&k.length===256){const F=Array.from(k),U=F.length-1,j=G=>{const K=Math.max(0,Math.min(100,G))/100*U,se=Math.floor(K),W=Math.min(U,Math.ceil(K)),fe=K-se,Se=(1-fe)*F[se]+fe*F[W],we=P>0?Se/P*100:0;return Math.max(0,Math.min(100,we))},B=t.originalData.map(G=>{const V=Math.max(0,Math.min(100,Number(G.input??G.GRAY??G.gray??0))),K=j(V),se={input:V,output:K};return typeof G.LAB_L=="number"&&(se.labL=G.LAB_L),se});if(x<=25)console.log(`[EDIT MODE] ðŸŽ¯ Direct seeding ${a} from ${x} global measurement points`),console.log("[EDIT MODE] ðŸ’¡ This replicates legacy quadgen.html LAB â†’ Smart Curves workflow"),f=Ar(F,{maxErrorPercent:.1,maxPoints:42,scaleMax:M>0?M:P}).map(V=>({input:Math.max(0,Math.min(100,Number(V.input))),output:Math.max(0,Math.min(100,Number(V.output)))})),b=!0,h={measurementSeed:{scope:"global",format:n,count:x,originalPoints:B}},typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] Global measurement adaptive count",f.length,a);else{const G=Math.max(25,Math.min(ud,F.length)),V=[];for(let K=0;K<G;K+=1){const se=G===1?0:K/(G-1)*100,W=G===1?0:K/(G-1)*U,fe=Math.floor(W),Se=Math.min(U,Math.ceil(W)),we=W-fe,Ne=F[fe]??0,ct=F[Se]??Ne,mt=(1-we)*Ne+we*ct,Vt=M>0?mt/M*100:0;V.push({input:se,output:Math.max(0,Math.min(100,Vt))})}f=V,b=!0,g={scope:"global",filename:t?.filename||aa(),pointCount:f.length,timestamp:Date.now()},h={measurementSeed:{scope:"global",format:n,count:x,originalPoints:B}},console.log(`[EDIT MODE] âœ… Extracted ${f.length} Smart key points for ${a} from corrected curve samples`),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] Global measurement fallback count",f.length,a)}}else if(N&&N.length===256){const F=N.length-1;f=t.originalData.map(U=>{const j=Math.max(0,Math.min(100,Number(U.input??U.GRAY??U.gray??0))),B=j/100*F,G=Math.floor(B),V=Math.min(F,Math.ceil(B)),K=B-G,W=((1-K)*N[G]+K*N[V])*M,fe=Math.max(0,Math.min(100,W/P*100));return{input:j,output:fe}}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] Global normalized key points count",f.length,a),g={scope:"global",filename:t?.filename||aa(),pointCount:f.length,timestamp:Date.now()},h={measurementSeed:{scope:"global",format:n,count:x}},console.log(`[EDIT MODE] âœ… Generated ${f.length} key points for ${a} using normalized measurement fallback`)}}}else if(!E){const x=Array.from(m.rows.children).find(k=>k.getAttribute("data-channel")===a)?.querySelector(".end-input"),P=parseInt(x?.value||"0",10);!E&&Array.isArray(I)&&I.length===Xt&&bo(a,I,"initialize-fallback")&&(E=!0,S=I,b=!0,f=Te.get(a)?.points||null)}if(f&&f.length>=2&&!E){const C=Number.isFinite(w)&&w>0?w:null,x=!!(h&&h.measurementSeed),P={...h||{},channelPercentOverride:C,pointsAreRelative:!0,skipUiRefresh:!1,includeBakedFlags:!0,sourceSamples:S},k=C&&C>0?C:null,N=f.map(U=>{const j=Number(U.output);let B;return P.pointsAreRelative?b?B=j:k?B=j/k*100:B=j:B=j,{input:Number(U.input),output:Math.max(0,Math.min(100,B))}});if(ga(a,N,"smooth",P),!x&&Array.isArray(S)&&S.length===Xt){const U=xp(a,S);if(!U.ok){const j=eS(S,ve);if(Array.isArray(j)&&j.length>=2){const B=j.map(G=>{const V=Number(G.output);return C&&C>0?{input:Number(G.input),output:Math.max(0,Math.min(100,V/C*100))}:{input:Number(G.input),output:Math.max(0,Math.min(100,V))}});yn(`Retrying Smart seed with inflection fallback for ${a}`,U),ga(a,B,"smooth",{channelPercentOverride:C,pointsAreRelative:!0,skipUiRefresh:!1,includeBakedFlags:!0,smartTouched:!0})}}S=null}let F=null;x?u?.scope==="global"&&(F={scope:"global",filename:u?.data?.filename||D.getGlobalData?.()?.filename||aa()||void 0,pointCount:N.length,timestamp:Date.now()}):g&&(F=g),F&&Sr(F)}else if(E)console.log(`[EDIT MODE] âœ… Preserved existing Smart key points for ${a} from fallback samples`);else{const C=nl(),x=Number.isFinite(w)&&w>0?w:null,P=C.map(N=>{const F=Number(N.output),U=x?F/x*100:F;return{input:Number(N.input),output:Math.max(0,Math.min(100,U))}});ga(a,P,"smooth",{channelPercentOverride:x,pointsAreRelative:!0,smartTouched:!1,skipUiRefresh:!1}),console.log(`[EDIT MODE] âœ… Created default linear points for ${a}`)}const _=Te.get(a)?.points||[];(!Array.isArray(_)||_.length<=2||sc(_))&&J0(a,"initialize-final")&&console.log(`[EDIT MODE] âœ… Rebuilt Smart key points for ${a} from stored curve`)}catch(f){console.warn(`[EDIT MODE] Failed to create Smart key points for ${a}:`,f)}}else console.log(`[EDIT MODE] ${a} already has ${s.length} Smart key points`)}),e&&D.isGlobalEnabled?.())try{const a=D.getGlobalData?.();if(a){const o=r[0]||null,s=o&&Te.get(o)?.points?.length||0;Sr({scope:"global",filename:a.filename||aa(),pointCount:s,timestamp:Date.now()},{skipHistory:!0})}}catch(a){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Unable to mark global correction baked during initialization:",a)}if(D.isGlobalEnabled?.()){const a=Ee?.()||null;r.forEach(o=>{const s=a?.keyPointsMeta?.[o]||{},l=!!s.measurementSeed;if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] Simplify check",o,s),l){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[EDIT MODE] Skipping Smart simplification for",o,"due to measurement seed");return}try{Fi(o,{maxErrorPercent:.05,maxPoints:50,minPoints:20,skipUiRefresh:!0})}catch(c){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] Failed to resimplify Smart points after measurement load for",o,c)}})}r.length>0&&!Mt.selectedChannel&&(ei(r[0],1),console.log(`[EDIT MODE] âœ… Selected ${r[0]} as default edit channel`))}function sS(){if(!m.editChannelSelect||!m.rows)return;const e=m.editChannelSelect,n=Array.from(m.rows.children).filter(c=>c.id!=="noChannelsRow").map(c=>{const u=c.getAttribute("data-channel");return u&&lS(c,u)?u:null}).filter(Boolean),r=e.value,i=Mt.selectedChannel||r,a=Mt.selectedOrdinal||1;if(e.innerHTML="",n.length===0){const c=document.createElement("option");c.value="",c.textContent="No channels enabled",c.disabled=!0,c.selected=!0,e.appendChild(c),ei(null,1),_p(!1),m.editChannelState&&(m.editChannelState.textContent="");return}n.forEach(c=>{const u=document.createElement("option");u.value=c,u.textContent=c,e.appendChild(u)});const o=n.includes(i)?i:n[0];e.value=o;const s=Mt.selectedChannel!==o;ei(o,s?1:a,{skipHistory:!s}),o&&So(o),zn()}function zn(){const e=Mt.selectedChannel;if(!ht()){_p(!1),m.editChannelState&&(m.editChannelState.textContent="");return}const t=Js(e);_p(t);try{ac(e)}catch(n){console.warn("[EDIT MODE] Failed to refresh bell apex control:",n)}try{X0(e)}catch(n){console.warn("[EDIT MODE] Failed to refresh bell width controls:",n)}m.editChannelState&&(e&&t?m.editChannelState.textContent=`Editing: ${e}`:e?m.editChannelState.textContent=`${e} (disabled)`:m.editChannelState.textContent="No channel selected"),pi()}function lS(e,t){if(!e)return!1;const n=e.querySelector(".percent-input")?.value??"",r=e.querySelector(".end-input")?.value??"",i=Number.parseFloat(n),a=Number.parseInt(r,10),o=Number.isFinite(i)&&i>0,s=Number.isFinite(a)&&a>0,l=e.querySelector(".per-channel-toggle"),c=!!l&&l.checked,u=!!t&&D.isPerChannelEnabled(t);return o||s||c||u}function Js(e){if(!e)return!1;const t=$r(e);return lS(t,e)}function _p(e){try{m.editPanelBody&&m.editPanelBody.classList.toggle("edit-panel-disabled",!e),["editChannelSelect","editChannelPrev","editChannelNext","editRecomputeBtn","editPointLeft","editPointRight","editXYInput","editDeleteBtn","editNudgeXNeg","editNudgeXPos","editNudgeYUp","editNudgeYDown","editMaxError","editMaxPoints"].forEach(r=>{const i=m[r]||document.getElementById(r);i&&(i.disabled=!e)});const n=m.editPointIndex||document.getElementById("editPointIndex");if(n&&n.classList.toggle("is-disabled",!e),m.editDisabledHint){const r=e||!ht();m.editDisabledHint.classList.toggle("hidden",r)}}catch(t){console.warn("[EDIT MODE] Controls update error:",t)}}function Xh(e){if(!ht()){Z("Edit mode is off");return}const t=m.editChannelSelect||document.getElementById("editChannelSelect");if(!t)return;const n=Array.from(t.options).filter(l=>!l.disabled&&l.value);if(n.length===0){Z("No channels enabled");return}const r=t.value&&n.some(l=>l.value===t.value)?t.value:n[0].value,i=n.findIndex(l=>l.value===r),o=(((i>=0?i:0)+e)%n.length+n.length)%n.length,s=n[o].value;if(!(!s||s===Mt.selectedChannel)){oL(s,{description:`Select channel ${s}`}),t.value!==s&&(t.value=s);try{Je()}catch(l){console.warn("[EDIT MODE] Failed to update chart after channel cycle:",l)}}}function cS(){_s(!1),ei(null,1,{skipHistory:!0}),iS(!1),aS(!1),cL(),pL(),CM(),WM(),console.log("âœ… Edit mode system initialized")}function cL(){Kh||m.editChannelSelect&&(Kh=!0,m.editChannelSelect.addEventListener("change",e=>{ei(e.target.value||null,1,{description:`Select channel ${e.target.value||"none"}`}),zn();try{Je()}catch(t){console.warn("[EDIT MODE] Chart update failed:",t)}}))}function uL(){if(!ht()){Z("Edit mode is off");return}const e=Mt.selectedChannel;if(!e){Z("No channel selected");return}if(!Js(e)){Z("Channel disabled â€“ enable in Channels to recompute");return}try{const t=document.getElementById("editMaxError"),n=document.getElementById("editMaxPoints"),r=vn.maxErrorPercent,i=t?Math.max(.05,Math.min(5,parseFloat(t.value||String(r)))):r,a=n?Math.max(2,Math.min(21,parseInt(n.value||"21",10))):21,o=Mt.selectedOrdinal||1,s=Fi(e,{maxErrorPercent:i,maxPoints:a,allowMeasurementResimplify:!0});if(s.success){const l=mm(e),c=Math.max(1,Math.min(o,l.length||1));Qs(c),zn(),ou(),Z(`Recomputed ${e} Key Points (${a} max, ${i}% max error)`);try{Er()}catch(u){console.warn("[EDIT MODE] updateRevertButtonsState failed after recompute:",u)}}else Z(s.message||"Recompute failed")}catch(t){console.warn("[EDIT MODE] Recompute error:",t),Z("Recompute error: "+t.message)}}function Qh(e){if(!ht()){Z("Edit mode is off");return}const t=Mt.selectedChannel;if(!t)return;const{orderedPoints:n,sortedOrdinal:r}=yo(t);if(n.length===0)return;const i=n.length,a=((r-1+e)%i+i)%i+1;Qs(a),zn(),pi(),Je()}function dL(){if(!ht()){Z("Edit mode is off");return}const e=Mt.selectedChannel;if(!e)return;if(Nt(e)){Z(Vi(e,"deleting points"));return}if(!Js(e)){Z("Channel disabled â€“ enable in Channels to edit");return}const{orderedPoints:t,sortedOrdinal:n}=yo(e);if(t.length===0){Z("No key points to delete");return}const r=t[n-1].rawOrdinal;try{const i=ym(e,r,{allowEndpoint:!1});if(i.success){Z(`Deleted key point ${n} from ${e}`);const a=mm(e),o=Math.min(n,a.length);Qs(o>0?o:1),zn(),ou()}else Z(i.message||"Delete failed")}catch(i){console.warn("[EDIT MODE] Delete error:",i),Z("Delete error: "+i.message)}}function Zh(){if(!ht()){Z("Edit mode is off");return}const e=Mt.selectedChannel;if(!e)return;const t=document.getElementById("editXYInput");if(!t)return;const r=String(t.value||"").trim().split(",");if(r.length!==2){t.classList.add("border-red-300"),Z("Invalid format. Use X,Y (e.g., 25.5, 72.3)"),setTimeout(()=>t.classList.remove("border-red-300"),1500);return}const i=parseFloat(r[0].trim()),a=parseFloat(r[1].trim());if(isNaN(i)||isNaN(a)){t.classList.add("border-red-300"),Z("Invalid numbers. Use format: X,Y"),setTimeout(()=>t.classList.remove("border-red-300"),1500);return}let o=a;try{const d=document.querySelector(`tr[data-channel="${e}"]`)?.querySelector(".percent-input"),p=d?q.clampPercent(d.getAttribute("data-base-percent")??d.value):100;Number.isFinite(p)&&p>0&&(a>p&&a<=100?o=a/100*p:a>100&&(o=p))}catch(u){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[EDIT MODE] XY input percent clamp failed",u)}const{orderedPoints:s,sortedOrdinal:l,rawOrdinal:c}=yo(e);if(s.length===0||c==null){t.classList.add("border-red-300"),Z("No key point selected"),setTimeout(()=>t.classList.remove("border-red-300"),1500);return}try{const u=rl(e,c,{inputPercent:i,outputPercent:o});u.success?(Z(`Updated key point ${l} to ${i.toFixed(1)}, ${o.toFixed(1)}`),zn(),ou(),t.classList.remove("border-red-300")):(t.classList.add("border-red-300"),Z(u.message||"Edit failed"),setTimeout(()=>t.classList.remove("border-red-300"),1500))}catch(u){console.warn("[EDIT MODE] XY input error:",u),t.classList.add("border-red-300"),Z("Edit error: "+u.message),setTimeout(()=>t.classList.remove("border-red-300"),1500)}}function pi(){const e=Mt.selectedChannel;if(!e||!Js(e)){const o=document.getElementById("editPointIndex");o&&(o.textContent="â€“",o.classList.add("is-disabled"));const s=document.getElementById("editXYInput");s&&(s.value="",s.disabled=!0);return}const{orderedPoints:t,sortedOrdinal:n,point:r}=yo(e);if(t.length===0||!r){const o=document.getElementById("editPointIndex");o&&(o.textContent="â€“",o.classList.add("is-disabled"));const s=document.getElementById("editXYInput");s&&(s.value="",s.disabled=!0);return}const i=document.getElementById("editPointIndex");i&&(i.textContent=String(n),i.classList.remove("is-disabled"));const a=document.getElementById("editXYInput");if(a){const o=Ea(e,r.output);a.value=`${r.input.toFixed(1)},${o.toFixed(1)}`,a.disabled=!1}}function pL(){if(Wh)return;Wh=!0;const e=document.getElementById("editRecomputeBtn");e&&e.addEventListener("click",uL);const t=document.getElementById("editChannelPrev");t&&t.addEventListener("click",()=>Xh(-1));const n=document.getElementById("editChannelNext");n&&n.addEventListener("click",()=>Xh(1));const r=document.getElementById("editPointLeft"),i=document.getElementById("editPointRight");r&&r.addEventListener("click",()=>Qh(-1)),i&&i.addEventListener("click",()=>Qh(1));const a=document.getElementById("editDeleteBtn");a&&a.addEventListener("click",dL);const o=document.getElementById("editXYInput");o&&(o.addEventListener("keypress",l=>{l.key==="Enter"&&Zh()}),o.addEventListener("blur",Zh));const s=(l,c,u)=>{l&&l.addEventListener("click",d=>{d.preventDefault(),nL(c,u,d)})};s(document.getElementById("editNudgeXNeg"),-1,0),s(document.getElementById("editNudgeXPos"),1,0),s(document.getElementById("editNudgeYUp"),0,1),s(document.getElementById("editNudgeYDown"),0,-1),console.log("âœ… Edit control handlers initialized")}function ou(){try{Je(),Pn(),Ur(Mt.selectedChannel)}catch(e){console.warn("[EDIT MODE] Chart/preview update failed:",e)}}Xe("editMode",{isEditModeEnabled:ht,setEditMode:ys,reinitializeChannelSmartCurves:Zs,EDIT:Mt,EDIT_STATE:Mt,refreshEditState:zn,updatePointDisplay:pi,edit_refreshPointIndex:pi,beginSmartPointDrag:nS,updateSmartPointDrag:rS,endSmartPointDrag:au,cancelSmartPointDrag:Bp,selectSmartPointOrdinal:Ss,isSmartPointDragActive:bs},{exposeOnWindow:!0,windowAliases:["isEditModeEnabled","setEditMode","reinitializeChannelSmartCurves","EDIT","refreshEditState","edit_refreshPointIndex","beginSmartPointDrag","updateSmartPointDrag","endSmartPointDrag","cancelSmartPointDrag","isSmartPointDragActive","selectSmartPointOrdinal"]});typeof window<"u"&&cS();const fL=0,uS=100,Jh=0,eg=100,dS=.01,mL=1e-6,hL=5,gL=1,bL=1e-4;function yL(e){return e&&Number.isFinite(e.input)&&Number.isFinite(e.output)}function SL(e){return{input:Number(e.input),output:Number(e.output)}}function vL(e){for(let t=1;t<e.length;t+=1)if(e[t].input<=e[t-1].input){const n=Math.min(uS,e[t-1].input+dS);e[t]={...e[t],input:n}}return e}function EL(e){for(let t=1;t<e.length;t+=1)e[t].output<e[t-1].output&&(e[t]={...e[t],output:e[t-1].output});return e}function Np(e,t={}){const n=t.enforceMonotonic!==!1;if(!Array.isArray(e)||e.length===0)return[];const r=e.filter(yL).map(a=>({input:Rr(a.input,fL,uS),output:Rr(a.output,Jh,eg)})).sort((a,o)=>a.input===o.input?a.output-o.output:a.input-o.input);if(r.length===0)return[];const i=[];for(const a of r){const o=i[i.length-1];if(o&&Math.abs(a.input-o.input)<=dS){const s=Math.max(o.output,a.output);i[i.length-1]={input:Number(o.input.toFixed(6)),output:Rr(s,Jh,eg)};continue}i.push(a)}return i.length===0?[]:(vL(i),n&&EL(i),i.map(a=>({input:Number(a.input.toFixed(6)),output:Number(a.output.toFixed(6))})))}function wL(e,t){const n=e&&typeof e=="object"?{...e}:{},r=Number(t);return!Number.isFinite(r)||r<=0||Math.abs(r-1)<=mL||("bakedGlobal"in n&&(n.bakedGlobal=!!n.bakedGlobal),Math.abs(r-1)*100-gL>bL&&("bakedAutoWhite"in n&&delete n.bakedAutoWhite,"bakedAutoBlack"in n&&delete n.bakedAutoBlack,"bakedAutoLimit"in n&&(n.bakedAutoLimit=!1))),n}function CL(e,t,n,r={}){const i={success:!1,channelName:e,points:[],metadata:{},warnings:[],scaleFactor:null},{points:a,metadata:o={},mode:s="preserveAbsolute"}=r;if(!e||typeof e!="string")return{...i,error:"channelName required"};if(!Array.isArray(a)||a.length<2)return{...i,error:"At least two key points are required"};const l=Number(t),c=Number(n);if(!Number.isFinite(l)||!Number.isFinite(c)||l<=0||c<0)return{...i,error:"Invalid percent values supplied to rescale"};if(l===0)return{...i,error:"Cannot rescale when previous percent is zero"};const d=Np(a,{enforceMonotonic:s!=="preserveRelative"});if(d.length<2)return{...i,error:"Normalized key points must contain at least two entries"};const p=c===0?0:c/l;i.scaleFactor=p;const f=[];let h;if(s==="preserveRelative")h=d.map(SL);else{const b=d.map(({input:y,output:v})=>p===0?{input:y,output:0}:{input:y,output:v*p}),S=Np(b,{enforceMonotonic:!0});if(S.length<2)return{...i,error:"Rescaled key points collapsed below minimum count"};let E=0;for(let y=0;y<Math.min(d.length,S.length);y+=1){const v=Math.abs(S[y].output-d[y].output);v>E&&(E=v)}p===0?f.push(`Channel ${e} scaled to zero percent ink limit.`):E>hL&&f.push(`Channel ${e} points shifted by ${E.toFixed(2)}%.`),h=S}const g=wL(o,p);return{success:!0,channelName:e,points:h,metadata:g,warnings:f,scaleFactor:p}}const Ot=typeof window<"u"?window:globalThis,oa=typeof document<"u",Go=(()=>{if(!oa)return null;if(Ot.__SMART_RESCALE_AUDIT)return Ot.__SMART_RESCALE_AUDIT;const e={enabled:!1,comparisons:0,lastDiff:null},t={enable(n=!0){e.enabled=!!n,e.enabled||t.resetMetrics()},disable(){t.enable(!1)},isEnabled(){return e.enabled},record(n){e.enabled&&(e.comparisons+=1,e.lastDiff=n||null)},resetMetrics(){e.comparisons=0,e.lastDiff=null},dumpMetrics(){return{enabled:e.enabled,comparisons:e.comparisons,lastDiff:e.lastDiff}}};return Ot.__SMART_RESCALE_AUDIT=t,t})();function hm(){try{if(_c())return!0;if(Ot&&typeof Ot.isActiveRangeLinearizationEnabled=="function")return!!Ot.isActiveRangeLinearizationEnabled()}catch(e){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Active-range flag probe failed:",e)}return!1}const vn={maxErrorPercent:.15,maxPoints:21},Sn={minGap:.01,yMin:0,yMax:100,defaultTolerance:1,endpointsLocked:!0,clampY(e){return Math.max(this.yMin,Math.min(this.yMax,e))},clampX(e){return Math.max(0,Math.min(100,e))}},pS=Ie-1;function su(e){if(typeof document>"u")return null;try{return document.querySelector(`tr[data-channel="${e}"]`)}catch{return null}}function rs(e){if(!Number.isFinite(e))return"0";const t=Math.round(e);if(Math.abs(e-t)<.05)return String(t);const n=Number(e.toFixed(1));return Math.abs(n-Math.round(n))<1e-6?String(Math.round(n)):n.toString()}function AL(e){if(!e)return 0;const t=e.getAttribute("data-base-percent"),n=t!==null?t:e.value;return q.clampPercent(n)}function ML(e){if(!e)return 0;const t=e.getAttribute("data-base-end"),n=t!==null?t:e.value;return q.clampEnd(n)}function gm(e,t,n={}){const r=Sn.clampY(Number(t)||0),{epsilonPercent:i=.05,emitStatus:a=!0,statusMessage:o=null,statusFormatter:s=null,lockedStatusMessage:l=null,lockedStatusFormatter:c=null,source:u=null}=n||{},d=Number.isFinite(i)?Math.max(0,i):.05;if(!oa)return{absolute:r,rescaleFactor:1,raised:!1,currentPercent:r};const p=su(e);if(!p)return{absolute:r,rescaleFactor:1,raised:!1,currentPercent:r};const f=p.querySelector(".percent-input"),h=p.querySelector(".end-input"),g=AL(f),b=ML(h);if(Nt(e)){if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[INK HELPER] channel locked, skipping raise",{channelName:e,currentPercent:g,desired:r}),a){let C=null;typeof c=="function"?C=c({channelName:e,currentPercent:g,desiredAbsolute:r,source:u}):typeof l=="string"&&l&&(C=l),C&&Z(C)}return{absolute:Math.min(r,g),rescaleFactor:1,raised:!1,locked:!0,currentPercent:g}}if(r<=g+d)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[INK HELPER] within current limit",{channelName:e,currentPercent:g,target:r}),{absolute:Math.min(r,g),rescaleFactor:1,raised:!1,currentPercent:g};const S=Math.min(100,Math.max(r,g));if(Math.abs(S-g)<d)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[INK HELPER] change below threshold",{channelName:e,currentPercent:g,newPercent:S,target:r}),{absolute:Math.min(r,S),rescaleFactor:1,raised:!1,currentPercent:g};const E=q.computeEndFromPercent(S),y=Math.round(q.clampEnd(E));if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[INK HELPER] raising limit",{channelName:e,previousPercent:g,newPercent:S,previousEnd:b,newEnd:y,target:r}),f&&(f.value=rs(S),f.setAttribute("data-base-percent",String(S))),h&&(h.value=String(y),h.setAttribute("data-base-end",String(y))),S>0&&p.hasAttribute("data-user-disabled")){p.removeAttribute("data-user-disabled");const C=p.querySelector("[data-disabled]");if(C&&C.classList.add("invisible"),p._virtualCheckbox)try{p._virtualCheckbox.checked=!0}catch(x){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Failed to sync virtual checkbox on auto-enable:",x)}}const v=$t(()=>({curves:{},baselineEnd:{},sources:{},keyPoints:{},keyPointsMeta:{},rebasedCurves:{},rebasedSources:{}}));v.baselineEnd=v.baselineEnd||{},v.baselineEnd[e]=y;const A=at?.();A&&(A.setChannelValue(e,"percentage",S),A.setChannelValue(e,"endValue",y),A.setChannelEnabled(e,y>0||S>0)),Zl(e,{percent:S,endValue:y}),gi(e),Er();const w=Ft?.();if(w&&typeof w.recordChannelAction=="function")try{w.recordChannelAction(e,"percentage",g,S),w.recordChannelAction(e,"endValue",b,y)}catch(C){console.warn("[SMART CURVES] Failed to record ink-limit history:",C)}let M=null;if(typeof s=="function")try{M=s({channelName:e,previousPercent:g,newPercent:S,desiredAbsolute:r,source:u})}catch(C){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[INK HELPER] statusFormatter failed:",C),M=null}else typeof o=="string"&&o&&(M=o);M||(M=`${e} ink limit changed to ${rs(S)}%`),a&&M&&Z(M);const I=g>1e-6&&S>1e-6?g/S:1;return{absolute:Math.min(r,S),rescaleFactor:I,raised:!0,currentPercent:g,previousPercent:g,newPercent:S,previousEnd:b,newEnd:y,message:M,source:u}}function LL(e){if(!Array.isArray(e)||e.length!==2)return!1;const[t,n]=e,r=a=>Math.abs(Number(a)||0)<=1e-4,i=a=>Math.abs((Number(a)||0)-100)<=1e-4;return r(t?.input)&&r(t?.output)&&i(n?.input)&&i(n?.output)}function el(e){if(typeof document>"u")return 100;const n=su(e)?.querySelector(".percent-input");if(!n)return 100;const r=n.getAttribute("data-base-percent"),i=q.clampPercent(r!==null?r:n.value);return Number.isFinite(i)&&i>0?i:100}function Ea(e,t){const n=el(e);if(!Number.isFinite(n)||n<=0)return Sn.clampY(t);const r=t/100*n;return Sn.clampY(r)}function vs(e,t){const n=el(e);if(!Number.isFinite(n)||n<=0)return Math.max(0,t);const r=n===0?0:t/n*100;return Math.max(0,r)}const Te={get(e){const t=Ee(),n=t?.keyPoints?.[e]||null,r=t?.keyPointsMeta?.[e]?.interpolationType||"smooth";return{points:n?n.map(i=>({input:i.input,output:i.output})):null,interpolation:r}},normalize(e){if(!Array.isArray(e))return[];const t=e.map(n=>({input:Sn.clampX(Number(n.input)),output:Math.max(0,Number(n.output))}));t.sort((n,r)=>n.input-r.input);for(let n=1;n<t.length;n++)t[n].input<=t[n-1].input&&(t[n].input=Math.min(100,t[n-1].input+Sn.minGap));return t},persist(e,t,n="smooth"){const r=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{}}));r.keyPoints||(r.keyPoints={}),r.keyPointsMeta||(r.keyPointsMeta={}),r.keyPoints[e]=t.map(a=>({input:a.input,output:a.output}));const i=r.keyPointsMeta[e]||{};r.keyPointsMeta[e]={...i,interpolationType:n==="linear"?"linear":"smooth"},hm()?r.keyPointsMeta[e].activeRangeLinearized=!0:r.keyPointsMeta[e].activeRangeLinearized&&delete r.keyPointsMeta[e].activeRangeLinearized},sampleY(e,t,n){if(!Array.isArray(e)||e.length===0)return 0;const r=e.map(o=>o.input),i=e.map(o=>o.output),a=Sn.clampX(n);if(t==="linear"){if(a<=r[0])return i[0];if(a>=r[r.length-1])return i[i.length-1];let o=0;for(;o<r.length-1&&r[o+1]<a;)o++;const s=r[o],l=r[o+1],c=i[o],u=i[o+1],d=(a-s)/(l-s);return c+d*(u-c)}else try{return zr(r,i)(a)}catch(o){return console.warn("PCHIP interpolation failed, falling back to linear:",o),this.sampleY(e,"linear",n)}},nearestIndex(e,t,n=Sn.defaultTolerance){const r=Sn.clampX(t);let i={index:-1,delta:1/0,input:0};return e.forEach((a,o)=>{const s=Math.abs(a.input-r);s<i.delta&&(i={index:o,delta:s,input:a.input})}),i.delta<=n?i:{index:-1,delta:1/0,input:0}}};function lu(e){return e==="smart"||e==="ai"}function Ni(e){try{const t=Ee()?.sources?.[e];return lu(t)}catch{return!1}}function IL(e,t="smooth",n=Ie){if(!Array.isArray(e)||e.length<2)return Mf(n,0,100);const r=Te.normalize(e),i=new Array(n);for(let a=0;a<n;a++){const o=a/(n-1)*100;i[a]=Te.sampleY(r,t,o)}return i}function kL(e,t,n){const r=n.x-t.x,i=n.y-t.y;if(r===0&&i===0){const a=e.x-t.x,o=e.y-t.y;return Math.hypot(a,o)}return Math.abs(i*e.x-r*e.y+n.x*t.y-n.y*t.x)/Math.hypot(r,i)}function tg(e,t){const n=new Array(e.length).fill(!1);n[0]=!0,n[e.length-1]=!0,(function i(a,o){if(o<=a+1)return;const s=e[a],l=e[o];let c=-1,u=-1;for(let d=a+1;d<o;d++){const p=kL(e[d],s,l);p>c&&(c=p,u=d)}c>t&&(n[u]=!0,i(a,u),i(u,o))})(0,e.length-1);const r=[];for(let i=0;i<e.length;i++)n[i]&&r.push(e[i]);return r}function Ar(e,t={}){const n=typeof t.minErrorPercent=="number"?Math.max(5e-4,t.minErrorPercent):5e-4,r=Math.max(n,Math.min(5,t.maxErrorPercent||vn.maxErrorPercent||1)),i=Math.max(2,Math.min(64,t.maxPoints||vn.maxPoints||21)),a=Math.max(1,t.scaleMax||ve);if(!Array.isArray(e)||e.length<2)return[{input:0,output:0},{input:100,output:100}];const o=e.length,s=Math.max(0,...e);if(s<=0)return[{input:0,output:0},{input:100,output:100}];const l=new Array(o);for(let b=0;b<o;b++){const S=b/(o-1)*100,E=s>0?e[b]/a:0,y=Math.max(0,Math.min(100,E*100));l[b]={x:S,y}}const c=.002,u=[];for(let b=0;b<=10;b++)u.push(Math.round((o-1)*(b/10)));if(u.every(b=>{const S=b/(o-1),E=e[b]/s;return Math.abs(E-S)<=c}))return[{input:0,output:0},{input:100,output:100}];let p=r,f=tg(l,p),h=0;for(;f.length>i&&h<8;)p*=1.3,f=tg(l,p),h+=1;let g=f.map(b=>({input:b.x,output:b.y}));if(g.length>i){const b=g.length-1,S=[],E=b/(i-1),y=new Set;for(let v=0;v<i;v+=1){const A=Math.round(v*E),w=Math.max(0,Math.min(b,A));y.has(w)||(S.push(g[w]),y.add(w))}S.length<2&&S.push(g[b]),g=S}return Te.normalize(g)}function tl(e,t,n,r={}){if(e&&Nt(e))return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SMART CURVES] Rescale skipped for locked channel",e),!1;if(!Ni(e)||!Number.isFinite(t)||!Number.isFinite(n)||t<=0||n<0)return!1;const{points:i,interpolation:a}=Te.get(e);if(!i||i.length===0)return!1;const o=r.mode==="preserveRelative"?"preserveRelative":"preserveAbsolute",s=i.map(b=>({input:b.input,output:b.output})),l=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{}}));l.keyPointsMeta=l.keyPointsMeta||{};const c=l.keyPointsMeta[e]?{...l.keyPointsMeta[e]}:{},u=CL(e,t,n,{points:s,metadata:c,mode:o});if(!u||!u.success)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Rescale service failed",{channelName:e,fromPercent:t,toPercent:n,mode:o,error:u?.error||"unknown"}),!1;let d=null;if(Go&&typeof Go.isEnabled=="function"&&Go.isEnabled()&&o!=="preserveRelative"){const b=t===0||n===0?0:n/t,S=s.map(w=>({input:w.input,output:b===0?0:Math.min(100,w.output*b)})),E=Np(S),y=u.points||[],v=Math.min(E.length,y.length);let A=0;for(let w=0;w<v;w+=1){const M=Math.abs((y[w]?.output??0)-(E[w]?.output??0));M>A&&(A=M)}d={channelName:e,fromPercent:t,toPercent:n,mode:o,scaleFactor:b,maxDelta:A,legacyPoints:E,servicePoints:y,lengthMismatch:E.length!==y.length},typeof Go.record=="function"&&Go.record(d),A>.05&&typeof console<"u"&&console.warn("[SMART CURVES][AUDIT] Legacy vs service rescale delta > 0.05%",d)}const p={rescaledFromPercent:t,rescaledToPercent:n,rescaleMode:o,...r.historyExtras||{}};Array.isArray(u.warnings)&&u.warnings.length>0&&(p.rescaleWarnings=u.warnings.slice(),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Rescale warnings",{channelName:e,warnings:u.warnings}));const f={allowWhenEditModeOff:!0,skipUiRefresh:!!r.skipUiRefresh,skipHistory:!!r.skipHistory,bakedFlags:u.metadata||c,historyExtras:p},h=Gi(e,u.points||s,a,f),g=!!h?.success;return!g&&typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Failed to persist rescaled key points",{channelName:e,applyResult:h}),g&&typeof DEBUG_LOGS<"u"&&DEBUG_LOGS?console.log("[SMART CURVES] Rescale applied",{channelName:e,fromPercent:t,toPercent:n,mode:o,warnings:u.warnings,audit:d}):d&&typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SMART CURVES][AUDIT] Rescale evaluated without apply success",d),g}function nl(e=0,t=100){return[{input:0,output:e},{input:100,output:t}]}function fS(e){if(!Array.isArray(e))return{valid:!1,message:"Key points must be an array"};if(e.length<2)return{valid:!1,message:"At least 2 key points required"};for(let t=0;t<e.length;t++){const n=e[t];if(!n||typeof n!="object")return{valid:!1,message:`Point ${t} is not an object`};if(typeof n.input!="number"||typeof n.output!="number")return{valid:!1,message:`Point ${t} must have numeric input and output`};if(!isFinite(n.input)||!isFinite(n.output))return{valid:!1,message:`Point ${t} has non-finite values`};if(n.input<0||n.input>100||n.output<0||n.output>100)return{valid:!1,message:`Point ${t} values outside 0-100 range`}}return{valid:!0,message:"Key points are valid"}}function DL(){const e=Ee();if(!e?.sources)return;const t=e.sources;for(const[n,r]of Object.entries(t))r==="ai"&&(t[n]="smart")}function mS(e,t="smooth"){try{const n=Te.get(e).points;if(n&&n.length>=2)return{success:!0};const a=Array.from(m.rows?.children||[]).find(u=>u.getAttribute("data-channel")===e)?.querySelector(".end-input"),o=a?q.clampEnd(a.value):65535,s=o>0?o:65535,l=Yt(s,e,!0,{normalizeToEnd:Hr(e)}),c=Ar(l,{maxErrorPercent:vn.maxErrorPercent,maxPoints:vn.maxPoints});return c.length<2?{success:!1,message:"Failed to generate Smart key points from curve"}:(Te.persist(e,c,t),{success:!0})}catch(n){return console.warn(`Error ensuring Smart key points for ${e}:`,n),{success:!1,message:`Error creating Smart key points: ${n.message}`}}}function rl(e,t,n={}){if(!e||typeof t!="number"||t<1)return{success:!1,message:"Invalid channel name or ordinal"};let{points:r,interpolation:i}=Te.get(e);if(!r||r.length<2){const k=mS(e,"smooth");if(!k.success)return{success:!1,message:k.message||`No Smart key points stored for ${e}.`};({points:r,interpolation:i}=Te.get(e))}if(t>r.length)return{success:!1,message:`Invalid ordinal ${t}. Valid range: 1..${r.length}`};const a=r.map(k=>({input:k.input,output:k.output})),o=Ft?.();let s=null;if(!n.skipHistory&&o&&typeof o.beginTransaction=="function")try{s=o.beginTransaction(`Adjust ${e} key point`)}catch(k){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Failed to start history transaction:",k),s=null}const c=t-1,u=a[c],d=Ea(e,u.output);let p=u.input,f=d;typeof n.inputPercent=="number"&&(p=n.inputPercent),typeof n.deltaInput=="number"&&(p+=n.deltaInput),typeof n.outputPercent=="number"&&(f=n.outputPercent),typeof n.deltaOutput=="number"&&(f+=n.deltaOutput),f=Sn.clampY(f);const h=Di(e,f);h.clamped&&(f=h.value);const g=gm(e,f),b=Number.isFinite(g?.absolute)?g.absolute:f,S=Number.isFinite(g?.rescaleFactor)?g.rescaleFactor:1;if(S!==1)for(let k=0;k<a.length;k+=1)k!==c&&(a[k].output=Math.max(0,a[k].output*S));const E=vs(e,b);f=b;const y=Sn.minGap,v=c>0?a[c-1].input:0,A=c<a.length-1?a[c+1].input:100,w=c===0?0:v+y,M=c===a.length-1?100:A-y;p=Math.max(w,Math.min(M,p)),a[c]={input:p,output:E};let I=Te.normalize(a);Nt(e)&&(I=I.map(k=>{const N=Ea(e,k.output),F=Di(e,N);if(F.clamped){const U=vs(e,F.value);return{input:k.input,output:Math.max(0,U)}}return k})),Te.persist(e,I,i),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SMART CURVES] adjustSmartKeyPointByIndex normalized points",{channelName:e,ordinal:t,interpType:i,newInput:p,newOutput:E,pointCount:I.length});const _=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{}}));_.curves||(_.curves={});const C=el(e),x=new Array(Ie);for(let k=0;k<Ie;k++){const N=k/pS*100,F=Te.sampleY(I,i,N),j=Math.max(0,F)/100*C,B=Di(e,j);x[k]=Math.round(B.value/100*ve)}_.curves[e]=x,_.sources||(_.sources={}),_.sources[e]="smart",typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SMART CURVES] persisted samples after adjust",{channelName:e,first:x[0],mid:x[128],last:x[255]}),BS();const P={success:!0,message:`Adjusted key point ${t} for ${e}`,channelName:e,ordinal:t,newPoint:{input:p,output:f}};if(s&&o&&typeof o.commit=="function")try{o.commit(s)}catch(k){console.warn("[SMART CURVES] Failed to commit history transaction:",k)}return P}function bm(e,t,n=null){if(!e||typeof t!="number")return{success:!1,message:"Invalid channel name or input percentage"};if(Nt(e))return{success:!1,message:Vi(e,"inserting points")};const r=Sn.clampX(t);let{points:i,interpolation:a}=Te.get(e);if(!i||i.length<2){const v=mS(e,"smooth");if(!v.success)return{success:!1,message:v.message||`No Smart key points stored for ${e}.`};({points:i,interpolation:a}=Te.get(e))}if(Te.nearestIndex(i,r,.5).index!==-1)return{success:!1,message:`A key point already exists near ${r}%`};const s=i.map(v=>({input:v.input,output:v.output}));s.sort((v,A)=>v.input-A.input);const l=Ft?.();let c=null;if(l&&typeof l.beginTransaction=="function")try{c=l.beginTransaction(`Insert point ${e}`)}catch(v){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Failed to start history transaction for insert:",v),c=null}let u,d=1;if(n==null){const v=Te.sampleY(s,a,r);u=Sn.clampY(Ea(e,v))}else{const v=Sn.clampY(n),A=Di(e,v),w=gm(e,A.value);if(u=Number.isFinite(w?.absolute)?w.absolute:A.value,d=Number.isFinite(w?.rescaleFactor)?w.rescaleFactor:1,d!==1)for(let M=0;M<s.length;M+=1)s[M].output=Math.max(0,s[M].output*d)}const p=Di(e,u);p.clamped&&(u=p.value);const f=vs(e,u),h=Math.max(0,f);let g=0;for(;g<s.length&&s[g].input<r;)g++;const b=Sn.minGap,S=g>0?s[g-1]:null,E=g<s.length?s[g]:null;if(S&&r-S.input<b)return{success:!1,message:`Too close to existing point at ${S.input}%`};if(E&&E.input-r<b)return{success:!1,message:`Too close to existing point at ${E.input}%`};s.splice(g,0,{input:r,output:h});const y=Gi(e,s,a,{historyExtras:{insertedPoint:{input:r,outputAbsolute:u,outputRelative:h},insertedIndex:g+1,selectedOrdinalAfter:g+1}});if(!y.success){if(c&&l&&typeof l.rollback=="function")try{l.rollback(c)}catch(v){console.warn("[SMART CURVES] Failed to rollback history transaction for insert:",v)}return y}if(c&&l&&typeof l.commit=="function")try{l.commit(c)}catch(v){console.warn("[SMART CURVES] Failed to commit history transaction for insert:",v)}return{...y,message:`Inserted key point at ${r}% for ${e}`,channelName:e,insertIndex:g+1,newPoint:{input:r,output:u}}}function ym(e,t,n={}){if(!e||typeof t!="number"||t<1)return{success:!1,message:"Invalid channel name or ordinal"};if(Nt(e))return{success:!1,message:Vi(e,"deleting points")};const{points:r,interpolation:i}=Te.get(e);if(!r||r.length<2)return{success:!1,message:`No Smart key points exist for ${e}`};if(t>r.length)return{success:!1,message:`Invalid ordinal ${t}. Valid range: 1..${r.length}`};if(r.length<=2)return{success:!1,message:"Cannot delete - at least 2 key points required"};const a=t-1;if((a===0||a===r.length-1)&&!n.allowEndpoint)return{success:!1,message:"Cannot delete endpoint - set allowEndpoint=true to override"};const s=r.map(d=>({input:d.input,output:d.output})),l=s[a];s.splice(a,1);const c=Math.max(1,Math.min(t,s.length)),u=Gi(e,s,i,{historyExtras:{deletedOrdinal:t,deletedPoint:l,selectedOrdinalAfter:c}});return u.success?{...u,message:`Deleted key point ${t} from ${e}`,deletedOrdinal:t,deletedPoint:l}:u}function Fi(e,t={}){if(!e)return{success:!1,message:"Channel name required"};const n=Math.max(5e-4,Math.min(5,t.maxErrorPercent||vn.maxErrorPercent)),r=Math.max(2,Math.min(64,t.maxPoints||vn.maxPoints));try{if(typeof ht=="function"&&!ht())return{success:!1,message:"Edit mode is off â€” enable Edit Curves to edit."};if(typeof Yt!="function"){console.warn(`[RECOMPUTE] ${e}: make256 not available, using linear fallback`);const w=Mf(Ie,0,ve),M=Ar(w,{maxErrorPercent:n,maxPoints:f});return Fp(e,M,"smooth")}const i=su(e),a=i?q.clampEnd(i.querySelector(".end-input")?.value||ve):ve,o=Yt(a,e,!0,{normalizeToEnd:Hr(e)}),l=Ee()?.keyPointsMeta?.[e]?.measurementSeed||null,c=!!l&&(Array.isArray(l.points)&&l.points.length>=2||Number.isFinite(Number(l.count))&&Number(l.count)>=2),u=t?.allowMeasurementResimplify===!0;if(c&&!u)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SMART CURVES] Skipping simplification for measurement-seeded channel",e),{success:!0,message:"Measurement-seeded Smart curve preserved"};const d=Number.isFinite(Number(l?.count))?Math.max(0,Math.floor(Number(l.count))):Array.isArray(l?.points)?l.points.length:0,p=Number.isFinite(Number(t.minPoints))?Math.max(2,Math.floor(Number(t.minPoints))):0,f=r,h=Math.min(f,Math.max(p,d>=2?d:0));let g=Ar(o,{maxErrorPercent:n,maxPoints:f});if(h>=2&&g.length<h){let w=Math.max(.01,n/2),M=g;for(;w>=5e-4;){const I=Ar(o,{maxErrorPercent:w,maxPoints:f});if(I.length>=h){M=I;break}if(I.length>M.length&&(M=I),I.length>=h||w<=.001)break;w=Math.max(5e-4,w/2)}if(M.length>=h)g=M;else{const I=[],_=o.length-1;if(_>=1)for(let C=0;C<h;C+=1){const x=h===1?0:C/(h-1),P=x*_,k=Math.floor(P),N=Math.min(_,Math.ceil(P)),F=P-k,U=o[k]??0,j=o[N]??U,B=(1-F)*U+F*j,G=x*100,V=ve>0?B/ve*100:0,K=Math.max(0,Math.min(100,V));I.push({input:G,output:K})}else I.push({input:0,output:0},{input:100,output:100});g=Te.normalize(I)}}if(!g||g.length<2)return{success:!1,message:"Failed to generate sufficient key points"};const b=g.map(w=>({input:Number(w.input),output:vs(e,Number(w.output))})),S=Fp(e,b,"smooth",{historyExtras:{recomputeAbsolutePoints:g.map(w=>({input:Number(w.input),output:Number(w.output)}))}});if(!S.success)return S;const E=!!m?.autoWhiteLimitToggle?.checked,y=!!m?.autoBlackLimitToggle?.checked,v=!!(D.globalApplied&&D.getGlobalData()),A=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{}}));if(A.keyPointsMeta=A.keyPointsMeta||{},A.keyPointsMeta[e]={...A.keyPointsMeta[e]||{},bakedGlobal:v,bakedAutoLimit:E||y,bakedAutoWhite:E,bakedAutoBlack:y},hm()?A.keyPointsMeta[e].activeRangeLinearized=!0:A.keyPointsMeta[e].activeRangeLinearized&&delete A.keyPointsMeta[e].activeRangeLinearized,v){const w=Ft?.();if(w&&Array.isArray(w.history))try{for(let M=w.history.length-1;M>=0;M--){const I=w.history[M];if(I&&I.kind==="channel"){const _=I.action;if(_&&_.type==="curve"&&_.channelName===e){_.newBakedGlobal=!0;break}}}}catch(M){console.warn("[SMART CURVES] Failed to annotate history bakedGlobal flag:",M)}}return{...S,message:`Recomputed ${S.keyPointCount} key points for ${e}`}}catch(i){return{success:!1,message:`Recompute failed: ${i.message}`}}}function PL(e,t,n,r=null){if(!e||typeof t!="number"||typeof n!="number")return{success:!1,message:"Invalid parameters"};if(Nt(e))return{success:!1,message:Vi(e,"inserting points")};const{points:i,interpolation:a}=Te.get(e);if(!i||i.length<2)return{success:!1,message:`No Smart key points exist for ${e}`};if(t<1||n<1||t>i.length||n>i.length)return{success:!1,message:"Invalid ordinals"};if(Math.abs(n-t)!==1)return{success:!1,message:"Ordinals must be adjacent"};const o=Math.min(t,n)-1,s=Math.max(t,n)-1,l=i[o],c=i[s],u=(l.input+c.input)/2;return bm(e,u,r)}function Fp(e,t,n="smooth",r={}){if(!oa)return{success:!1,message:"Window context unavailable"};let i=Te.normalize(t);if(Nt(e)&&(i=i.map(C=>{const x=Ea(e,C.output),P=Di(e,x);if(P.clamped){const k=vs(e,P.value);return{input:C.input,output:Math.max(0,k)}}return C})),i.length<2)return{success:!1,message:"At least 2 key points are required"};const a=$t(()=>({curves:{},keyPoints:{},keyPointsMeta:{},sources:{}}));a.curves=a.curves||{},a.keyPoints=a.keyPoints||{},a.keyPointsMeta=a.keyPointsMeta||{},a.sources=a.sources||{};const o=n==="linear"?"linear":"smooth",s=a.curves[e]?a.curves[e].slice():null,l=a.keyPoints[e]?a.keyPoints[e].map(C=>({input:C.input,output:C.output})):null,c=a.keyPointsMeta[e]?.interpolationType||"smooth",u=a.sources[e]||null,d=Ft?.(),p=!!r.skipHistory,f=oa&&Ot.EDIT&&Ot.EDIT.selectedChannel===e&&Ot.EDIT.selectedOrdinal||1;if(!p&&d&&typeof d.recordKeyPointsChange=="function")try{d.recordKeyPointsChange(e,l,i.map(C=>({input:C.input,output:C.output})),c,o)}catch(C){console.warn("[SMART CURVES] recordKeyPointsChange failed:",C)}const h=typeof ht=="function"?ht():!1,g=LL(i);if(!(r.forcePersistDefaultRamp===!0)&&!h&&g)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SMART CURVES] Skipped default ramp persistence (edit mode off)",{channelName:e,pointCount:i.length}),{success:!0,message:"Default ramp ignored while edit mode is off",channelName:e,keyPointCount:i.length,interpolation:o,skipped:!0};Te.persist(e,i,o),a.keyPoints[e]=i.map(C=>({input:C.input,output:C.output}));const S=r.includeBakedFlags!==!1,E=S?r.bakedFlags||{}:{},y=a.keyPointsMeta[e]||{},v=r.smartTouched!==void 0?r.smartTouched:!0,A={...y,interpolationType:o};S?Object.assign(A,E):(delete A.bakedGlobal,delete A.bakedFilename,delete A.bakedAutoLimit,delete A.bakedAutoWhite,delete A.bakedAutoBlack),v?A.smartTouched=!0:"smartTouched"in A&&delete A.smartTouched,hm()?A.activeRangeLinearized=!0:"activeRangeLinearized"in A&&delete A.activeRangeLinearized,a.keyPointsMeta[e]=A;const w=el(e),M=new Array(Ie);for(let C=0;C<Ie;C++){const x=C/pS*100,P=Te.sampleY(i,o,x),N=Math.max(0,P)/100*w,U=Di(e,N).value;M[C]=Math.round(U/100*ve)}if(a.curves[e]=M.slice(),a.sources[e]="smart",hS(e,M),!p&&d&&typeof d.recordChannelAction=="function")try{const C={oldKeyPoints:l,newKeyPoints:i.map(x=>({input:x.input,output:x.output})),oldInterpolation:c,newInterpolation:o,oldSource:u,newSource:"smart",selectedOrdinalBefore:f,selectedChannelBefore:oa&&Ot.EDIT?Ot.EDIT.selectedChannel:null};if(r.historyExtras&&typeof r.historyExtras=="object"&&Object.assign(C,r.historyExtras),C.selectedOrdinalAfter===void 0){const x=Math.max(1,Math.min(f,i.length));C.selectedOrdinalAfter=x}C.selectedChannelAfter===void 0&&oa&&Ot.EDIT&&(C.selectedChannelAfter=Ot.EDIT.selectedChannel),d.recordChannelAction(e,"curve",s,M.slice(),C)}catch(C){console.warn("[SMART CURVES] recordChannelAction failed:",C)}if(!!!r.skipMarkEdited)try{Hb(e)}catch(C){console.warn("[SMART CURVES] markLinearizationEdited failed:",C)}try{const C=gt();if(C.perChannelEnabled&&Object.prototype.hasOwnProperty.call(C.perChannelEnabled,e)){const P={...C.perChannelEnabled,[e]:!1};nt({perChannelEnabled:P})}if(D&&typeof D.setPerChannelData=="function"){const P=D.getPerChannelData(e);P&&D.setPerChannelData(e,P,!1)}const x=su(e);if(x){const P=x.querySelector(".per-channel-toggle");P&&(P.disabled=!0,P.checked=!1)}}catch(C){console.warn("[SMART CURVES] Failed to update per-channel toggle state:",C)}if(!!!r.skipUiRefresh)try{Pn(),Ur(e),Je(),Er()}catch(C){console.warn("[SMART CURVES] UI refresh failed:",C)}return Ot.invalidateMake256Cache?.(),{success:!0,message:`Set ${i.length} key points for ${e}`,channelName:e,keyPointCount:i.length,keyPoints:i.map(C=>({input:C.input,output:C.output})),curve:M}}function Gi(e,t,n="smooth",r={}){if(!e)return{success:!1,message:"Channel name required"};const i=fS(t);return i.valid?typeof ht=="function"&&!r.allowWhenEditModeOff&&!ht()?{success:!1,message:"Edit mode is off â€” enable Edit Curves to edit."}:Fp(e,t,n,r):{success:!1,message:i.message}}oa&&(Ot.isSmartCurve=Ni,Ot.ControlPoints=Te,Ot.KP_SIMPLIFY=vn,Ot.adjustSmartKeyPointByIndex=rl,Ot.insertSmartKeyPointAt=bm,Ot.deleteSmartKeyPointByIndex=ym,Ot.simplifySmartKeyPointsFromCurve=Fi,Ot.insertSmartKeyPointBetween=PL,Ot.setSmartKeyPoints=Gi,Ot.rescaleSmartCurveForInkLimit=tl);function hS(e,t){try{const n=$t(()=>({}));if(!n||!e||!Array.isArray(t))return;const r=t.slice(),i=r.reduce((o,s)=>s>o?s:o,0);n.plotBaseCurves=n.plotBaseCurves&&typeof n.plotBaseCurves=="object"?n.plotBaseCurves:{},n._plotSmoothingOriginalCurves=n._plotSmoothingOriginalCurves&&typeof n._plotSmoothingOriginalCurves=="object"?n._plotSmoothingOriginalCurves:{},n._plotSmoothingBaselineCurves=n._plotSmoothingBaselineCurves&&typeof n._plotSmoothingBaselineCurves=="object"?n._plotSmoothingBaselineCurves:{},n._plotSmoothingOriginalEnds=n._plotSmoothingOriginalEnds&&typeof n._plotSmoothingOriginalEnds=="object"?n._plotSmoothingOriginalEnds:{},n.baselineEnd=n.baselineEnd&&typeof n.baselineEnd=="object"?n.baselineEnd:{},n.rebasedCurves=n.rebasedCurves&&typeof n.rebasedCurves=="object"?n.rebasedCurves:{},n.rebasedSources=n.rebasedSources&&typeof n.rebasedSources=="object"?n.rebasedSources:{},n.plotBaseCurves[e]=r.slice(),n._plotSmoothingOriginalCurves[e]=r.slice(),n._plotSmoothingBaselineCurves[e]=r.slice(),n._plotSmoothingOriginalEnds[e]=i,n.baselineEnd[e]=i,n.rebasedCurves[e]=r.slice(),n.rebasedSources[e]=r.slice(),(!n._zeroSmoothingCurves||typeof n._zeroSmoothingCurves!="object")&&(n._zeroSmoothingCurves={});const a=typeof lo=="function"?Number(lo()):0;!Number.isFinite(a)||a<=0?n._zeroSmoothingCurves[e]=r.slice():Array.isArray(n._zeroSmoothingCurves[e])||(n._zeroSmoothingCurves[e]=r.slice())}catch(n){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[SMART CURVES] Failed to refresh plot smoothing snapshots:",n)}}function cu(e,t={}){if(!e)return{success:!1,reason:"invalid_channel"};const n=$t(()=>({curves:{},sources:{}}));if(!n)return{success:!1,reason:"no_data"};const{points:r=null,interpolation:i=null,skipPlotSmoothingRefresh:a=!1}=t||{},o=Te.get(e),s=Array.isArray(r)&&r.length>=2?r:o.points;if(!s||s.length<2)return{success:!1,reason:"no_points"};const l=typeof i=="string"?i:o.interpolation||"smooth",c=Te.normalize(s),u=el(e),d=new Array(Ie);for(let p=0;p<Ie;p+=1){const f=p/(Ie-1)*100,h=Te.sampleY(c,l,f),g=Math.max(0,h)/100*u,b=Di(e,g),S=Number.isFinite(b?.value)?b.value:g;d[p]=Math.round(S/100*ve)}return(!n.curves||typeof n.curves!="object")&&(n.curves={}),n.curves[e]=d.slice(),(!n.sources||typeof n.sources!="object")&&(n.sources={}),n.sources[e]="smart",a||hS(e,d),{success:!0,samples:d}}const $l=typeof globalThis<"u"?globalThis:{},Vl="__debugMake256Steps";function xL(){return $l[Vl]||($l[Vl]={}),$l[Vl]}function ba(e,t,n){if(!e||!t||!Array.isArray(n))return;const r=xL();r[e]||(r[e]={}),r[e][t]=n.slice(0,16)}function BL(e){const t=$l[Vl];return t&&t[e]||null}Xe("debugMake256",{captureMake256Step:ba,getMake256Debug:BL},{exposeOnWindow:typeof window<"u",windowAliases:["__debugGetMake256Steps"]});const gS=Object.freeze({limitProximityPct:3,slopeAbsolutePct:.45,sustainSamples:3,minWidthPct:8,blackShoulderScanStartPct:80,whiteToeScanEndPct:22,fallbackPlateauPct:3});class TL{constructor(){this.overrides=null}getDefault(t){return gS[t]}getNumber(t){if(this.overrides&&this.overrides.hasOwnProperty(t)){const n=this.overrides[t];if(typeof n=="number"&&Number.isFinite(n))return n}return this.getDefault(t)}setOverrides(t){if(!t||typeof t!="object"){this.overrides=null;return}const n={},r=(i,a,o)=>Math.max(a,Math.min(o,i));Object.keys(t).forEach(i=>{const a=t[i];if(a==null||a==="")return;let o=Number(a);if(Number.isFinite(o)){switch(i){case"limitProximityPct":o=r(o,.5,20);break;case"slopeAbsolutePct":o=r(o,.01,20);break;case"sustainSamples":o=Math.round(Math.min(64,Math.max(1,o)));break;case"minWidthPct":o=r(o,1,50);break;case"blackShoulderScanStartPct":o=r(o,50,95);break;case"whiteToeScanEndPct":o=r(o,5,50);break;case"fallbackPlateauPct":o=r(o,1,20);break;default:return}n[i]=o}}),this.overrides=Object.keys(n).length>0?n:null}clearOverrides(){this.overrides=null}}const jr=new TL,OL=wa();OL.AUTO_LIMIT_CONFIG=jr;ri({AUTO_LIMIT_CONFIG:jr});Xe("autoLimitConfig",{AUTO_LIMIT_CONFIG:jr,AUTO_LIMIT_DEFAULTS:gS},{exposeOnWindow:typeof window<"u",windowAliases:["AUTO_LIMIT_CONFIG"]});const _L={};function ng(){return typeof globalThis<"u"?globalThis:typeof window<"u"?window:_L}class NL{constructor(){this.scope=ng()}getScope(){const t=ng();return t!==this.scope&&(this.scope=t),this.scope}getGlobalData(){return this.getScope().linearizationData||null}setGlobalData(t){const n=this.getScope();n.linearizationData=t||null}getGlobalApplied(){return this.getScope().linearizationApplied===!0}setGlobalApplied(t){const n=this.getScope();n.linearizationApplied=t===!0}setGlobalState(t,n){this.setGlobalData(t),typeof n<"u"&&this.setGlobalApplied(n)}getPerChannelData(t){return t&&this.getScope().perChannelLinearization?.[t]||null}setPerChannelData(t,n){if(!t)return;const r=this.getScope(),i=r.perChannelLinearization||{};if(!n){if(i[t]){const a={...i};delete a[t],r.perChannelLinearization=a}return}r.perChannelLinearization={...i,[t]:n}}isPerChannelEnabled(t){return t?this.getScope().perChannelEnabled?.[t]===!0:!1}setPerChannelEnabled(t,n){if(!t)return;const r=this.getScope(),i=r.perChannelEnabled||{};if(!n&&i[t]){const a={...i};delete a[t],r.perChannelEnabled=a;return}r.perChannelEnabled={...i,[t]:n===!0}}setPerChannelBatch({data:t={},enabled:n={}}={}){const r=this.getScope();r.perChannelLinearization={...t},r.perChannelEnabled={...n}}}let dd=null;function bS(){return dd||(dd=new NL),dd}const Es={lastRun:null},FL=.005,GL=.003,RL=.01,Gp=1e-6;function yl(e){return Es.lastRun={...e||{},timestamp:Date.now()},Es.lastRun}function rg(e=[]){const t=new Set,n=[];return e.forEach(r=>{if(typeof r!="string")return;const i=r.trim().toUpperCase();!i||t.has(i)||(t.add(i),n.push(i))}),n}function zL(e="global",t=null){if(e==="channel"&&t)return rg([t]);const n=[],r=typeof lt=="function"?lt():null;return r&&Array.isArray(r.channels)&&n.push(...r.channels),!n.length&&typeof document<"u"&&document.querySelectorAll("tr[data-channel]").forEach(i=>{const a=i.getAttribute("data-channel");a&&n.push(a)}),rg(n)}function UL(e){if(!e||typeof e!="object")return[];const t=[],n=r=>{Array.isArray(r)&&r.length>0&&t.push(r)};return n(e.samples),n(e.previewSamples),n(e.originalSamples),n(e.originalData),t}function $L(){try{const e=typeof globalThis<"u"?globalThis:window;if(!e)return null;if(typeof e.getCompositeCoverageSummary=="function")return e.getCompositeCoverageSummary();if(e.LinearizationState&&typeof e.LinearizationState.getCompositeCoverageSummary=="function")return e.LinearizationState.getCompositeCoverageSummary()}catch(e){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[auto-raise] failed to read coverage summary:",e)}return null}function VL(e,t){if(!e||typeof e!="object"||!t)return null;if(e[t])return e[t];const n=t.toUpperCase();if(e[n])return e[n];const r=t.toLowerCase();return e[r]?e[r]:null}function yS(e){if(!e||typeof e!="object")return{headroom:Number.POSITIVE_INFINITY,bufferedLimit:null,maxNormalized:null,limit:null};const t=Number.isFinite(e.bufferedLimit)?e.bufferedLimit:Number.isFinite(e.limit)?e.limit:null,n=Number.isFinite(e.maxNormalized)?e.maxNormalized:0,r=t!=null?Math.max(0,t-n):Number.POSITIVE_INFINITY,i=Number.isFinite(e.limit)?e.limit:t;return{headroom:r,bufferedLimit:t,maxNormalized:n,limit:i}}function HL(e,t,n){if(!e||typeof e!="object")return!1;const r=Object.keys(e);if(!r.length)return!1;const i=Number.isFinite(n)?n:1;return r.some(a=>{if(typeof a!="string"||a===t||a.toUpperCase()===t.toUpperCase())return!1;const o=e[a];if(!o||typeof o!="object")return!1;const{headroom:s,bufferedLimit:l}=yS(o);return!Number.isFinite(s)||s<=GL+Gp?!1:l==null?!0:l+RL+Gp>=i})}function qL(e,t,n){const r=Number.isFinite(n)?n:1,i=VL(e,t);if(!i)return{allowRaise:!0,reason:"no-coverage-data",entrySnapshot:null};const a=yS(i),o={limit:a.limit,bufferedLimit:a.bufferedLimit,maxNormalized:a.maxNormalized,headroom:a.headroom};return Number.isFinite(a.headroom)?a.headroom>FL+Gp?{allowRaise:!1,reason:"coverage-available",entrySnapshot:o}:HL(e,t,r)?{allowRaise:!1,reason:"handoff-available",entrySnapshot:o}:{allowRaise:!0,reason:"coverage-exhausted",entrySnapshot:o}:{allowRaise:!0,reason:"no-coverage-data",entrySnapshot:o}}function SS(e){const t=UL(e);if(!t.length)return 0;let n=0;return t.forEach(r=>{r.forEach(i=>{const a=Number(i);Number.isFinite(a)&&(n=Math.max(n,a))})}),!Number.isFinite(n)||n<=0?0:n>100?100:n>1.0001?Math.min(100,n):Math.min(100,n*100)}function Rp(){return Es.lastRun?{...Es.lastRun}:null}function jL(){Es.lastRun=null}function Ri(e,t={}){const n=Rs(),r=typeof document<"u",i={scope:t.scope==="channel"?"channel":"global",channelName:t.channelName||null,label:t.label||"correction",source:t.source||"correction-import"},a={enabled:n,inBrowser:r,adjustments:[],blocked:[],evaluated:!1,targetPercent:0,context:i};if(!n||!r)return yl(a),a;const o=SS(e);if(a.evaluated=!0,a.targetPercent=o,!Number.isFinite(o)||o<=0)return yl(a),a;const s=zL(i.scope,i.channelName);if(!s.length)return yl(a),a;const l=typeof Ee=="function"?Ee():null,c=l?.baselineEnd||{},u=l?.curves||{};let d={};try{const w=typeof at=="function"?at():null;w&&typeof w.get=="function"&&(d=w.get("printer.channelValues")||{})}catch{d={}}const p=w=>typeof w=="string"?w.trim().toUpperCase():"",f=typeof DEBUG_LOGS<"u"&&DEBUG_LOGS;f&&(console.log("[auto-raise] channel state snapshot",d),console.log("[auto-raise] baseline map",c));const h=new Set;Object.entries(c).forEach(([w,M])=>{const I=p(w),_=Number(M);!I||!Number.isFinite(_)||_<=0||h.add(I)});const g=new Set;Object.entries(u).forEach(([w,M])=>{const I=p(w);if(!I||!Array.isArray(M))return;M.some(C=>{const x=Number(C);return Number.isFinite(x)&&x>0})&&g.add(I)});const b={};Object.entries(d).forEach(([w,M])=>{const I=p(w);I&&(b[I]=M)});const S=w=>{const M=p(w);if(!M)return!1;if(h.has(M)||g.has(M))return!0;const I=d?.[w]||b[M]||d?.[M];if(I&&typeof I=="object"){const _=Number(I.percentage),C=Number(I.endValue);if(Number.isFinite(_)&&_>0||Number.isFinite(C)&&C>0)return!0}return!1},E=Number.isFinite(t.epsilonPercent)?Math.max(0,t.epsilonPercent):.05,y=$L(),v=Number.isFinite(o)?Math.max(0,Math.min(1,o/100)):null;y&&typeof y=="object"&&(a.coverageSummary=y),s.forEach(w=>{const M=p(w),I=d?.[w]||b[M]||d?.[M],_=S(w);if(f&&console.log("[auto-raise] channel baseline check",w,{hasBaseline:_,baseline:Number(c?.[w])||0,statePercent:Number(I?.percentage)||0,stateEnd:Number(I?.endValue)||0}),!_){const U=I&&Number.isFinite(Number(I.percentage))?Number(I.percentage):0;f&&console.log("[auto-raise] skip disabled channel",w,{currentPercent:U,baseline:Number(c?.[w])||0}),a.blocked.push({channelName:w,currentPercent:U,desiredPercent:o,reason:"disabled-channel",coverage:null});return}if(f){const U=Number(c?.[w])||0,j=Number(I?.percentage)||0,B=Number(I?.endValue)||0;console.log("[auto-raise] evaluating channel",w,{baseline:U,percent:j,endValue:B})}const C=qL(y,w,v),x=C.entrySnapshot||null;if(!C.allowRaise){const U=Number(I?.percentage);Number.isFinite(U)&&Number.isFinite(o)&&U+E<o&&(C.allowRaise=!0,C.reason="end-limited")}if(!C.allowRaise){a.blocked.push({channelName:w,currentPercent:null,desiredPercent:o,reason:C.reason,coverage:x});return}const P=t.notifyLocked===!1?null:({currentPercent:U})=>`${w} ink limit locked at ${rs(U??0)}% â€” auto-raise skipped (${i.label} peaks at ${rs(o)}%)`,k=gm(w,o,{epsilonPercent:E,statusFormatter:({newPercent:U})=>`${w} ink limit changed to ${rs(U)}% (auto-raised for ${i.label})`,lockedStatusFormatter:P,emitStatus:t.emitStatus!==!1,source:i.source});if(!k)return;const N=C.reason==="no-coverage-data"?"end-limited":C.reason;if(k.raised){a.adjustments.push({channelName:w,previousPercent:Number.isFinite(k.previousPercent)?k.previousPercent:Number.isFinite(k.currentPercent)?k.currentPercent:null,newPercent:Number.isFinite(k.newPercent)?k.newPercent:Number.isFinite(k.currentPercent)?k.currentPercent:null,desiredPercent:o,absoluteTarget:Number.isFinite(k.absolute)?k.absolute:o,previousEnd:Number.isFinite(k.previousEnd)?k.previousEnd:null,newEnd:Number.isFinite(k.newEnd)?k.newEnd:null,raised:!0,source:i.source,reason:N,coverage:x});return}if(k.locked){const U=Number.isFinite(k.currentPercent)?k.currentPercent:Number.isFinite(k.previousPercent)?k.previousPercent:null;a.blocked.push({channelName:w,currentPercent:U,desiredPercent:o,reason:"locked",coverage:x});return}const F=N==="end-limited"?"within-limit":N;F!=="within-limit"&&a.blocked.push({channelName:w,currentPercent:Number.isFinite(k.currentPercent)?k.currentPercent:null,desiredPercent:o,reason:F,coverage:x})});const A=[];return a.adjustments.forEach(w=>{A.push({channel:w.channelName,previousPercent:w.previousPercent,newPercent:w.newPercent,desiredPercent:Number.isFinite(w.desiredPercent)?w.desiredPercent:a.targetPercent,locked:!1,currentPercent:w.newPercent,reason:w.reason||null,coverage:w.coverage||null})}),a.blocked.forEach(w=>{A.push({channel:w.channelName,previousPercent:w.currentPercent,newPercent:w.currentPercent,desiredPercent:w.desiredPercent??a.targetPercent,locked:w.reason==="locked",currentPercent:w.currentPercent,reason:w.reason||null,coverage:w.coverage||null})}),jy(A,{label:i.label,source:i.source,targetPercent:a.targetPercent,evaluated:a.evaluated,timestamp:Date.now()}),yl(a),a}Xe("autoRaiseInkLimits",{getAutoRaiseAuditState:Rp,clearAutoRaiseAuditState:jL,computeAutoRaiseTargetPercent:SS,maybeAutoRaiseInkLimits:Ri},{exposeOnWindow:typeof window<"u",windowAliases:["getAutoRaiseAuditState","computeAutoRaiseTargetPercent"]});const et={ISOLATED:"isolated",NORMALIZED:"normalized",MOMENTUM:"momentum",EQUAL:"equal"},vS="quadgen.compositeWeightingMode",lc=new Set;function WL(){if(typeof window>"u"||!window.localStorage)return null;try{const e=window.localStorage.getItem(vS);return e&&Object.values(et).includes(e)?e:null}catch(e){return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CompositeSettings] Failed to read weighting mode from storage:",e),null}}function KL(e){if(!(typeof window>"u"||!window.localStorage))try{window.localStorage.setItem(vS,e)}catch(t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CompositeSettings] Failed to persist weighting mode:",t)}}let Zi=WL()||et.NORMALIZED;function uu(){return Zi}function ES(e){const t=Object.values(et).includes(e)?e:et.NORMALIZED;return t===Zi||(Zi=t,KL(Zi),YL()),Zi}function wS(e){return typeof e!="function"?()=>{}:(lc.add(e),()=>{lc.delete(e)})}function YL(){lc.size&&lc.forEach(e=>{try{e(Zi)}catch(t){console.warn("[CompositeSettings] subscriber failed:",t)}})}Xe("compositeSettings",{getCompositeWeightingMode:uu,setCompositeWeightingMode:ES,subscribeCompositeWeightingMode:wS,modes:{...et}},{exposeOnWindow:typeof window<"u"});const XL=2,QL=1;function ZL(e,t){const n=Math.max(0,Math.floor(Number.isFinite(e)?e:XL)),r=Number.isFinite(t)&&t>0?t:n>0?n/1.5:QL,i=[];let a=0;for(let o=-n;o<=n;o+=1){const s=Math.exp(-(o*o)/(2*r*r));i.push(s),a+=s}return a<=0?{kernel:[1],radius:0}:{kernel:i.map(o=>o/a),radius:n}}function JL(e){const t=e.length,n=new Array(t).fill(0);if(!t)return n;if(t===1)return n[0]=0,n;for(let r=0;r<t;r+=1)r===0?n[r]=e[1]-e[0]:n[r]=e[r]-e[r-1];return n[t-1]=e[t-1]-e[t-2],n}function eI(e,t){return e.length?t<=0?e[0]:t>=e.length?e[e.length-1]:e[t]:0}function tI(e,t={}){if(!Array.isArray(e)||!e.length)return[];const n=e.map(c=>ce(Number.isFinite(c)?c:0)),r=JL(n),{kernel:i,radius:a}=ZL(t.windowRadius,t.sigma),o=n.length,s=new Array(o).fill(0);for(let c=0;c<o;c+=1){let u=0;for(let d=-a;d<=a;d+=1){const p=i[d+a],f=eI(r,c+d);u+=p*Math.abs(f)}s[c]=u}const l=s.reduce((c,u)=>u>c?u:c,0);return l<=0?s.fill(0):s.map(c=>ce(c/l))}function nI(e,t,n={}){if(!Array.isArray(e)||e.length===0||!(Number.isFinite(t)&&t>0))return new Array(Array.isArray(e)?e.length:0).fill(0);const r=e.map(i=>ce((Number(i)||0)/t));return tI(r,n)}const jo=1e-9;function wi(e){return!Number.isFinite(e)||e<=0?0:e>=1?1:e}function CS(e,t){return Array.isArray(e)&&e.length?e.slice():Array.isArray(t)&&t.length?t.slice():t&&typeof t=="object"?Object.keys(t):[]}function rI(e,t){if(!Array.isArray(e)||!e.length)return null;const n=e.length;if(n===1)return[wi(e[0])];const r=e.map(l=>wi(l)),i=wi(e[0]),a=wi(e[n-1]);r[0]=i,r[n-1]=a;const o=Math.max(0,t-1e-4),s=Math.max(2,n*3);for(let l=0;l<s;l+=1){let c=!1;for(let u=1;u<n;u+=1){const d=r[u-1],p=d+o,f=d-o;r[u]>p+jo?(r[u]=p,c=!0):r[u]<f-jo&&(r[u]=f,c=!0)}r[n-1]=a;for(let u=n-2;u>=0;u-=1){const d=r[u+1],p=d+o,f=d-o;r[u]>p+jo?(r[u]=p,c=!0):r[u]<f-jo&&(r[u]=f,c=!0)}if(r[0]=i,!c)break}for(let l=0;l<n;l+=1)r[l]=wi(r[l]);return r}function iI(e,{channelNames:t=null,endValues:n=null,thresholdPercent:r=Pi}={}){if(!e||typeof e!="object")return{};const i=Number.isFinite(r)&&r>0?r/100:Pi/100;if(i<=jo)return{};const a=CS(t,e),o=n&&typeof n=="object"?n:{},s={};return a.forEach(l=>{const c=e[l];if(!Array.isArray(c)||!c.length)return;const u=Number(o[l]),d=Number.isFinite(u)&&u>0?u:0;if(d<=0)return;const p=c.map(h=>{const g=Number(h),b=d>0?g/d:0;return wi(b)}),f=rI(p,i);if(f){for(let h=0;h<c.length;h+=1){const g=wi(f[h]),b=Math.round(g*d),S=Math.max(0,Math.min(d,b));c[h]=S,f[h]=d>0?S/d:0}s[l]=f}}),s}function aI(e,{channelNames:t=null,normalizedSeriesByChannel:n=null,correctedCurves:r=null,endValues:i=null,densityWeights:a=null}={}){if(!Array.isArray(e)||!e.length||!n||typeof n!="object")return;const o=CS(t,n);if(!o.length)return;const s=i&&typeof i=="object"?i:{},l=r&&typeof r=="object"?r:{},c=a instanceof Map?a:a&&typeof a=="object"?new Map(Object.entries(a)):new Map;e.forEach((u,d)=>{if(!u||typeof u!="object"||!u.perChannel||typeof u.perChannel!="object")return;let p=0,f=0;const h=new Map;o.forEach(b=>{const S=u.perChannel[b],E=n[b],y=l[b],v=Number(s[b]),A=Number.isFinite(v)&&v>0?v:0;if(!S||!Array.isArray(E)||E.length<=d||A<=0)return;const w=wi(E[d]),M=Array.isArray(y)&&y.length>d?Math.max(0,Number(y[d])||0):Math.max(0,Math.round(w*A)),I=Number(S.baselineValue)||0,_=Number(S.normalizedBefore)||0,C=Number.isFinite(S.weight)?S.weight:c.get(b)||0,x=Number(S.densityContributionBefore)||0,P=C*w;S.correctedValue=M,S.valueDelta=M-I,S.normalizedAfter=w,S.normalizedDelta=w-_,S.densityContributionAfter=P,S.densityContributionDelta=P-x,p+=M,f+=P,h.set(b,P)}),(p>0||f>0)&&o.forEach(b=>{const S=u.perChannel[b];if(!S)return;const E=Number(S.correctedValue)||0,y=h.has(b)?h.get(b):Number(S.densityContributionAfter)||0;S.shareAfter=p>0?E/p:0,S.densityShareAfter=f>0?y/f:0}),u.correctedInk=p;const g=Number(u.baselineInk)||0;u.inkDelta=p-g})}const tn=1e-9,AS=4,ig=10,ag=.25,oI=.6,sI=.04,zp=1e-4,Ro=1e-6,lI=.95,og=3,cI=.02;let cc=null;function vo(e){return!Number.isFinite(e)||e<=0?0:e>=1?1:e}function uI(e,t){return Array.isArray(e)&&e.length?e.slice():Array.isArray(t)&&t.length?t.slice():t&&typeof t=="object"?Object.keys(t):[]}function dI(e,...t){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SLOPE_KERNEL]",e,...t)}function pI(e,t){const n=new Map;return!Array.isArray(e)||!e.length||!Array.isArray(t)||!t.length||(t.forEach(r=>{n.set(r,new Array(e.length).fill(!1))}),e.forEach((r,i)=>{if(!r||typeof r!="object")return;const a=r.perChannel||{};t.forEach(o=>{const s=n.get(o);if(!s||i>=s.length)return;const l=a[o];if(!l){s[i]=!0;return}const c=l.blendLimited===!0,u=l.reserveState,d=Number(l.reserveAllowanceRemaining),p=Number(l.headroomAfter),f=Number(l.pendingBlendCap),h=Number(l.allowedNormalized),g=Number(l.normalizedAfter),b=l.enabled===!1||l.disabled===!0,S=Number.isFinite(f)&&Number.isFinite(h)&&Number.isFinite(g)&&f<=h+tn&&g>=f-tn&&g<=f+cI,E=u==="exhausted"||Number.isFinite(d)&&d<=tn,y=Number.isFinite(p)&&p<=tn;(c||E||y||S||b)&&(s[i]=!0)})})),n}function fI(e){let t=0;if(!Array.isArray(e)||e.length<2)return t;for(let n=1;n<e.length;n+=1){const r=e[n-1],i=e[n],a=Math.abs(i-r);a>t&&(t=a)}return t}function Up(e,t,n){if(!Array.isArray(e)||t>=n)return 0;let r=0;for(let i=t+1;i<=n;i+=1){const a=Math.abs(e[i]-e[i-1]);a>r&&(r=a)}return r}function mI(e,t,n){if(!Array.isArray(e)||e.length===0)return!0;const r=e[t],a=e[n]>=r?1:-1;for(let o=t+1;o<=n;o+=1)if(a>=0){if(e[o]+tn<e[o-1])return!1}else if(e[o]>e[o-1]+tn)return!1;return!0}function hI(e){if(!Array.isArray(e)||e.length===0)return[];const t=e.filter(r=>r&&Number.isFinite(r.start)&&Number.isFinite(r.end)).map(r=>({start:Math.max(0,Math.floor(r.start)),end:Math.max(0,Math.floor(r.end))})).sort((r,i)=>r.start-i.start);if(!t.length)return[];const n=[t[0]];for(let r=1;r<t.length;r+=1){const i=t[r],a=n[n.length-1];i.start<=a.end+1?a.end=Math.max(a.end,i.end):n.push({...i})}return n}function gI(e,t){if(!Array.isArray(e)||e.length<2)return[];const n=Math.max(t*lI,t-.02),r=[];let i=null,a=null,o=0,s=!1;const l=()=>{if(i===null||a===null){i=null,a=null,o=0,s=!1;return}const c=a-i;if(s||o>=og||c>=og){const d=Up(e,i,a);(s||d>=n-tn)&&r.push({start:i,end:a})}i=null,a=null,o=0,s=!1};for(let c=1;c<e.length;c+=1){const u=e[c]-e[c-1],d=Math.abs(u);if(d>t+tn){i===null&&(i=c-1),a=c,s=!0,o+=1;continue}d>=n-tn?(i===null&&(i=c-1),a=c,o+=1):l()}return l(),hI(r)}function bI(e,t,n){if(!Array.isArray(e))return!1;for(let r=t;r<=n;r+=1)if(e[r])return!0;return!1}function yI(e,t,n){if(!Array.isArray(n)||e>=t)return{start:e,end:t};let r=e,i=t;for(;r<i&&n[r];)r+=1;for(;r<i&&n[i];)i-=1;return i-r+1<AS||bI(n,r,i)?null:{start:r,end:i}}function SI(e,t,n,r,i=null){let a=!1;const o=Math.max(r-zp,r*.95),s=t-1;if(s>=0&&s<e.length){const c=e[s];let u=e[t];if(Number.isFinite(c)&&Number.isFinite(u)){const d=u-c;if(Math.abs(d)>o+tn){const p=d>=0?1:-1,f=c+p*o;e[t]=vo(f),i&&(i.startExternalClamp=!0),a=!0}}}const l=n+1;if(l>=0&&l<e.length){const c=e[l];let u=e[n];if(Number.isFinite(c)&&Number.isFinite(u)){const d=c-u;if(Math.abs(d)>o+tn){const p=d>=0?1:-1,f=c-p*o;e[n]=vo(f),i&&(i.endExternalClamp=!0),a=!0}}}return a}function vI(e){if(!Number.isFinite(e)||e<=0)return null;const t=(e-1)/2,n=Math.max(1.1,e*.35),r=[];let i=0;for(let a=0;a<e;a+=1){const o=a-t,s=Math.exp(-(o*o/(2*n*n)));Number.isFinite(s)&&(r.push(s),i+=s)}return r.length!==e||i<=tn?null:r.map(a=>a/i)}function EI(e){if(!Number.isFinite(e)||e<=0)return null;const t=[];let n=0;for(let r=0;r<e;r+=1){const i=(r+.5)/e,a=.5*(1-Math.cos(Math.PI*i));Number.isFinite(a)&&(t.push(a),n+=a)}return t.length!==e||n<=tn?null:t.map(r=>r/n)}function wI(e){if(e<=0)return null;const t=vI(e);return Array.isArray(t)?t:EI(e)}function CI(e,t,n){if(!Array.isArray(e)||e.length===0)return null;if(!Number.isFinite(t)||t<=tn)return e;if(!Number.isFinite(n)||n<=tn)return null;const r=n/t;if(!Number.isFinite(r)||r<=Ro)return null;if(e.reduce((f,h)=>h>f?h:f,0)<=r+Ro)return e;const a=e.length,o=1/a;if(o>r+Ro)return null;const s=new Array(a).fill(o);let l=0,c=1,u=s.slice();for(let f=0;f<24;f+=1){const h=(l+c)/2,g=e.map((S,E)=>s[E]*(1-h)+S*h);g.reduce((S,E)=>E>S?E:S,0)>r+Ro?c=h:(u=g,l=h)}if(u.reduce((f,h)=>h>f?h:f,0)>r+Ro)return null;const p=u.reduce((f,h)=>f+h,0);return p<=tn?null:u.map(f=>f/p)}function pd(e,t,n,r){const i=n-t;if(i<1)return!1;const a=wI(i);if(!Array.isArray(a)||a.length!==i)return!1;const o=e[t],s=e[n],l=s-o;if(Math.abs(l)<=tn)return!0;const c=CI(a,Math.abs(l),r);if(!c)return!1;const u=e.slice();let d=o;for(let p=0;p<i;p+=1){d+=l*c[p];const f=t+p+1;if(f>=n)break;u[f]=vo(d)}if(u[t]=o,u[n]=s,!mI(u,t,n))return!1;for(let p=t+1;p<n;p+=1)e[p]=u[p];return!0}function AI(e,t,n){if(!e)return null;let r=e.start,i=e.end,a=ig;for(;a>0&&r>0;){const s=r-1;if(n&&n[s])break;r=s,a-=1}let o=ig;for(;o>0&&i<t-1;){const s=i+1;if(n&&n[s])break;i=s,o-=1}if(i-r+1<AS)return null;if(n){const s=yI(r,i,n);if(!s)return null;r=s.start,i=s.end}return{start:r,end:i}}function sg(e,t,n){if(!Array.isArray(e)||n<0||n>=e.length)return null;const r=e[t],i=e[n];if(!Number.isFinite(r)||!Number.isFinite(i))return null;const a=(1-ag)*r+ag*i;return vo(a)}function MI(e,t,n,r){if(!Array.isArray(e)||e.length<3)return{series:e?e.slice():[],applied:!1,requiresLimiter:!0};const i=e.slice();let a=!1,o=!0;const s=gI(e,t);return s.length?(s.forEach(l=>{const c=AI(l,i.length,n);if(!c){r.windows.push({start:l.start,end:l.end,skipped:!0,reason:"locked-or-small"});return}const{start:u,end:d}=c,p=i.slice(u,d+1),f={start:u,end:d,deltaBefore:fI(p),passesApplied:0,fallback:!1},h=sg(i,u,u+1);h!==null&&(i[u]=h,f.startBlended=!0);const g=sg(i,d,d-1);g!==null&&(i[d]=g,f.endBlended=!0);let b=!1;pd(i,u,d,t)&&(f.passesApplied+=1,b=!0);const E=Math.min(t*oI,sI);if(b&&E>tn&&(pd(i,u,d,E)?f.passesApplied+=1:dI("secondary pass aborted",{start:u,end:d})),!f.passesApplied){for(let v=0;v<p.length;v+=1)i[u+v]=p[v];f.reverted=!0,f.deltaAfter=f.deltaBefore,r.windows.push(f);return}const y=Up(i,u,d);if(f.deltaAfter=y,a=!0,y>t+zp?f.fallback=!0:o=!1,SI(i,u,d,t,f)){pd(i,u,d,t)&&(f.passesApplied+=1,f.postClampPass=!0);const A=Up(i,Math.max(0,u-1),Math.min(i.length-1,d+1));f.deltaAfter=A,A<=t+zp?o=!1:f.fallback=!0}r.windows.push(f)}),a||(o=!0),{series:i,applied:a,requiresLimiter:o}):{series:i,applied:!1,requiresLimiter:!0}}function LI(e,{channelNames:t=null,endValues:n=null,thresholdPercent:r=Pi,debugSnapshots:i=null}={}){if(!e||typeof e!="object")return{normalizedSeriesByChannel:{},appliedChannels:[],channelsNeedingLimiter:[],stats:null};const a=Number.isFinite(r)&&r>0?r/100:Pi/100;if(a<=tn)return{normalizedSeriesByChannel:{},appliedChannels:[],channelsNeedingLimiter:[],stats:null};const o=uI(t,e);if(!o.length)return{normalizedSeriesByChannel:{},appliedChannels:[],channelsNeedingLimiter:[],stats:null};const s=n&&typeof n=="object"?n:{},l=pI(i,o),c={},u=[],d=[],p={guardThreshold:a,channels:{}};return o.forEach(f=>{const h=e[f];if(!Array.isArray(h)||!h.length)return;const g=Number(s[f]),b=Number.isFinite(g)&&g>0?g:0;if(b<=0)return;const S=h.map(w=>{const M=Number(w)||0;return vo(b>0?M/b:0)}),E={windows:[]};p.channels[f]=E;const{series:y,applied:v,requiresLimiter:A}=MI(S,a,l.get(f)||null,E);if(!Array.isArray(y)||!y.length){A&&d.push(f);return}v&&u.push(f),A&&d.push(f);for(let w=0;w<h.length&&w<y.length;w+=1){const M=vo(y[w]),I=Math.round(M*b),_=Math.max(0,Math.min(b,I));h[w]=_}c[f]=y.slice()}),cc={timestamp:Date.now(),...p},{normalizedSeriesByChannel:c,appliedChannels:u,channelsNeedingLimiter:d,stats:cc}}function lg(){return cc?JSON.parse(JSON.stringify(cc)):null}Xe("slopeKernel",{getSnapshotSlopeKernelStats:lg,getSlopeKernelStats:()=>lg()},{exposeOnWindow:typeof window<"u",windowAliases:["getSlopeKernelStats"]});const Qe=typeof globalThis<"u"?globalThis:{},Sl=.45,cg=.2,II=.05,kI=20;let uc=!1;function DI(e){uc=!!e,console.log(`[LUT] Legacy mapping mode ${uc?"enabled":"disabled"}`)}function PI(){return uc}function Ra(e){if(!e)return 0;const t=Number.isFinite(e.headroomNormalized)?Math.max(0,e.headroomNormalized):0,n=Number.isFinite(e.frontReserveBase)?Math.max(0,e.frontReserveBase):0,r=Number.isFinite(e.frontReserveApplied)?Math.max(0,e.frontReserveApplied):0,i=Math.max(0,n-r);return Math.max(0,t-i)}function Ba(e,{coverageCapacity:t=Number.POSITIVE_INFINITY,effectiveHeadroom:n=Number.POSITIVE_INFINITY,endCapacity:r=Number.POSITIVE_INFINITY}={}){if(!e)return 0;const i=Number.isFinite(t)?Math.max(0,t):Number.POSITIVE_INFINITY,a=Number.isFinite(n)?Math.max(0,n):Number.isFinite(e?.effectiveHeadroomNormalized)?Math.max(0,e.effectiveHeadroomNormalized):Ra(e),o=Number.isFinite(r)?Math.max(0,r):Number.isFinite(e?.headroomNormalized)?Math.max(0,e.headroomNormalized):Number.POSITIVE_INFINITY,s=Math.min(i,a,o);if(!Number.isFinite(s)){const l=Math.min(a,o);return Number.isFinite(l)?Math.max(0,l):0}return Math.max(0,s)}function xI(){const e=Qe&&typeof Qe=="object"?Qe.__COMPOSITE_AUDIT__:null;if(!e||e.enabled===!1)return null;const t=Number.isFinite(e?.sampleIndex)?Math.max(0,Math.floor(e.sampleIndex)):242;return Array.isArray(e.events)||(e.events=[]),{index:t,events:e.events,log:typeof e?.log=="function"?e.log:(n,r)=>{try{console.log("[COMPOSITE_AUDIT]",n,r)}catch{}}}}function za(e,t){try{const n=xI();if(!n)return;const r=typeof t=="function"?t(n.index):t;if(r==null)return;n.log(e,r),Array.isArray(n.events)&&n.events.push({stage:e,payload:r,ts:Date.now()})}catch(n){console.warn("[COMPOSITE_AUDIT] emit failed:",n)}}function qn(e){if(!e)return{};if(e instanceof Map){const t={};return e.forEach((n,r)=>{const i=Number(n);Number.isFinite(i)&&(t[r]=i)}),t}if(typeof e=="object"){const t={};return Object.keys(e).forEach(n=>{const r=Number(e[n]);Number.isFinite(r)&&(t[n]=r)}),t}return{}}function _a(e){if(!e||typeof e!="object")return{};const t={};return Object.keys(e).forEach(n=>{const r=e[n];if(!r||typeof r!="object")return;const i=Array.isArray(r.clampedSamples)?r.clampedSamples.map(a=>!a||typeof a!="object"?null:{index:Number.isInteger(a.index)?a.index:null,inputPercent:Number.isFinite(a.inputPercent)?a.inputPercent:null,normalizedBefore:Number.isFinite(a.normalizedBefore)?a.normalizedBefore:null,normalizedAfter:Number.isFinite(a.normalizedAfter)?a.normalizedAfter:null,desiredNormalizedAfter:Number.isFinite(a.desiredNormalizedAfter)?a.desiredNormalizedAfter:null,overflowNormalized:Number.isFinite(a.overflowNormalized)?a.overflowNormalized:0,bufferedLimit:Number.isFinite(a.bufferedLimit)?a.bufferedLimit:null,limit:Number.isFinite(a.limit)?a.limit:null,truncatedByThreshold:a.truncatedByThreshold===!0,truncatedByEnd:a.truncatedByEnd===!0,truncatedByBlend:a.truncatedByBlend===!0}).filter(Boolean):[];t[n]={limit:Number.isFinite(r.limit)?Number(r.limit):0,buffer:Number.isFinite(r.buffer)?Number(r.buffer):0,bufferedLimit:Number.isFinite(r.bufferedLimit)?Number(r.bufferedLimit):0,maxNormalized:Number.isFinite(r.maxNormalized)?Number(r.maxNormalized):0,overflow:Number.isFinite(r.overflow)?Number(r.overflow):i.length,overflowNormalized:Number.isFinite(r.overflowNormalized)?Number(r.overflowNormalized):0,clampedSamples:i}}),t}function MS(e,{coverageLimits:t,coverageBuffers:n,coverageThresholds:r,coverageUsage:i,coverageClampEvents:a}){const o=new Map,s={};return e.forEach(l=>{const c=Math.max(0,t?.get?.(l)||0),u=n?.get?.(l)||0,d=r?.get?.(l),p=Number.isFinite(d)?d:c+u,f=i?.get?.(l),h=a?.get?.(l)||[],g=Number.isFinite(f)?Math.max(0,Math.min(f,Number.isFinite(p)?p:Math.max(f,0))):0,b=h.reduce((y,v)=>{const A=Number(v?.overflowNormalized);return Number.isFinite(A)?y+Math.max(0,A):y},0),S=h.map(y=>{const v=Number.isInteger(y?.index)?y.index:null,A=Number(y?.inputPercent),w=Number.isFinite(A)?A:v!=null?v/(Ie-1)*100:null;return{index:v,inputPercent:w,normalizedBefore:Number.isFinite(y?.normalizedBefore)?y.normalizedBefore:null,normalizedAfter:Number.isFinite(y?.normalizedAfter)?y.normalizedAfter:null,desiredNormalizedAfter:Number.isFinite(y?.desiredNormalizedAfter)?y.desiredNormalizedAfter:null,overflowNormalized:Number.isFinite(y?.overflowNormalized)?y.overflowNormalized:0,bufferedLimit:Number.isFinite(y?.bufferedLimit)?y.bufferedLimit:null,limit:Number.isFinite(y?.limit)?y.limit:null,truncatedByThreshold:y?.truncatedByThreshold===!0,truncatedByEnd:y?.truncatedByEnd===!0}}),E={limit:c,buffer:u,bufferedLimit:p,maxNormalized:g,overflow:h.length,overflowNormalized:b,clampedSamples:S};o.set(l,E),s[l]={...E}}),{map:o,plain:s}}function fd(){return O.ladderBlendTracker instanceof Map||(O.ladderBlendTracker=new Map),O.ladderBlendTracker}function BI(){O.ladderBlendTracker instanceof Map?O.ladderBlendTracker.clear():O.ladderBlendTracker=new Map}function ug(){return O.shadowBlendTracker instanceof Map||(O.shadowBlendTracker=new Map),O.shadowBlendTracker}function dg(){O.shadowBlendTracker instanceof Map?O.shadowBlendTracker.clear():O.shadowBlendTracker=new Map}function TI(){return O.frontReservePeaks instanceof Map||(O.frontReservePeaks=new Map),O.frontReservePeaks}function pg(){O.frontReservePeaks instanceof Map?O.frontReservePeaks.clear():O.frontReservePeaks=new Map}function OI(e=0){const t=Math.max(0,Math.min(e,jn-1)),n=LS*(t+1);return Math.min(ZI,n)}function fg(e){if(!e)return{state:"exhausted",allowance:0};const t=Number.isFinite(e.frontReserveBase)?Math.max(0,e.frontReserveBase):0,n=Number.isFinite(e.headroomNormalized)?Math.max(0,e.headroomNormalized):0,r=Number.isFinite(e.frontReserveApplied)?Math.max(0,e.frontReserveApplied):0,i=Math.max(0,t-r),a=Math.max(0,Ra(e)),o=Math.max(H,t*rk);let s;t<=H?s=n>H?"approaching":"exhausted":n<=H||a<=H&&n<=o+H?s="exhausted":n<=t+H?s="within":s="approaching";let l=0;if(s==="approaching"&&n>t){const c=Math.max(0,n-t),u=Math.max(H,t*ak);l=Math.min(c,u)}else if(s==="within"){const c=Math.max(H,Math.min(i,t)),u=t>H?Math.max(0,Math.min(1,n/t)):0,d=Math.max(H,t*ik),p=u*c;l=Math.min(d,p,n)}return{state:s,allowance:Math.max(0,l)}}const mg=bS();function _I(e){return typeof document>"u"?null:document.querySelector(`tr[data-channel="${e}"]`)}const bt=Ie-1,NI=.995,FI=1e-4,GI=.9,RI=.2,Ta=.01,H=1e-6,zI=8,hg=.12,UI=.005,$I=4,vl=.1,El=3,gg=.08,bg=.32,yg=5e-4,VI=.015,Sg=.05,HI=.15,qI=3,jI=1.25,WI=1.5,KI=.02,md=.035,hd=.1,vg=.2,Eg=9,YI=1,XI=.9,QI=.005,wl=.005,jn=4,LS=8e-4,ZI=.008,$p=1e-4,JI=.4,Ki=6,wg=.01,ek=.02,tk=.0025,nk=.45,rk=.25,ik=.35,ak=.15,ok={CURVE_RESOLUTION:Ie,TOTAL:ve,N:Ie,LADDER_BLEND_CAPACITY_THRESHOLD:$p},O={active:!1,channels:[],endValues:{},baseCurves:{},densityWeights:new Map,densityConstants:new Map,densityProfiles:[],densityCumulative:{},densityCoverage:new Map,densityCoverageSummary:{},densityCoverageLimits:new Map,densityCoverageBuffers:new Map,densityCoverageThresholds:new Map,densityCoverageThresholdsNormalized:new Map,densityCoverageUsage:new Map,measurementDeltas:[],measurementSamples:[],densityInputs:[],densityOverrides:new Map,densitySources:new Map,normalizedEntry:null,domainMin:0,domainMax:1,interpolationType:"cubic",smoothingPercent:0,warnings:[],preparedContext:null,weightingMode:et.NORMALIZED,weightingStrength:1,momentumByChannel:new Map,momentumSummary:{},momentumOptions:null,lastDebugSession:null,autoComputeDensity:!0,autoRaiseAdjustments:[],autoRaiseContext:null,densityLadder:[],densityLadderIndex:new Map,ladderBlendTracker:new Map,shadowBlendTracker:new Map};function sk(e={}){const{channelNames:t=[],endValues:n={},labEntry:r=null}=e;if(!Rf()||!r)return O.active=!1,O.channels=[],O.baseCurves={},O.densityWeights=new Map,O.densityConstants=new Map,O.densityProfiles=[],O.densityCumulative={},O.densityCoverage=new Map,O.densityCoverageSummary={},O.densityCoverageLimits=new Map,O.densityCoverageBuffers=new Map,O.densityCoverageThresholds=new Map,O.densityCoverageThresholdsNormalized=new Map,O.densityCoverageUsage=new Map,O.measurementDeltas=[],O.measurementSamples=[],O.densityInputs=[],O.densityOverrides=new Map,O.densitySources=new Map,O.preparedContext=null,O.warnings=[],O.weightingMode=et.NORMALIZED,O.lastDebugSession=null,O.momentumByChannel=new Map,O.momentumSummary={},O.momentumOptions=null,O.autoComputeDensity=!0,O.autoRaiseAdjustments=[],O.autoRaiseContext=null,O.analysisOnly=!1,O.densityLadder=[],O.densityLadderIndex=new Map,O.ladderBlendTracker=new Map,O.shadowBlendTracker=new Map,!1;const i=Aa(r)||r,a=Rn(i);if(!a||!Array.isArray(a.samples)||a.samples.length<2)return O.active=!1,O.channels=[],O.baseCurves={},O.densityWeights=new Map,O.densityConstants=new Map,O.densityProfiles=[],O.densityCumulative={},O.densityCoverage=new Map,O.densityCoverageSummary={},O.densityCoverageLimits=new Map,O.densityCoverageBuffers=new Map,O.densityCoverageThresholds=new Map,O.densityCoverageThresholdsNormalized=new Map,O.densityCoverageUsage=new Map,O.measurementDeltas=[],O.densityInputs=[],O.measurementSamples=[],O.densityOverrides=new Map,O.densitySources=new Map,O.preparedContext=null,O.warnings=[],O.weightingMode=et.NORMALIZED,O.lastDebugSession=null,O.momentumByChannel=new Map,O.momentumSummary={},O.momentumOptions=null,O.autoComputeDensity=!0,O.autoRaiseAdjustments=[],O.autoRaiseContext=null,O.analysisOnly=!1,O.densityLadder=[],O.densityLadderIndex=new Map,O.ladderBlendTracker=new Map,O.shadowBlendTracker=new Map,!1;try{O.active=!0,O.channels=Array.isArray(t)?t.slice():[],O.endValues={...n},O.baseCurves={},O.densityWeights=new Map,O.densityConstants=new Map,O.densityProfiles=[],O.densityCumulative={},O.densityCoverage=new Map,O.densityCoverageSummary={},O.densityCoverageLimits=new Map,O.densityCoverageBuffers=new Map,O.densityCoverageThresholds=new Map,O.densityCoverageThresholdsNormalized=new Map,O.densityCoverageUsage=new Map,O.measurementDeltas=[],O.measurementSamples=[],O.densityInputs=[],O.normalizedEntry=a,O.domainMin=typeof a.domainMin=="number"?a.domainMin:0,O.domainMax=typeof a.domainMax=="number"?a.domainMax:1,O.interpolationType=e.interpolationType||"cubic",O.smoothingPercent=Number.isFinite(e.smoothingPercent)?Number(e.smoothingPercent):0,O.warnings=[],O.preparedContext=null,O.momentumByChannel=new Map,O.momentumSummary={},O.momentumOptions=null,O.lastDebugSession=null,O.densityLadder=[],O.densityLadderIndex=new Map,O.ladderBlendTracker=new Map,O.shadowBlendTracker=new Map;const o=typeof Rp=="function"?Rp():null,s=[];if(o&&Array.isArray(o.adjustments)&&o.adjustments.length){const p=new Map;O.channels.forEach(f=>{typeof f=="string"&&(p.set(f,f),p.set(f.toUpperCase(),f),p.set(f.toLowerCase(),f))}),o.adjustments.forEach(f=>{if(!f||typeof f.channelName!="string")return;const h=f.channelName.trim();if(!h)return;const g=p.get(h)||p.get(h.toUpperCase())||h;s.push({channel:g,channelName:g,previousPercent:Number.isFinite(f.previousPercent)?f.previousPercent:null,newPercent:Number.isFinite(f.newPercent)?f.newPercent:null,desiredPercent:Number.isFinite(f.desiredPercent)?f.desiredPercent:Number.isFinite(o.targetPercent)?o.targetPercent:null,absoluteTarget:Number.isFinite(f.absoluteTarget)?f.absoluteTarget:null,previousEnd:Number.isFinite(f.previousEnd)?f.previousEnd:null,newEnd:Number.isFinite(f.newEnd)?f.newEnd:null,raised:f.raised===!0,source:f.source||o.context?.source||null,timestamp:o.timestamp||Date.now()})})}O.autoRaiseAdjustments=s,O.autoRaiseContext=s.length?{targetPercent:Number.isFinite(o?.targetPercent)?o.targetPercent:null,label:typeof o?.context?.label=="string"?o.context.label:null,scope:o?.context?.scope||null,timestamp:o?.timestamp||Date.now()}:null;const l=e.densityOverrides,c=new Map,u=new Map;if(l&&typeof l=="object"){const p=l instanceof Map?l.entries():Object.entries(l);Array.from(p).forEach(([f,h])=>{if(!f)return;const g=h&&typeof h=="object"&&h!==null?h.value:h,b=Number(g);if(!Number.isFinite(b))return;const S=b<0?0:b;c.set(f,S);const E=h&&typeof h=="object"&&typeof h.source=="string"?h.source:"manual";u.set(f,E)})}O.densityOverrides=c,O.densitySources=u,O.autoComputeDensity=e.autoComputeDensity!==!1,O.analysisOnly=e.analysisOnly===!0;const d=e.weightingMode||uu();return O.weightingMode=Object.values(et).includes(d)?d:et.NORMALIZED,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] begin redistribution",{channels:O.channels,smoothingPercent:O.smoothingPercent,weightingMode:O.weightingMode,autoCompute:O.autoComputeDensity}),!0}catch(o){return console.error("[beginCompositeLabRedistribution] Error during redistribution setup:",o),qc("LAB redistribution setup failed"),O.active=!1,!1}}function lk(e,t){!O.active||!e||!Array.isArray(t)||(O.baseCurves[e]=t.slice())}function ck(e,t){if(!Array.isArray(e)||!Array.isArray(t)||e.length===0)return null;const n=e.length;if(t.length!==n)return null;for(let a=0;a<n;a+=1)if(!Array.isArray(e[a])||e[a].length!==n)return null;const r=new Array(n);for(let a=0;a<n;a+=1){r[a]=new Array(n+1);for(let o=0;o<n;o+=1)r[a][o]=e[a][o];r[a][n]=t[a]}for(let a=0;a<n;a+=1){let o=a,s=Math.abs(r[a][a]);for(let c=a+1;c<n;c+=1){const u=Math.abs(r[c][a]);u>s&&(s=u,o=c)}if(s<=1e-12)return null;if(o!==a){const c=r[a];r[a]=r[o],r[o]=c}const l=r[a][a];for(let c=a;c<=n;c+=1)r[a][c]/=l;for(let c=0;c<n;c+=1){if(c===a)continue;const u=r[c][a];if(!(Math.abs(u)<=1e-12))for(let d=a;d<=n;d+=1)r[c][d]-=u*r[a][d]}}const i=new Array(n);for(let a=0;a<n;a+=1)i[a]=r[a][n];return i}function uk(e,t){if(!Array.isArray(e)||e.length===0)return 0;if(e.length===1)return ce(Number(e[0])||0);const r=ce(Number.isFinite(t)?t:0)*(e.length-1),i=Math.floor(r),a=Math.min(e.length-1,i+1),o=r-i,s=ce(Number(e[i])||0),l=ce(Number(e[a])||0);return s+(l-s)*o}function IS(e,t,n,r,i){if(!e)return;const a={};Object.keys(r||{}).forEach(s=>{const l=r[s];l>H&&(a[s]=l)});const o={index:t,delta:n,contributions:a,weightMap:{...i},inputPercent:t/bt*100,smoothingWindows:[]};Array.isArray(e.sampleRecords)||(e.sampleRecords=new Array(Ie).fill(null)),e.sampleRecords[t]=o,e.channelHistory instanceof Map||(e.channelHistory=new Map),Object.keys(a).forEach(s=>{let l=e.channelHistory.get(s);l||(l=[],e.channelHistory.set(s,l)),l.push(t)})}function kS(e,t,n,r,i={}){try{let Se=function(R={},Q={}){const X=Number.isFinite(R.minSamples)?Math.round(R.minSamples):3,le=Math.max(3,Math.min(12,X)),pe=Number.isFinite(R.maxSamples)?Math.round(R.maxSamples):9,ne=Math.max(le,Math.min(12,pe)),ie=Number.isFinite(R.targetSpan)?R.targetSpan:.07,oe=Math.max(.01,Math.min(.5,ie)),de=Number.isFinite(R.alpha)?R.alpha:1.5,ke=Math.max(.5,Math.min(4,de)),Fe=Number.isFinite(R.momentumBias)?R.momentumBias:0,ot=Q&&Q.perSampleCeiling===!0;return{config:{minSamples:le,maxSamples:ne,targetSpan:oe,targetSpanPercent:oe*100,alpha:ke,momentumBias:Fe,maxIncomingScan:Math.max(ne,6),allowShortWindows:ot},sampleRecords:new Array(Ie).fill(null),channelHistory:new Map,saturationByChannel:new Map,clampIndicesByChannel:new Map,perSampleCeiling:ot,windows:[],debugRows:[],nextWindowId:1,syntheticClampWindows:new Map,forcedChannels:Q&&Q.forcedChannels instanceof Set?new Set(Q.forcedChannels):new Set,forcedChannelMetadata:Q&&Q.forcedChannelMetadata instanceof Map?new Map(Q.forcedChannelMetadata):new Map}},we=function(R,Q,X,le=null){const pe=Array.isArray(R)?R.length:0;if(pe===0)return[];const ne=!!X?.allowShortWindows;if(!ne&&pe<X.minSamples)return[];const ie=ne?Math.min(X.minSamples,Math.max(2,pe)):X.minSamples,oe=X.maxSamples,de=[];let ke=0,Fe=null;for(let Ae=pe-1;Ae>=0;Ae-=1){const Ve=R[Ae];if(Number.isInteger(le)&&Ve>le)continue;const ge=Q[Ve];if(!ge)continue;const T=Number.isFinite(ge.inputPercent)?ge.inputPercent:Ve/bt*100;if(Fe!=null&&(ke+=Math.abs(Fe-T)),de.unshift(Ve),Fe=T,de.length>=ie&&ke>=X.targetSpanPercent||de.length>=oe)break}let ot=pe-de.length-1;for(;de.length<ie&&ot>=0;){const Ae=R[ot];if(Number.isInteger(le)&&Ae>le){ot-=1;continue}if(!Q[Ae])break;de.unshift(Ae),ot-=1}return de},Ne=function(R,Q,X){const le=R.sampleRecords,pe=R.config,ne=new Set;X.forEach(oe=>{const de=le[oe];!de||!de.contributions||Object.entries(de.contributions).forEach(([ke,Fe])=>{ke!==Q&&Fe>H&&ne.add(ke)})});const ie=X.length?X[X.length-1]:-1;for(let oe=ie+1;oe<le.length&&oe>=0&&ne.size<pe.maxIncomingScan;oe+=1){const de=le[oe];!de||!de.contributions||Object.entries(de.contributions).forEach(([ke,Fe])=>{ke!==Q&&Fe>H&&ne.add(ke)})}if(!ne.size){const oe=X.length?X[X.length-1]:null,de=Number.isInteger(oe)?le[oe]:null;de&&de.weightMap&&Object.entries(de.weightMap).filter(([Fe,ot])=>Fe!==Q&&Number(ot)>0).sort((Fe,ot)=>(Number(ot[1])||0)-(Number(Fe[1])||0)).slice(0,3).forEach(([Fe])=>ne.add(Fe))}if(!ne.size&&R.forcedChannelMetadata instanceof Map){const oe=[];R.forcedChannelMetadata.forEach((de,ke)=>{if(!de||ke===Q)return;const Fe=Number(de.previousPercent);!Number.isFinite(Fe)||Fe<=0||oe.push({name:ke,weight:Fe})}),oe.sort((de,ke)=>(ke.weight||0)-(de.weight||0)).slice(0,3).forEach(({name:de})=>ne.add(de))}return!ne.size&&R.forcedChannels instanceof Set&&Array.from(R.forcedChannels).filter(oe=>oe!==Q).slice(0,3).forEach(oe=>ne.add(oe)),ne},ct=function(R,Q,X){if(!Array.isArray(R)||R.length===0)return null;for(let le=R.length-2;le>=0;le-=1){const pe=R[le],ne=R[le+1],ie=X[pe],oe=X[ne];if(!ie||!oe)continue;const de=Number(ie.contributions?.[Q])||0,ke=Number(oe.contributions?.[Q])||0;if(!(de<=H)&&ke<=de*.6)return pe}return R[R.length-1]},mt=function(R){const{delta:Q,outgoingChannel:X,newOutgoing:le,originalContributions:pe,incomingChannels:ne,weightMap:ie}=R,oe={},de=Math.max(0,Math.min(Q,le));oe[X]=de;const ke=Math.max(0,Q-de);let Fe=0;if(Object.entries(pe).forEach(([ge,T])=>{ge!==X&&T>H&&(Fe+=T)}),Fe>H&&ke>H){const ge=ke/Fe;Object.entries(pe).forEach(([T,L])=>{if(T===X)return;const Y=L*ge;Y>H&&(oe[T]=Y)})}else if(ke>H){let ge=0;ne.forEach(T=>{const L=Math.max(0,Number(ie?.[T])||0);L>0&&(ge+=L)}),ge<=H&&ne.length&&(ge=ne.length),ne.forEach(T=>{const L=Math.max(0,Number(ie?.[T])||0),Y=ge>H?(L||1)/ge:1/ne.length,ee=ke*Y;ee>H&&(oe[T]=(oe[T]||0)+ee)})}let ot=Object.values(oe).reduce((ge,T)=>ge+T,0);if(ot<=H)return{contributions:{...pe}};const Ae=Q-ot;if(Math.abs(Ae)>1e-6){const ge=ne.length?ne:Object.keys(oe),T=Ae/Math.max(1,ge.length);ge.forEach(L=>{oe[L]=(oe[L]||0)+T})}if(Object.keys(oe).forEach(ge=>{oe[ge]<=H&&delete oe[ge]}),ot=Object.values(oe).reduce((ge,T)=>ge+T,0),!Number.isFinite(ot)||ot<=H)return{contributions:{...pe}};const Ve=Q/ot;return Object.keys(oe).forEach(ge=>{oe[ge]*=Ve}),{contributions:oe}},Vt=function(R,Q,X,le,pe={}){if(!X.length)return;const ne=pe&&pe.forced===!0,ie=Ne(R,Q,X);if(!ie.size)return;const oe=Array.from(ie),de=X.length>1?X.length-1:1,ke=R.nextWindowId++;X.forEach((Ae,Ve)=>{const ge=R.sampleRecords[Ae];if(!ge||!Number.isFinite(ge.delta)||ge.delta<=H)return;const T=ge.contributions||{},L=T[Q]||0;if(L<=H)return;const Y=de>0?Ve/de:1,ee=Math.pow(Math.max(0,1-Y),R.config.alpha),be=L*ee,Le=mt({delta:ge.delta,outgoingChannel:Q,newOutgoing:be,originalContributions:T,incomingChannels:oe,weightMap:ge.weightMap||{}});ge.contributions=Le.contributions;const ae=le[Ae];if(ae){const $={};Object.entries(Le.contributions).forEach(([he,ue])=>{ue>H&&($[he]=ce(ue/ge.delta))}),ae.shares=$,Array.isArray(ae.smoothingWindows)||(ae.smoothingWindows=[]),ae.smoothingWindows.push({id:ke,outgoingChannel:Q,incomingChannels:oe.slice(),position:Y,outFactor:ee,forced:ne})}if(ge.smoothingWindows=ge.smoothingWindows||[],ge.smoothingWindows.push({id:ke,outgoingChannel:Q,incomingChannels:oe.slice(),position:Y,outFactor:ee,forced:ne}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const $={};oe.forEach(he=>{$[he]=Le.contributions[he]||0}),R.debugRows.push({windowId:ke,sampleIndex:Ae,inputPercent:ge.inputPercent,outgoingOriginal:L,outgoingAdjusted:Le.contributions[Q]||0,delta:ge.delta,incoming:$,forced:ne})}});const Fe=R.sampleRecords[X[0]],ot=R.sampleRecords[X[X.length-1]];R.windows.push({id:ke,outgoingChannel:Q,incomingChannels:oe.slice(),startIndex:X[0],endIndex:X[X.length-1],inputStart:Fe?Fe.inputPercent:null,inputEnd:ot?ot.inputPercent:null,forced:ne})},xt=function(R,Q){if(!R)return;const X=R.forcedChannels instanceof Set?R.forcedChannels:null,le=R.clampIndicesByChannel instanceof Map?R.clampIndicesByChannel:null,pe=R.perSampleCeiling===!0;R.channelHistory.forEach((ne,ie)=>{if(!Array.isArray(ne)||!ne.length)return;let oe=!1;if(pe&&le){const Ae=le.get(ie);Array.isArray(Ae)&&Ae.length&&(Array.from(new Set(Ae)).sort((ge,T)=>ge-T).forEach(ge=>{if(!Number.isInteger(ge))return;let T=we(ne,R.sampleRecords,R.config,ge);if(T.length<2){const L=ne.filter(Y=>Number.isInteger(Y)&&Y<=ge);if(L.length>=2){const Y=Math.max(0,L.length-R.config.minSamples);T=L.slice(Y)}}T.length>=2&&(Vt(R,ie,T,Q,{forced:!0}),oe=!0)}),le.set(ie,[]))}const de=X?X.has(ie):!1;let ke=R.saturationByChannel?.get(ie);if(Number.isInteger(ke)||(ke=ct(ne,ie,R.sampleRecords)),!Number.isInteger(ke)&&de&&(ke=ne[ne.length-1]),oe&&!de)return;const Fe=we(ne,R.sampleRecords,R.config,ke),ot=de?Math.min(R.config.minSamples,2):R.config.minSamples;Fe.length>=ot&&Fe.length>0&&Vt(R,ie,Fe,Q,{forced:de})})},Un=function(R,Q){if(!R)return;const X={};R.sampleRecords.forEach(le=>{!le||!le.contributions||Object.entries(le.contributions).forEach(([pe,ne])=>{!Number.isFinite(ne)||ne<=H||(X[pe]=(X[pe]||0)+ne)})}),Object.keys(Q).forEach(le=>{Q[le]=X[le]||0}),Object.keys(X).forEach(le=>{Object.prototype.hasOwnProperty.call(Q,le)||(Q[le]=X[le])})};var a=Se,o=we,s=Ne,l=ct,c=mt,u=Vt,d=xt,p=Un;const f=i.weightingMode||et.NORMALIZED,h=new Map,g=new Map,b=new Array(Ie).fill(0),S=new Array(Ie).fill(null),E=f===et.MOMENTUM,y=new Map,v={},A=E?{windowRadius:qI,sigma:jI}:null,w=Array.isArray(O.autoRaiseAdjustments)?O.autoRaiseAdjustments:[],M=new Set,I=new Map;w.forEach(R=>{if(!R||R.raised!==!0)return;const Q=typeof R.channelName=="string"?R.channelName:R.channel;Q&&(M.add(Q),I.set(Q,R))});const _=Rc(),x=Gc()?Se(zc(),{forcedChannels:M,forcedChannelMetadata:I,perSampleCeiling:_}):null,P={},k=new Map,N=new Map,F=new Map,U=new Map,j=new Map,B=new Map,G=new Array(Ie).fill(0),V=Object.create(null);let K=0,se=!1,W=0;const fe=Array.isArray(r?.samples)?r.samples:null,Bt=Number.isFinite(i.smoothingPercent)?Number(i.smoothingPercent):O.smoothingPercent,Gt=fy(),ir=Bt>0?Ir(Bt):1;let Lt=null;if(Array.isArray(r?.originalData)&&r.originalData.length>=2)try{const R=$c(r.originalData,{skipDefaultSmoothing:!Gt&&Bt<=0,widenFactor:ir});R&&typeof R.evaluate=="function"&&(Lt=R.evaluate)}catch(R){console.warn("[COMPOSITE] Failed to build density evaluator from measurements:",R)}const rt=[];if(e.forEach(R=>{const Q=t[R],X=Math.max(0,Number(n[R])||0);if(!(!Array.isArray(Q)||Q.length===0||X<=0||Q.reduce((pe,ne)=>{const ie=Number(ne)||0;return ie>pe?ie:pe},0)<=0)&&(rt.push({name:R,curve:Q,endValue:X}),E)){const pe=nI(Q,X,A||void 0);y.set(R,pe);const ne=Array.isArray(pe)?pe.reduce((ie,oe)=>Number.isFinite(oe)&&oe>ie?oe:ie,0):0;v[R]=ne}}),!rt.length)return{weights:h,totalWeight:K,solved:se,constants:g,measurementDeltas:b,profiles:S,cumulativeDensity:P,totalDensity:W,inputs:G};const wt=Lt?Ie:Math.min(Ie,Array.isArray(fe)?fe.length:0),Ct=i.manualDensityOverrides,fr=new Map,ar=new Map;if(Ct&&typeof Ct=="object"){const R=Ct instanceof Map?Ct.entries():Object.entries(Ct);Array.from(R).forEach(([Q,X])=>{if(!Q)return;const le=X&&typeof X=="object"&&X!==null?X.value:X,pe=Number(le);if(!Number.isFinite(pe))return;const ne=pe<0?0:pe;fr.set(Q,ne);const ie=X&&typeof X=="object"&&typeof X.source=="string"?X.source:"manual";ar.set(Q,ie)})}const qr=i.autoComputeEnabled!==!1,Pr=new Map;rt.forEach((R,Q)=>{Pr.set(R.name,Q)});const En=new Map;fr.forEach((R,Q)=>{Pr.has(Q)&&En.set(Q,R)});const z=new Set(En.keys()),me=rt.filter(({name:R})=>!z.has(R)&&qr).map(({name:R})=>R),Pe=[],$e=[];if(wt>=2)for(let R=0;R<wt;R+=1){const Q=new Array(rt.length);let X=!1;for(let ie=0;ie<rt.length;ie+=1){const{curve:oe,endValue:de}=rt[ie],ke=Number(oe[R])||0,Fe=de>0?ce(ke/de):0;Q[ie]=Fe,Fe>1e-6&&(X=!0)}if(!X)continue;let le;if(Lt){const ie=wt>1?R/(wt-1):0;le=ce(Number(Lt(ie))||0)}else if(fe&&fe.length){const ie=Math.min(R,fe.length-1);le=ce(Number(fe[ie])||0)}else le=Pe.length>1?R/(wt-1):0;let pe=0;En.forEach((ie,oe)=>{const de=Pr.get(oe);de!=null&&(pe+=ie*(Q[de]||0))});const ne=Math.max(0,le-pe);if(me.length){const ie=new Array(me.length);let oe=!1;for(let de=0;de<me.length;de+=1){const ke=Pr.get(me[de]),Fe=ke!=null&&Q[ke]||0;ie[de]=Fe,Fe>1e-6&&(oe=!0)}(oe||ne>H)&&(Pe.push(ie),$e.push(ne))}}const Ce=new Map;if(Pe.length&&me.length){const R=me.length,Q=Array.from({length:R},()=>new Array(R).fill(0)),X=new Array(R).fill(0);Pe.forEach((pe,ne)=>{const ie=$e[ne];for(let oe=0;oe<R;oe+=1){const de=pe[oe];X[oe]+=de*ie;for(let ke=0;ke<R;ke+=1)Q[oe][ke]+=de*pe[ke]}});for(let pe=0;pe<R;pe+=1)Q[pe][pe]+=FI;const le=ck(Q,X);le&&(le.forEach((pe,ne)=>{if(!Number.isFinite(pe)||pe<=0)return;const ie=pe,oe=me[ne];h.set(oe,ie),g.set(oe,ie),Ce.set(oe,"solver"),K+=ie}),se=le.some(pe=>Number.isFinite(pe)&&pe>0))}En.forEach((R,Q)=>{Number.isFinite(R)&&(h.set(Q,R),g.set(Q,R),Ce.set(Q,ar.get(Q)||"manual"),K+=R,se=!0)});const St=new Array(Ie).fill(0);for(let R=0;R<Ie;R+=1){const Q=bt>0?R/bt:0;let X;Lt?X=Lt(Q):fe&&fe.length>=2?X=uk(fe,Q):X=Q,St[R]=ce(Number(X)||0),G[R]=R/bt*100}for(let R=1;R<Ie;R+=1){const Q=Math.max(0,St[R]-St[R-1]);b[R]=Q,W+=Q}b[0]=0;let At=0;for(let R=0;R<Ie;R+=1){const Q=bt>0?R/bt:0,X=St[R];if(Number.isFinite(X)){const le=Math.abs(X-Q);le>At&&(At=le)}}const It={};rt.forEach(({name:R})=>{It[R]=new Array(Ie).fill(0),P[R]=0});for(let R=0;R<Ie;R+=1){let Q=0;rt.forEach(({name:X,curve:le})=>{Q+=Math.max(0,Number(le[R])||0)}),!(Q<=H)&&rt.forEach(({name:X,curve:le})=>{const pe=Math.max(0,Number(le[R])||0)/Q;It[X][R]=pe})}const Rt=f===et.NORMALIZED;let Ht=[];if(Rt)rt.forEach(({name:R})=>{let Q=0;for(let X=1;X<Ie;X+=1){const le=b[X];if(le<=H)continue;const pe=It[R][X]||0;pe<=Ta||(Q+=le*pe)}g.set(R,Q)}),Ht=rt.map(({name:R})=>({name:R}));else{Ht=rt.map(({name:X})=>{const le=It[X];let pe=-1;for(let ne=0;ne<Ie;ne+=1)if(!(b[ne]<=H)&&le[ne]>=GI){pe=ne;break}if(pe===-1){for(let ne=0;ne<Ie;ne+=1)if(!(b[ne]<=H)&&le[ne]>=RI){pe=ne;break}}if(pe===-1){for(let ne=0;ne<Ie;ne+=1)if(le[ne]>Ta){pe=ne;break}}return pe===-1&&(pe=Number.POSITIVE_INFINITY),{name:X,firstDominance:pe,shareArray:le}}).sort((X,le)=>X.firstDominance-le.firstDominance);const R=[];Ht.forEach(({name:X,shareArray:le})=>{let pe=0,ne=0;for(let ke=1;ke<Ie;ke+=1){const Fe=b[ke];if(Fe<=H)continue;const ot=le[ke];if(ot<=Ta)continue;let Ae=Fe;R.forEach(Ve=>{const ge=g.get(Ve)||0,T=It[Ve]?.[ke]||0;ge>0&&T>0&&(Ae-=ge*T)}),!(Ae<=H)&&(pe+=Ae,ne+=ot)}if(ne<=H||W<=H){g.set(X,0),R.push(X);return}let ie=pe/ne;(!Number.isFinite(ie)||ie<0)&&(ie=0);const oe=Array.from(g.values()).reduce((ke,Fe)=>ke+Fe,0),de=Math.max(0,W-oe);if(de<=H){g.set(X,0),R.push(X);return}ie>de&&(ie=de),g.set(X,ie),R.push(X)});const Q=Array.from(g.values()).reduce((X,le)=>X+le,0);if(W>H&&Q<W-H&&Ht.length){const X=Ht[Ht.length-1].name,le=Math.max(0,W-Q);g.set(X,(g.get(X)||0)+le)}}typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[density] constants size",g.size,"mode",f),En.forEach((R,Q)=>{Number.isFinite(R)&&(g.set(Q,R),Ce.set(Q,ar.get(Q)||"manual"))}),f===et.EQUAL&&(K=0,se=!0,rt.forEach(({name:Q})=>{h.set(Q,1),K+=1}));const Tt=Ht.length?Ht:rt.map(({name:R})=>({name:R}));Tt.forEach(({name:R})=>{const Q=Math.max(0,Number(n[R])||0),X=Q>0?Math.max(0,Math.min(1,Q/ve)):0;let le=Math.max(0,g.get(R)||0),pe=Ce.get(R);const ne=Number.isFinite(fs[R])?fs[R]:null;ne!=null&&(le=ne,g.set(R,le),(!pe||pe==="solver"||pe==="pending")&&(Ce.set(R,"fixed"),pe="fixed")),!Number.isFinite(le)||le<=H?X>H?(le=X,g.set(R,le),pe||(Ce.set(R,"end"),pe="end")):(le=0,g.set(R,le)):X>H&&le>X+H&&(le=X,g.set(R,le));const ie=le;k.set(R,ie);const oe=ie>0?QI:0;N.set(R,oe);const de=ie+oe;F.set(R,de),U.set(R,0),j.set(R,0),_||(V[R]=Math.max(0,Number.isFinite(de)?de:0))});for(let R=1;R<Ie;R+=1){const Q=b[R];if(Q<=H){const Ae={density:0,shares:{}};if(E){const Ve={};y.forEach((ge,T)=>{Ve[T]=Array.isArray(ge)&&ge[R]||0}),Ae.momentum=Ve}S[R]=Ae;continue}const X={},le=E?{}:null;let pe=0;if(rt.forEach(({name:Ae})=>{const Ve=It[Ae][R]||0,ge=V[Ae]||0;let T=0;if(le){const ee=y.get(Ae);T=Array.isArray(ee)&&ee[R]||0,le[Ae]=T}if(ge<=H)return;let L=Ve,Y=1;if(le&&(Y+=T*WI,L<=Ta&&(L=Math.max(L,T*KI))),L>Ta){const ee=g.get(Ae)||0;X[Ae]=ee*L*Y,(X[Ae]>0||ge>H)&&(pe+=1)}}),!pe){const Ae={density:Q,shares:{}};le&&(Ae.momentum=le),S[R]=Ae;continue}const ne=x?{}:null;ne&&rt.forEach(({name:Ae})=>{ne[Ae]=Number(V[Ae])||0});const ie={};let oe=Q,de=0,ke=Object.keys(X);for(ke.length||(ke=Object.keys(V).filter(Ae=>(V[Ae]||0)>H));oe>H&&ke.length&&de<zI;){de+=1;let Ae=0;if(ke.forEach(Ve=>{Ae+=X[Ve]||0}),Ae<=H){const Ve=oe/ke.length;let ge=0;if(ke.forEach(T=>{const L=V[T]||0;if(L<=H)return;const Y=Math.min(Ve,L);Y>0&&(ie[T]=(ie[T]||0)+Y,V[T]=L-Y,ge+=Y)}),ge<=H)break;oe-=ge}else{let Ve=0;if(ke.forEach(ge=>{const T=V[ge]||0;if(T<=H)return;const L=(X[ge]||0)/Ae*oe,Y=Math.min(L,T);Y>0&&(ie[ge]=(ie[ge]||0)+Y,V[ge]=T-Y,Ve+=Y)}),Ve<=H)break;oe-=Ve}ke=ke.filter(Ve=>(V[Ve]||0)>H)}if(oe>H){let Ae=null,Ve=0;if(rt.forEach(({name:ge})=>{const T=V[ge]||0,L=It[ge][R]||0;T>Ve&&L>Ta&&(Ae=ge,Ve=T)}),Ae){const ge=Math.min(oe,Ve);ge>0&&(ie[Ae]=(ie[Ae]||0)+ge,V[Ae]=Ve-ge,oe-=ge)}}if(x&&ne){const Ae=x.saturationByChannel;rt.forEach(({name:Ve})=>{if(Ae.has(Ve))return;const ge=ne[Ve]||0,T=V[Ve]||0;ge>H&&T<=H&&Ae.set(Ve,R)})}x&&IS(x,R,Q,ie,X);const Fe={};Object.keys(ie).forEach(Ae=>{const Ve=ie[Ae];Ve<=H||(Fe[Ae]=ce(Ve/Q),P[Ae]+=Ve)});const ot={density:Q,shares:Fe};le&&(ot.momentum=le),S[R]=ot}if(x&&(xt(x,S),Un(x,P),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&Array.isArray(x.debugRows)&&x.debugRows.length))try{console.table(x.debugRows.slice(-Math.min(20,x.debugRows.length)))}catch{console.log("[smoothingWindow]",x.debugRows.slice(-Math.min(20,x.debugRows.length)))}if(S[0]){if(E&&!S[0].momentum){const R={};y.forEach((Q,X)=>{R[X]=Array.isArray(Q)&&Q[0]||0}),S[0].momentum=R}}else{const R={density:0,shares:{}};if(E){const Q={};y.forEach((X,le)=>{Q[le]=Array.isArray(X)&&X[0]||0}),R.momentum=Q}S[0]=R}const zt=Tt.length?Tt.map(({name:R})=>R):e,{map:Bn,plain:qt}=MS(zt,{coverageLimits:k,coverageBuffers:N,coverageThresholds:F,coverageUsage:j,coverageClampEvents:B}),st=x?x.windows.slice():[];if(_&&x&&st.length===0){const R=[];Object.entries(qt||{}).forEach(([Q,X])=>{if(!X||typeof X!="object")return;const pe=(Array.isArray(X.clampedSamples)?X.clampedSamples:[]).find(Fe=>Number.isFinite(Fe?.index));if(!pe)return;const ne=Number(pe.index);if(!Number.isFinite(ne))return;const ie=Math.trunc(ne),oe=Number.isFinite(pe.inputPercent)?pe.inputPercent:ie/bt*100,ke={id:Number.isFinite(x.nextWindowId)?x.nextWindowId++:R.length+1,outgoingChannel:Q,incomingChannels:[],startIndex:ie,endIndex:ie,inputStart:oe,inputEnd:oe,forced:!0,synthetic:!0};R.push(ke)}),R.length&&(st.push(...R),Array.isArray(x.windows)&&x.windows.push(...R))}return{weights:h,totalWeight:K,solved:se,constants:g,measurementDeltas:b,profiles:S,cumulativeDensity:P,totalDensity:W,inputs:G,measurementSamples:St,momentumByChannel:y,momentumSummary:v,momentumOptions:A,densitySources:Ce,coverageSummary:qt,coverageByChannel:Bn,coverageLimits:k,coverageBuffers:N,coverageThresholds:F,coverageThresholdsNormalized:U,coverageClampEvents:B,coverageUsage:j,smoothingWindows:st,smoothingConfig:x?{...x.config}:null,remainingByChannel:{...V},smoothingContext:x,perSampleCeilingEnabled:_}}catch(f){return console.error("[computeCompositeDensityWeights] Error computing density weights:",f),qc("Composite density calculation failed"),{weights:new Map,constants:new Map,measurementDeltas:new Array(Ie).fill(0),densityProfiles:new Array(Ie).fill(null),momentumByChannel:new Map,momentumSummary:{},momentumOptions:null,densitySources:new Map,coverageSummary:{},coverageByChannel:new Map,coverageLimits:new Map,coverageBuffers:new Map,coverageThresholds:new Map,coverageThresholdsNormalized:new Map,coverageClampEvents:new Map,coverageUsage:new Map,smoothingWindows:null,smoothingConfig:null,remainingByChannel:{},smoothingContext:null,perSampleCeilingEnabled:!1}}}function dk(){if(!O.active)return null;if(O.preparedContext)return O.preparedContext;const e=wm(O.normalizedEntry,O.domainMin,O.domainMax,O.interpolationType,O.smoothingPercent);return O.preparedContext=e,e}function Cg(e){return`${(e/bt*100).toFixed(1).replace(/\\.0$/,"")}%`}function pk(){if(!O.active)return null;const e=Rc(),t=O.analysisOnly===!0,{channels:n,endValues:r,baseCurves:i}=O,a=dk();if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] finalize redistribution",{activeChannels:n?.length||0,perSampleCeilingEnabled:e,smoothingEnabled:Gc(),autoCompute:O.autoComputeDensity,debugEnabled:ds()}),!a||!n.length)return O.active=!1,O.preparedContext=null,null;const{interpolationFunction:o,lutDomainMin:s,domainSpan:l}=a;if(!n.length)return O.active=!1,O.preparedContext=null,null;pg();const c={},u={},d=new Map,p=new Map;n.forEach(z=>{const J=i[z];Array.isArray(J)&&(c[z]=J.slice(),u[z]=J.slice())});const f=new Array(Ie).fill(0);let h=0;for(let z=0;z<Ie;z+=1){let J=0;n.forEach(me=>{const Pe=u[me];Pe&&(J+=Pe[z])}),f[z]=J,J>h&&(h=J)}if(h<=0)return O.active=!1,O.preparedContext=null,null;const g=O.weightingMode||et.NORMALIZED,b=kS(n,u,r,O.normalizedEntry,{weightingMode:g,smoothingPercent:O.smoothingPercent,manualDensityOverrides:O.densityOverrides,autoComputeEnabled:O.autoComputeDensity}),S=b.smoothingContext||null,E=b.weights;O.densityWeights=E;const y=b.constants instanceof Map?b.constants:new Map(b.constants?Object.entries(b.constants):[]);if(O.densityConstants=y instanceof Map?new Map(y):y,typeof globalThis<"u")try{delete globalThis.__solverConstantsEntries,delete globalThis.__solverConstantsMap}catch{}O.densityProfiles=Array.isArray(b.profiles)?b.profiles:[],O.densityCumulative=b.cumulativeDensity||{},O.measurementDeltas=Array.isArray(b.measurementDeltas)?b.measurementDeltas:[],O.densityInputs=Array.isArray(b.inputs)?b.inputs:[],O.measurementSamples=Array.isArray(b.measurementSamples)?b.measurementSamples:[],O.momentumByChannel=b.momentumByChannel instanceof Map?b.momentumByChannel:new Map(b.momentumByChannel?Object.entries(b.momentumByChannel):[]),O.momentumSummary=b.momentumSummary||{},O.momentumOptions=b.momentumOptions||null,O.densitySources=b.densitySources instanceof Map?b.densitySources:new Map(b.densitySources?Object.entries(b.densitySources):[]),O.densityCoverage=b.coverageByChannel instanceof Map?b.coverageByChannel:new Map(Object.entries(b.coverageByChannel||{}).map(([z,J])=>[z,J&&typeof J=="object"?{...J}:{limit:0,buffer:0,bufferedLimit:0,maxNormalized:0,overflow:0,overflowNormalized:0,clampedSamples:[]}])),O.densityCoverageSummary={},O.densityCoverageLimits=b.coverageLimits instanceof Map?b.coverageLimits:new Map(Object.entries(b.coverageLimits||{})),O.densityCoverageBuffers=b.coverageBuffers instanceof Map?b.coverageBuffers:new Map(Object.entries(b.coverageBuffers||{})),O.densityCoverageThresholds=b.coverageThresholds instanceof Map?b.coverageThresholds:new Map(Object.entries(b.coverageThresholds||{})),O.densityCoverageThresholdsNormalized=b.coverageThresholdsNormalized instanceof Map?b.coverageThresholdsNormalized:new Map(Object.entries(b.coverageThresholdsNormalized||{}).map(([z,J])=>[z,Number.isFinite(J)?Number(J):J])),O.densityCoverageUsage=b.coverageUsage instanceof Map?b.coverageUsage:new Map(Object.entries(b.coverageUsage||{})),O.densityCoverageClampEvents=b.coverageClampEvents instanceof Map?b.coverageClampEvents:new Map(Object.entries(b.coverageClampEvents||{}).map(([z,J])=>[z,Array.isArray(J)?J.slice():[]])),O.perSampleCeilingEnabled=e;const v=O.densityCoverageLimits instanceof Map?O.densityCoverageLimits:new Map,A=O.densityCoverageBuffers instanceof Map?O.densityCoverageBuffers:new Map,w=O.densityCoverageUsage instanceof Map?O.densityCoverageUsage:new Map,M=O.densityCoverageClampEvents instanceof Map?O.densityCoverageClampEvents:new Map,I=O.densityCoverageThresholds instanceof Map?O.densityCoverageThresholds:new Map,_=O.densityCoverageThresholdsNormalized instanceof Map?O.densityCoverageThresholdsNormalized:new Map,C=Object.assign(Object.create(null),b.remainingByChannel&&typeof b.remainingByChannel=="object"?b.remainingByChannel:{});if(O.smoothingWindows=Array.isArray(b.smoothingWindows)?b.smoothingWindows.slice():[],O.smoothingConfig=b.smoothingConfig?{...b.smoothingConfig}:null,t){const z=_a(b.coverageSummary||{});O.densityCoverageSummary=z;const J=Array.isArray(b.warnings)?b.warnings.slice():[],me={};Array.isArray(n)&&n.forEach(qt=>{const st=Number(r?.[qt]);me[qt]=Number.isFinite(st)?st:0});const Pe=qn(E),$e=qn(O.densityConstants),Ce=qn(O.densitySources),St=qn(O.densityCumulative),At=O.momentumSummary?{...O.momentumSummary}:null,It=new Array(Ie).fill(null),Rt=O.measurementSamples||[],Ht=O.measurementDeltas||[],Tt=O.densityInputs||[];for(let qt=0;qt<Ie;qt+=1){const st=f[qt]||0,R={};n.forEach(X=>{const le=u[X]||[],pe=Number(le[qt])||0,ne=Math.max(0,Number(r[X])||0),ie=ne>0?ce(pe/ne):0,oe=E.get(X)||0,de=st>0?pe/st:0,ke=Number(_.get(X)),Fe=Number.isFinite(ke)?Math.max(0,ke-ie):ne>0?Math.max(0,1-ie):0,ot=ne>0?Math.max(0,Math.min(1,ne/ve)):0,Ae=ie*ot,Ve=w.get(X)||0;Ae>Ve&&w.set(X,Ae);const ge=oe*ie;R[X]={baselineValue:pe,correctedValue:pe,valueDelta:0,normalizedBefore:ie,normalizedAfter:ie,normalizedDelta:0,weight:oe,shareBefore:de,shareAfter:de,weightingShare:de,densityShareBefore:de,densityShareAfter:de,headroomBefore:Fe,headroomAfter:Fe,densityContributionBefore:ge,densityContributionAfter:ge,densityContributionDelta:0,momentum:0}});const Q=Array.isArray(Rt)?Rt[qt]??null:null;It[qt]={index:qt,inputPercent:qt/bt*100,targetDensity:Q,measurementDensity:Q,deltaDensity:0,baselineInk:st,correctedInk:st,inkDelta:0,perChannel:R,weightingMode:g}}const Bn={summary:{channelNames:Array.isArray(n)?n.slice():[],channelMaxima:me,densityWeights:Pe,densityConstants:$e,cumulativeDensity:St,totalDensity:Number.isFinite(b.totalDensity)?b.totalDensity:null,measurementSamples:Array.isArray(Rt)?Rt.slice():null,measurementDeltas:Array.isArray(Ht)?Ht.slice():null,densityInputs:Array.isArray(Tt)?Tt.slice():null,densitySources:Ce,densityLadder:Se.slice(),ladderOrderIndex:{...Ne},warnings:J.slice(),peakIndices:null,weightingMode:g,momentumPeaks:At,momentumWindow:O.momentumOptions?.windowRadius??null,momentumSigma:O.momentumOptions?.sigma??null,coverageSummary:_a(z),coverageLimits:qn(v),coverageBuffers:qn(A),smoothingWindows:[],smoothingConfig:null},snapshots:It,selectionIndex:null};return O.lastDebugSession=Bn,ps(Bn),typeof Qe=="object"&&Qe&&(Qe.__COMPOSITE_DEBUG_CACHE__=Bn),O.warnings=J,O.peakIndices={},O.active=!1,O.preparedContext=null,O.analysisOnly=!1,D&&typeof D=="object"&&(typeof D.setGlobalBaselineCurves=="function"&&D.setGlobalBaselineCurves(u),typeof D.setGlobalCorrectedCurves=="function"&&D.setGlobalCorrectedCurves(c),typeof D.setGlobalWarnings=="function"&&D.setGlobalWarnings(J),typeof D.setCompositeCoverageSummary=="function"&&D.setCompositeCoverageSummary(z)),{curves:c,warnings:J,peakIndices:{},weights:E instanceof Map?Array.from(E.entries()):[],measurementSamples:Array.isArray(O.measurementSamples)?O.measurementSamples.slice():[]}}const x=ds(),P=!0;let k=new Array(Ie).fill(null),N=null,F=null;typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] debug capture state",{captureDebug:P,debugEnabled:x});{const z={};Array.isArray(n)&&n.forEach(J=>{const me=Number(r?.[J]);z[J]=Number.isFinite(me)?me:0}),N={channelNames:Array.isArray(n)?n.slice():[],channelMaxima:z,densityWeights:qn(E),densityConstants:qn(O.densityConstants),cumulativeDensity:qn(O.densityCumulative),totalDensity:Number.isFinite(b.totalDensity)?b.totalDensity:null,measurementSamples:Array.isArray(O.measurementSamples)?O.measurementSamples.slice():null,measurementDeltas:Array.isArray(O.measurementDeltas)?O.measurementDeltas.slice():null,densityInputs:Array.isArray(O.densityInputs)?O.densityInputs.slice():null,densitySources:qn(O.densitySources),warnings:[],peakIndices:null,weightingMode:g,momentumPeaks:O.momentumSummary?{...O.momentumSummary}:null,momentumWindow:O.momentumOptions?.windowRadius??null,momentumSigma:O.momentumOptions?.sigma??null,coverageSummary:_a(b.coverageSummary||{}),coverageLimits:qn(b.coverageLimits),coverageBuffers:qn(b.coverageBuffers),coverageClampEvents:(()=>{if(!(b.coverageClampEvents instanceof Map))return{};const J={};return b.coverageClampEvents.forEach((me,Pe)=>{J[Pe]=Array.isArray(me)?me.map($e=>({...$e})):[]}),J})(),perSampleCeilingEnabled:e,smoothingWindows:Array.isArray(O.smoothingWindows)?O.smoothingWindows.map(J=>J?{id:J.id??null,outgoingChannel:J.outgoingChannel??null,incomingChannels:Array.isArray(J.incomingChannels)?J.incomingChannels.slice():[],startIndex:J.startIndex??null,endIndex:J.endIndex??null,inputStart:J.inputStart??null,inputEnd:J.inputEnd??null}:null).filter(Boolean):[],smoothingConfig:O.smoothingConfig?{...O.smoothingConfig}:null},typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] debug summary seeded",{channelCount:N.channelNames.length,smoothingWindowCount:N.smoothingWindows.length})}const U=new Map;n.forEach(z=>{const J=u[z],me=Math.max(0,Number(r[z])||0);if(!Array.isArray(J)||me<=0){U.set(z,new Array(Ie).fill(0));return}const Pe=J.map($e=>ce((Number($e)||0)/me));U.set(z,Pe)});const j=new Array(Ie);for(let z=0;z<Ie;z+=1){let J=null,me=0;n.forEach(Pe=>{const $e=U.get(Pe)?.[z]||0;$e>me+H&&(me=$e,J=Pe)}),j[z]=me>H?J:null}const B=new Map;let G=j[0],V=0;for(let z=1;z<Ie;z+=1){const J=j[z];if(J!==G){if(G){const me=B.get(G)||[];me.push({start:V,end:z-1}),B.set(G,me)}G=J,V=z}}if(G){const z=B.get(G)||[];z.push({start:V,end:Ie-1}),B.set(G,z)}const K=new Map;B.forEach((z,J)=>{if(!Array.isArray(z)||z.length===0)return;let me=z[0];for(let Tt=1;Tt<z.length;Tt+=1){const zt=z[Tt];if(zt.start<me.start)me=zt;else if(zt.start===me.start){const Bn=me.end-me.start;zt.end-zt.start>Bn&&(me=zt)}}const Pe=U.get(J)||[],$e=me.start,Ce=me.end;let St=$e,At=Pe[$e]||0;for(let Tt=$e+1;Tt<=Ce;Tt+=1){const zt=Pe[Tt]||0;if(zt>At+H)At=zt,St=Tt;else if(zt+H<At)break}const It=St,Rt=Math.max(0,$e-El),Ht=Math.min(bt,It+El);K.set(J,{start:$e,end:Ce,primaryEnd:It,effectiveStart:Rt,effectiveEnd:Ht})});const se=new Map;U.forEach((z,J)=>{const me=Array.isArray(z)?z.reduce((Pe,$e)=>Pe+(Number($e)||0),0):0;se.set(J,me)});const W=n.slice().sort((z,J)=>{const me=se.get(z)||0;return(se.get(J)||0)-me}),fe=z=>E instanceof Map?Number(E.get(z)):E&&typeof E=="object"?Number(E[z]):Number.NaN,Se=n.slice().sort((z,J)=>{const me=fe(z),Pe=fe(J),$e=Number.isFinite(me)?me:Number.POSITIVE_INFINITY,Ce=Number.isFinite(Pe)?Pe:Number.POSITIVE_INFINITY;if(Math.abs($e-Ce)>H)return $e-Ce;const St=se.get(z)||0,At=se.get(J)||0;return St-At}),we=new Map;Se.forEach((z,J)=>{we.set(z,J)});const Ne={};we.forEach((z,J)=>{Ne[J]=z}),O.densityLadder=Se.slice(),O.densityLadderIndex=new Map(we);const ct=new Map;W.forEach((z,J)=>{ct.set(z,J)});const mt=new Map;n.forEach(z=>{mt.set(z,!1)});const Vt=new Map;n.forEach(z=>{Vt.set(z,{maxNormalized:0,maxValue:0,peakIndex:0,locked:!1})});const xt=(z,J)=>{const me=K.get(z);if(!me)return 0;const{start:Pe,primaryEnd:$e,effectiveStart:Ce,effectiveEnd:St}=me,At=1+$I;if(J<Ce||J>St)return 0;if(J>=Pe&&J<=$e)return At;if(J<Pe){const zt=1-(Pe-J)/(El+1),Bn=Math.max(0,Math.min(1,zt));return vl+(At-vl)*Bn}const Rt=1-(J-$e)/(El+1),Ht=Math.max(0,Math.min(1,Rt));return vl*Ht};for(let z=0;z<Ie;z+=1){const J=n.reduce((T,L)=>{const Y=c[L];if(!Array.isArray(Y))return T;const ee=Number(Y[z])||0;return ee>0?T+ee:T},0);if(J<=0)continue;const me=Array.isArray(O.densityProfiles)?O.densityProfiles[z]:null,Pe=me&&me.shares?me.shares:null,$e=me&&me.momentum?me.momentum:null,Ce=new Map,St={};n.forEach(T=>{const L=c[T],Y=u[T];if(!L||!Y)return;const ee=Math.max(0,Number(r[T])||0);if(ee<=0)return;const be=Array.isArray(L)?Math.max(0,Number(L[z])||0):0,Le=Array.isArray(Y)?Math.max(0,Number(Y[z])||0):0,ae=ee>0?ce(Le/ee):0,$=(E.get(T)||0)*ae,he=f[z]||0,ue=he>0?Le/he:0,Re=be,He=Math.max(0,ee-Re),je=E.get(T)||0,Ke=ee>0?ce(Re/ee):0,Me=ee>0?He/ee:0,Ye=$e&&Number.isFinite($e[T])?Math.max(0,$e[T]):0,ut=Math.max(H,je||E.get(T)||0),jt=I.get(T),it=v.get(T),kt=Number.isFinite(jt)?Math.max(0,jt):null,wn={curve:L,endValue:ee,endNormalized:ee>0?Math.max(0,Math.min(1,ee/ve)):0,current:Re,headroom:He,headroomNormalized:Me,normalized:Ke,weight:je,baselineValue:Le,baselineNormalized:ae,baselineContribution:$,baselineShare:ue,share:J>0?Math.max(0,Re)/J:0,densityShare:0,regionShareOverride:!1,momentum:Ye,densityWeight:ut,densityLimit:kt,coverageLimit:Number.isFinite(it)?it:null,coverageFloorNormalized:0,layerNormalized:0,allowedNormalized:null,reserveReleaseScale:1,reserveReleaseHeadroom:Me,capacityBeforeNormalized:0,capacityAfterNormalized:0,blendCapNormalized:Number.POSITIVE_INFINITY,blendAppliedNormalized:0,blendWindow:0,blendProgress:0,shadowBlendCapNormalized:Number.POSITIVE_INFINITY,shadowBlendAppliedNormalized:0,shadowBlendWindow:0,shadowBlendProgress:0,shadowBlendFromChannel:null,reserveState:"approaching",reserveAllowanceNormalized:0,reserveAllowanceRemaining:0};Ce.set(T,wn),St[T]=je});const At=Se.slice().reverse();let It=0;if(At.forEach(T=>{const L=Ce.get(T);if(!L)return;const Y=L.densityWeight,ee=L.densityLimit,be=L.coverageLimit,Le=L.curve,ae=Math.max(L.baselineNormalized,It);L.coverageFloorNormalized=ae;let $=1;if(ee!=null&&Y>H){const Ke=Math.max(0,ee/Y);$=Math.min(1,ae+Ke)}L.allowedNormalized=$;const he=L.normalized;if(he>$+H){const Ke=$,Me=Math.round(Ke*L.endValue);Le[z]=Me,L.current=Me,L.normalized=Ke,L.headroom=Math.max(0,L.endValue-Me),L.headroomNormalized=L.endValue>0?L.headroom/L.endValue:0;const Ye=he-Ke;if(Ye>H){const ut=M.get(T)||[];ut.push({index:z,inputPercent:z/bt*100,normalizedBefore:he,normalizedAfter:L.normalized,desiredNormalizedAfter:Ke,overflowNormalized:Ye,bufferedLimit:ee,limit:be,truncatedByThreshold:!0,truncatedByEnd:!1,floorNormalized:ae}),M.set(T,ut)}}const ue=Math.max(0,L.normalized-ae);L.layerNormalized=ue,ee!=null&&L.allowedNormalized!=null?L.headroomNormalized=Math.max(0,L.allowedNormalized-L.normalized):L.headroomNormalized=L.endValue>0?Math.max(0,L.endValue-L.current)/L.endValue:0,L.effectiveHeadroomNormalized=Ra(L);const Re=L.allowedNormalized!=null?Math.max(0,L.allowedNormalized-L.normalized):Number.POSITIVE_INFINITY,He=Number.isFinite(L.headroomNormalized)?Math.max(0,L.headroomNormalized):Number.POSITIVE_INFINITY,je=Number.isFinite(L.effectiveHeadroomNormalized)?Math.max(0,L.effectiveHeadroomNormalized):Number.POSITIVE_INFINITY;if(L.capacityBeforeNormalized=Ba(L,{coverageCapacity:Re,effectiveHeadroom:je,endCapacity:He}),L.capacityAfterNormalized=L.capacityBeforeNormalized,ee!=null){const Ke=ue*Y;w.set(T,L.normalized),C[T]=Math.max(0,ee-Ke),_.set(T,L.allowedNormalized??L.normalized)}else w.set(T,L.normalized),_.set(T,1),e&&(C[T]=Math.max(0,Y*(L.effectiveHeadroomNormalized??L.headroomNormalized)));It=Math.max(It,L.normalized)}),g===et.NORMALIZED){const T=TI();let L=0;for(let Y=Se.length-1;Y>=0;Y-=1){const ee=Se[Y],be=Ce.get(ee);if(!be)continue;const Le=Number.isFinite(be.normalized)?be.normalized:0,ae=Number.isFinite(be.allowedNormalized)?be.allowedNormalized:Le,$=Math.max(0,ae-Le),he=T.get(ee),ue=Number.isFinite(he?.peak)?Math.max(0,he.peak):0,Re=Number.isFinite(he?.base)?Math.max(0,he.base):0;be.frontReserveBase=0,be.frontReserveDarkerHeadroom=L,be.frontReserveApplied=0;let He=0,je=0;if(L>H&&$>H){const Me=Math.min($,md);He=Math.min(md,Math.max(ue,Me)),!Number.isFinite(Re)||Re<=H||Me>=Re?je=Me:je=Math.max(Me,Re*XI)}else if($>H){const Me=Math.min($,md);He=Me,je=Me}else He=0,je=0;be.frontReservePeak=He,be.frontReserveBase=je,T.set(ee,{peak:He,base:je}),L+=$,be.effectiveHeadroomNormalized=Ra(be);const Ke=fg(be);be.reserveState=Ke.state,be.reserveAllowanceNormalized=Ke.allowance,be.reserveAllowanceRemaining=Ke.allowance,Ke.allowance>H&&(be.effectiveHeadroomNormalized=Math.max(0,(be.effectiveHeadroomNormalized||0)+Ke.allowance))}}else pg(),Ce.forEach(T=>{T.frontReserveBase=0,T.frontReservePeak=0,T.frontReserveDarkerHeadroom=0,T.frontReserveApplied=0,T.effectiveHeadroomNormalized=Ra(T),T.reserveState="approaching",T.reserveAllowanceNormalized=0,T.reserveAllowanceRemaining=0});Ce.forEach(T=>{const L=g===et.NORMALIZED&&T.baselineShare>H?T.baselineShare:T.share;T.weightingShare=L});let Rt=0;k&&Ce.forEach(T=>{Rt+=T.baselineValue||0});const Ht=zf();let Tt=W.findIndex(T=>!mt.get(T));Tt===-1&&(Tt=W.length-1);const zt=T=>{const L=T?.weightingShare;if(Number.isFinite(L)&&L>H)return L;const Y=T?.share;return Number.isFinite(Y)&&Y>H?Y:0},Bn=g===et.EQUAL,qt=new Map;Pe?Ce.forEach((T,L)=>{let Y=typeof Pe[L]=="number"?ce(Pe[L]):0;const ee=T.share||0,be=Ht&&T.normalized<=hg,Le=zt(T);be?Y=ee>0?ee:Le:Y<=H&&(Y=Le>H?Le:ee),qt.set(L,Y)}):Ce.forEach((T,L)=>{qt.set(L,zt(T))});const st=[],R=new Map;Ce.forEach((T,L)=>{const Y=U.get(L)?.[z]||0;let ee=g===et.NORMALIZED?1:xt(L,z);const be=ct.get(L),Le=mt.get(L);if(T.lockPositive=!!Le,Bn&&ee<=H){const je=Y>H,Ke=T.headroomNormalized>H;je&&Ke&&!Le&&(ee=1)}g!==et.NORMALIZED&&!Le&&be!=null?be<Tt?ee=0:be===Tt||be===Tt+1&&ee>vl||(ee=0):Le||(ee=0);const ae=qt.get(L)??0,$=zt(T),he=Pe&&typeof Pe[L]=="number"?Pe[L]>H:!1,ue=ae>H?ae:$>H?$:0,Re=ee>H;Re&&st.push(L);const He=g===et.NORMALIZED?!0:ee>H||Le;R.set(L,{multiplier:ee,preferredShare:ue,allowNegativeFallback:He,isCandidate:Re,manualOverride:he})});const Q=new Set(st),X=st.length?1/st.length:0;Ce.forEach((T,L)=>{const Y=R.get(L);if(!Y){T.densityShare=0,T.regionShareOverride=!1,T.allowNegativeFallback=!1;return}const{multiplier:ee,preferredShare:be,allowNegativeFallback:Le,isCandidate:ae}=Y;if(ee<=H){T.densityShare=0,T.regionShareOverride=!1,T.allowNegativeFallback=Le;return}const $=be>H?be:zt(T),ue=(Bn&&ae&&Q.has(L)?X:$)*ee;ue>H?(T.densityShare=ue,T.regionShareOverride=!0,T.allowNegativeFallback=g===et.NORMALIZED):(T.densityShare=0,T.regionShareOverride=!1,T.allowNegativeFallback=Le)});const le=z/bt,ne=ce(o(s+le*l));let ie=null;if(Array.isArray(O.measurementSamples)&&O.measurementSamples.length>z){const T=O.measurementSamples[z];Number.isFinite(T)&&(ie=ce(T))}let oe=0;if(Ce.forEach(T=>{!T||!Number.isFinite(T.weight)||T.weight<=H||(oe+=T.weight*T.normalized)}),ie!=null&&Number.isFinite(ie)&&ie>=ne-H&&oe>ie+H){const T=()=>{let ae=0;return Ce.forEach($=>{const he=$.weight||0;he>H&&(ae+=he*($.normalized||0))}),ae},L=ie/Math.max(oe,H);Ce.forEach(ae=>{if(!ae||!ae.curve||ae.endValue<=0)return;const $=ce((ae.normalized||0)*L),he=Math.round($*ae.endValue);ae.curve[z]=he,ae.current=he,ae.normalized=ae.endValue>0?he/ae.endValue:0,ae.headroom=Math.max(0,ae.endValue-he),ae.headroomNormalized=ae.endValue>0?ae.headroom/ae.endValue:0}),oe=T();let Y=0;const ee=n.length*4,be=Array.from(Ce.entries()),Le=()=>{be.sort((ae,$)=>{const he=ae[1].weight||0,ue=$[1].weight||0,Re=he*(ae[1].normalized||0);return ue*($[1].normalized||0)-Re})};for(Le();oe>ie+H&&Y<ee;){Y+=1;let ae=!1;for(const[,$]of be)if(!(!$||!$.curve||$.endValue<=0)&&!($.current<=0)){$.current=Math.max(0,$.current-1),$.curve[z]=$.current,$.normalized=$.endValue>0?$.current/$.endValue:0,$.headroom=Math.max(0,$.endValue-$.current),$.headroomNormalized=$.endValue>0?$.headroom/$.endValue:0,ae=!0;break}if(!ae)break;Le(),oe=T()}Ce.forEach((ae,$)=>{const he=_.get($);Number.isFinite(he)?C[$]=Math.max(0,he-ae.normalized):C[$]=ae.headroomNormalized})}if(ie!=null&&Number.isFinite(ie)&&ie<=ne+H){Ce.forEach(L=>{const Y=L.baselineValue||0;L.current>Y&&(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] reverting to baseline",{sampleIndex:z,baselineValue:Y,correctedValue:L.current}),L.curve[z]=Y,L.current=Y,L.normalized=L.endValue>0?Y/L.endValue:0,L.headroom=Math.max(0,L.endValue-Y),L.headroomNormalized=L.endValue>0?L.headroom/L.endValue:0)});let T=0;Ce.forEach(L=>{const Y=L.weight||0;Y>H&&(T+=Y*(L.normalized||0))}),oe=T}typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&z===Math.round(.05*bt)&&console.log("[COMPOSITE] 5% diagnostics",{sampleIndex:z,measurementSample:ie,targetDensity:ne,currentDensity:oe});let de;if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[deltaCheck.before]",{sample:z,measurementSample:ie,targetDensity:ne,currentDensity:oe}),ie!=null&&Number.isFinite(ie)?de=ne-ie:de=ne-oe,de>0&&Number.isFinite(ne)&&(Number.isFinite(ie)?Math.min(ne,ie):ne)<=hg&&(Number.isFinite(ie)?ne-ie:de)<=UI&&(de=0),t&&(de=0),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[deltaCheck.after]",{sample:z,deltaDensity:de}),za("sample.beforeDistribution",T=>{if(z!==T)return null;const L=Array.from(Ce.entries()).map(([Y,ee])=>({channel:Y,baselineValue:ee.current,normalized:ee.normalized,headroom:ee.headroom,weight:ee.weight,share:ee.share,densityShare:ee.densityShare,densityContribution:ee.weight*ee.normalized}));return{sampleIndex:T,targetDensity:ne,measurementSample:ie,currentDensity:oe,deltaDensity:de,perChannel:L}}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&z===242&&console.log("[DEBUG Sample 242 @ 95%]",{sample:z,inputPercent:z/bt*100,channelData:Array.from(Ce.entries()).map(([T,L])=>({channel:T,current:L.current,normalized:L.normalized,weight:L.weight,densityContribution:L.weight*L.normalized,share:L.share,densityShare:L.densityShare})),currentDensity:oe,targetDensity:ne,deltaDensity:de,measurementDelta:Array.isArray(O.measurementDeltas)&&O.measurementDeltas[z]||0}),Array.isArray(O.measurementDeltas)&&O.measurementDeltas[z],Ce.forEach(T=>{T&&(T.blendAppliedNormalized=0,T.blendCapNormalized=Number.POSITIVE_INFINITY,T.blendWindow=0,T.blendProgress=0,T.pendingBlendCap=void 0,T.pendingBlendWindow=void 0,T.pendingBlendProgress=void 0,T.shadowBlendAppliedNormalized=0,T.shadowBlendCapNormalized=Number.POSITIVE_INFINITY,T.shadowBlendWindow=0,T.shadowBlendProgress=0,T.pendingShadowBlendCap=void 0,T.pendingShadowBlendWindow=void 0,T.pendingShadowBlendProgress=void 0,T.shadowBlendFromChannel=void 0)}),g===et.NORMALIZED){const T=fd(),L=ug(),Y=de>H,ee=de<-H;if(Y){L.clear();const be=new Set;for(let Le=1;Le<Se.length;Le+=1){const ae=Se[Le],$=Se[Le-1],he=Ce.get(ae),ue=Ce.get($);if(!he||!ue)continue;const Re=Math.max(0,Number(ue.effectiveHeadroomNormalized)||0),He=Math.max(0,Number(ue.capacityBeforeNormalized)||0),je=typeof ue.reserveState=="string"?ue.reserveState:"approaching",Ke=Number.isFinite(ue.reserveAllowanceRemaining)?Math.max(0,ue.reserveAllowanceRemaining):null,Me=Ke??Re,Ye=Number.isFinite(ue.frontReserveBase)?Math.max(0,ue.frontReserveBase):0,ut=Ye>H&&Ke!=null?Ke/Ye:Number.POSITIVE_INFINITY,jt=je==="approaching"&&ut<=JI;if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[blendCandidate]",{sample:z,channel:ae,lighter:$,lighterState:je,lighterReserveRemaining:Ke,lighterEffectiveForBlend:Me,lighterCapacity:He,lighterBaseReserve:Ye,reserveRatio:ut}),!(je==="exhausted"||je==="within"||Ke!=null&&Ke<=$p||Math.min(Me,He)<=$p||jt))continue;const kt=T.get(ae)||{progress:0,window:jn,fromChannel:$,startIndex:z};kt.fromChannel=$,Number.isInteger(kt.startIndex)||(kt.startIndex=z),kt.window=Math.max(jn,kt.window||jn),T.set(ae,kt),be.add(ae),he.pendingBlendCap=Math.max(H,LS),he.pendingBlendWindow=jn,he.pendingBlendProgress=kt.progress||0,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[blendActivate]",{sample:z,channel:ae,lighter:$,lighterState:je})}T.forEach((Le,ae)=>{if(!be.has(ae)){T.delete(ae);return}const $=Ce.get(ae);if(!$){T.delete(ae);return}const he=Math.max(0,Math.min(Le.progress||0,(Le.window||jn)-1)),ue=OI(he),Re=Number.isFinite($.capacityBeforeNormalized)?Math.max(0,$.capacityBeforeNormalized):Number.POSITIVE_INFINITY,He=Number.isFinite(Re)?Math.min(Re,ue):ue,je=Math.max(H,He);Le.allowed=je,Le.progress=he,$.blendCapNormalized=je,$.blendWindow=Le.window||jn,$.blendProgress=he,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[blendState]",{sample:z,channel:ae,allowed:je,progress:he,lighter:Le.fromChannel})})}else if(ee){T.clear();const be=new Set;for(let Le=Se.length-2;Le>=0;Le-=1){const ae=Se[Le],$=Se[Le+1],he=Ce.get(ae),ue=Ce.get($);if(!he||!ue)continue;if(Math.max(Number.isFinite(he.capacityBeforeNormalized)?he.capacityBeforeNormalized:0,he.normalized??0)<=tk){L.delete($);continue}const He=L.get($)||{progress:0,window:Ki,fromChannel:ae};He.fromChannel!==ae&&(He.progress=0,He.fromChannel=ae);const je=Math.max(0,Number.isFinite(He.progress)?He.progress:0),Ke=Math.max(Ki,Number.isFinite(He.window)?He.window:Ki),Me=Math.min(ek,wg*(je+1));He.window=Ke,He.cap=Me,L.set($,He),ue.pendingShadowBlendCap=Math.max(H,Me),ue.pendingShadowBlendWindow=Ke,ue.pendingShadowBlendProgress=je,ue.shadowBlendFromChannel=ae,be.add($)}L.forEach((Le,ae)=>{be.has(ae)||L.delete(ae)})}else T.clear(),L.clear()}else BI(),dg();const ke=z/bt*100,Fe=(T,L,Y,ee,be={})=>{if(!L||!L.curve||L.endValue<=0||!Number.isFinite(ee)||ee<=H)return 0;const Le=Y;let ae=Y;const $=v.get(T),he=I.get(T),ue=_.get(T),Re=Number.isFinite(ue)?ue:null,He=Number.isFinite(he)?he:null;let je=!1,Ke=!1,Me=!1,Ye=Number.POSITIVE_INFINITY,ut=Re!=null?Math.max(0,Re-L.normalized):Number.POSITIVE_INFINITY,jt=0;const it=ae>0;Number.isFinite(L.frontReserveBase)&&Math.max(0,L.frontReserveBase);const kt=it?Math.max(0,Number(L.reserveAllowanceRemaining)||0):0;if(it&&Number.isFinite(L.pendingBlendCap)){const dt=Math.max(H,L.pendingBlendCap);L.blendCapNormalized=dt;const Ln=Number.isFinite(L.pendingBlendWindow)&&L.pendingBlendWindow>0?L.pendingBlendWindow:jn;L.blendWindow=Ln;const sr=Number.isFinite(L.pendingBlendProgress)&&L.pendingBlendProgress>=0?L.pendingBlendProgress:0;L.blendProgress=sr}const wn=it&&Number.isFinite(L.blendCapNormalized)?Math.max(0,L.blendCapNormalized):Number.POSITIVE_INFINITY,Cn=it?Math.max(0,Number(L.blendAppliedNormalized)||0):0,An=it&&Number.isFinite(wn)?Math.max(0,wn-Cn):Number.POSITIVE_INFINITY;if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&it&&(T==="C"||T==="LK")&&console.log("[blendCapCheck]",{sample:z,channel:T,blendCapNormalized:L.blendCapNormalized,blendApplied:Cn,blendRemaining:An}),it&&An<=H?(ae=0,Me=!0):it&&Number.isFinite(An)&&ae>An+H&&(ae=An,Me=!0),!it&&Number.isFinite(L.pendingShadowBlendCap)){const dt=Math.max(H,L.pendingShadowBlendCap);L.shadowBlendCapNormalized=dt;const Ln=Number.isFinite(L.pendingShadowBlendWindow)&&L.pendingShadowBlendWindow>0?L.pendingShadowBlendWindow:Ki;L.shadowBlendWindow=Ln;const sr=Number.isFinite(L.pendingShadowBlendProgress)&&L.pendingShadowBlendProgress>=0?L.pendingShadowBlendProgress:0;L.shadowBlendProgress=sr}const $n=!it&&Number.isFinite(L.shadowBlendCapNormalized)?Math.max(0,L.shadowBlendCapNormalized):Number.POSITIVE_INFINITY,or=it?0:Math.max(0,Number(L.shadowBlendAppliedNormalized)||0);Ye=!it&&Number.isFinite($n)?Math.max(0,$n-or):Number.POSITIVE_INFINITY,!it&&Number.isFinite(Ye)&&(Ye<=H?(ae=0,Me=!0):Math.abs(ae)>Ye+H&&(ae=-Ye,Me=!0));let an=Re!=null?Math.max(0,Re-L.normalized):Number.POSITIVE_INFINITY;if(it&&an<=H&&kt>H&&Re==null&&(an=kt),it){const dt=Number.isFinite(L.frontReserveBase)?Math.max(0,L.frontReserveBase):0,Ln=Number.isFinite(L.frontReserveApplied)?Math.max(0,L.frontReserveApplied):0,sr=Math.max(0,dt-Ln);if(!be.allowReserveRelease&&g===et.NORMALIZED){const Vn=Number.isFinite(L.frontReserveDarkerHeadroom)?L.frontReserveDarkerHeadroom:0;if(sr>H&&Vn>H&&ut>H){const on=Math.abs(be.deltaDensityForSample??0);let ka=1;if(on>=vg)ka=0;else if(on>hd){const Fo=Math.max(vg-hd,H);ka=Math.max(0,1-(on-hd)/Fo)}if(ka>H){const Fo=sr*ka,Nu=Math.min(Fo,ut);Nu>H&&(ut=Math.max(0,ut-Nu),jt=Nu)}}}const No=Math.max(0,dt-(Ln+jt)),La=Re!=null?Math.max(0,ut):Math.max(0,(Number.isFinite(L.headroomNormalized)?L.headroomNormalized:0)-No);let hn=Math.max(0,La);kt>H&&Re==null&&(hn=Math.max(hn,kt)),L.effectiveHeadroomNormalized=hn,an=Re!=null?Math.max(0,ut):Math.max(0,hn);let Br=1;if(!be.allowReserveRelease&&g===et.NORMALIZED&&dt>H&&hn<=dt*Eg+H){const Vn=dt*Eg,on=dt*YI;if(Vn>on+H)if(hn<=on+H)Br=0;else{const ka=Math.max(Vn-on,H),Fo=Math.min(Vn,Math.max(on,hn));Br=Math.max(0,Math.min(1,(Fo-on)/ka))}else hn<=dt+H&&(Br=0)}Br<1-H&&(ae*=Br),L.reserveReleaseScale=Br,L.reserveReleaseHeadroom=hn;const bi=Number.isFinite(L.headroomNormalized)?Math.max(0,L.headroomNormalized):Number.POSITIVE_INFINITY,Ia=Ba(L,{coverageCapacity:an,effectiveHeadroom:hn,endCapacity:bi});L.capacityBeforeNormalized=Ia;let Zt=Ia;if(Number.isFinite(Zt)||(Zt=hn),Number.isFinite(An)&&(Zt=Math.min(Zt,An)),Zt<=H){const Vn=Number.isFinite(an)&&an<=H,on=Number.isFinite(bi)&&bi<=H;(Vn||!Vn&&!on)&&(je=!0),Number.isFinite(An)&&An<=H&&(Me=!0),on&&(Ke=!0),ae=0}else if(ae>Zt+H){const Vn=Number.isFinite(an)&&an<=Zt+H,on=Number.isFinite(bi)&&bi<=Zt+H;(Vn||!Vn&&!on)&&(je=!0),on&&(Ke=!0),Number.isFinite(An)&&Zt===An&&(Me=!0),ae=Zt}}else if(L.capacityBeforeNormalized=Math.max(0,L.normalized),ae=Math.max(ae,-L.normalized),g!==et.NORMALIZED){const dt=U.get(T)?.[z]||0;if(dt>H){const Ln=Math.min(dt,dt*gg);if(L.normalized>Ln+H){const sr=Ln-L.normalized;ae=Math.max(ae,sr)}}}if(Math.abs(ae)<=H){if(it&&Me?C[T]=Number.isFinite(An)?Math.max(0,An):0:!it&&Me&&(C[T]=Number.isFinite(Ye)?Math.max(0,Ye):0),ae>0&&g===et.NORMALIZED&&!be.allowReserveRelease&&Number.isFinite(L.frontReserveBase)){const dt=Math.max(0,Number(L.frontReserveBase)||0);Math.max(0,Number(L.frontReserveApplied)||0);const Ln=dt;L.frontReserveApplied=Ln,L.effectiveHeadroomNormalized=0,L.reserveLocked=!0,C[T]=0}return 0}const Mn=L.normalized;let xr=ce(Mn+ae);if(e&&Number.isFinite(ue)&&xr>ue+H&&(xr=ue,je=!0),Math.abs(xr-Mn)<=H)return 0;const mr=Math.max(0,Math.min(L.endValue,Math.round(xr*L.endValue)));mr===L.current&&(xr=L.endValue>0?mr/L.endValue:0),L.curve[z]=mr,L.current=mr,L.normalized=L.endValue>0?mr/L.endValue:0;const _o=L.normalized-Mn;if(it&&_o>H){if(L.blendAppliedNormalized=(L.blendAppliedNormalized||0)+_o,Number.isFinite(L.reserveAllowanceRemaining)){const dt=Math.max(0,Number(L.reserveAllowanceRemaining)||0);L.reserveAllowanceRemaining=Math.max(0,dt-_o)}}else if(!it&&_o<-H){const dt=Math.abs(_o);L.shadowBlendAppliedNormalized=(L.shadowBlendAppliedNormalized||0)+dt}L.headroom=Math.max(0,L.endValue-mr),e&&Number.isFinite(ue)?L.headroomNormalized=Math.max(0,ue-L.normalized):L.headroomNormalized=L.endValue>0?L.headroom/L.endValue:0;const iE=Ra(L),aE=Number.isFinite(L.reserveAllowanceRemaining)?Math.max(0,Number(L.reserveAllowanceRemaining)):0;if(L.effectiveHeadroomNormalized=Math.max(0,iE+aE),L.layerNormalized=Math.max(0,L.normalized-(L.coverageFloorNormalized??0)),jt>H){const dt=Number.isFinite(L.frontReserveApplied)?L.frontReserveApplied:0;L.frontReserveApplied=dt+jt}if(Number.isFinite(ue))C[T]=Math.max(0,ue-L.normalized);else{const dt=Number.isFinite(L.effectiveHeadroomNormalized)?Math.max(0,L.effectiveHeadroomNormalized):Math.max(0,L.headroomNormalized||0),Ln=it&&Number.isFinite(L.blendCapNormalized)?Math.max(0,L.blendCapNormalized-(L.blendAppliedNormalized||0)):Number.POSITIVE_INFINITY,sr=!it&&Number.isFinite(L.shadowBlendCapNormalized)?Math.max(0,L.shadowBlendCapNormalized-(L.shadowBlendAppliedNormalized||0)):Number.POSITIVE_INFINITY,No=it?Ln:sr,La=L.reserveState==="within"?Math.max(0,Number(L.reserveAllowanceRemaining)||0):dt,hn=Math.min(dt,La,No);C[T]=hn}const oE=w.get(T)||0,sE=Math.max(oE,L.normalized);w.set(T,sE);const lE=Re!=null?Math.max(0,Re-L.normalized):Number.POSITIVE_INFINITY,$m=Number.isFinite(L.headroomNormalized)?Math.max(0,L.headroomNormalized):Number.POSITIVE_INFINITY,cE=Number.isFinite(L.effectiveHeadroomNormalized)?Math.max(0,L.effectiveHeadroomNormalized):$m;L.capacityAfterNormalized=Ba(L,{coverageCapacity:lE,effectiveHeadroom:cE,endCapacity:$m});const uE=Math.max(0,Number(L.reserveAllowanceRemaining)||0),_u=fg(L);if(L.reserveState=_u.state,L.reserveAllowanceNormalized=_u.allowance,L.reserveAllowanceRemaining=Math.min(uE,_u.allowance),L.blendLimited=Me,e&&Le>0){const dt=L.normalized-Mn,Ln=ce(Mn+Le),sr=Math.max(0,Ln-L.normalized),No=Re!=null?Re-L.normalized<=wl:L.headroomNormalized<=wl;if((je||Ke||sr>H||No)&&dt>H){const La=M.get(T)||[];if(La.push({index:z,inputPercent:ke,normalizedBefore:Mn,normalizedAfter:L.normalized,desiredNormalizedAfter:Ln,overflowNormalized:sr,bufferedLimit:He??1,limit:Number.isFinite($)?$:null,truncatedByThreshold:je,truncatedByEnd:Ke,truncatedByBlend:Me,floorNormalized:L.coverageFloorNormalized??null}),M.set(T,La),S&&S.perSampleCeiling===!0){const hn=S.clampIndicesByChannel instanceof Map?S.clampIndicesByChannel:null;if(hn){if(S.channelHistory instanceof Map){const Zt=S.channelHistory.get(T);Array.isArray(Zt)?Zt[Zt.length-1]!==z&&Zt.push(z):S.channelHistory.set(T,[z])}const Br=hn.get(T);Array.isArray(Br)?Br[Br.length-1]!==z&&Br.push(z):hn.set(T,[z]);let bi=!1;const Ia=S.syntheticClampWindows instanceof Map?S.syntheticClampWindows:null;if(Ia&&!Ia.has(T)&&(Ia.set(T,z),bi=!0),bi&&Array.isArray(S.windows)){const Zt=Array.isArray(S.sampleRecords)?S.sampleRecords[z]:null,Vn=Number.isFinite(S.nextWindowId)?S.nextWindowId++:0,on=Zt&&Number.isFinite(Zt.inputPercent)?Zt.inputPercent:z/bt*100;S.windows.push({id:Vn,outgoingChannel:T,incomingChannels:[],startIndex:z,endIndex:z,inputStart:on,inputEnd:on,forced:!0,synthetic:!0})}}}}}if(L.endValue>0&&L.current>=L.endValue*NI&&ke<95){d.has(T)||d.set(T,Cg(z));const dt=p.get(z)||[];dt.push(T),p.set(z,dt)}return ee*(L.normalized-Mn)},ot=S?{}:null;ot&&Ce.forEach((T,L)=>{ot[L]=Number(C[L])||0});let Ae=null;const ge=(T=>{const L={};let Y=T;const ee={direction:T>H?"increase":T<-H?"decrease":"flat",blocked:[],sequence:[]},be=Math.max(4,Ce.size*4),Le=($,he)=>{if(!$)return 0;const ue=Number.isFinite($.effectiveHeadroomNormalized)?Math.max(0,$.effectiveHeadroomNormalized):null;if(ue!=null)return ue;const Re=_.get(he);if(Number.isFinite(Re))return Math.max(0,Re-($.normalized||0));const He=$.headroomNormalized;return Number.isFinite(He)?Math.max(0,He):0},ae=$=>{if(!$)return 0;const he=$.normalized;return Number.isFinite(he)?Math.max(0,he):0};for(let $=0;$<be&&Math.abs(Y)>H;$+=1){const he=Y>0,ue=[];let Re=!1;if(Ce.forEach((Me,Ye)=>{if(!Me||!Me.curve||Me.endValue<=0)return;if(he&&Me.reserveLocked){Me.reserveLocked=!1;return}const ut=Me.weight;if(!Number.isFinite(ut)||ut<=H||he&&Me.lockPositive)return;const jt=R.get(Ye),it=!!(jt&&jt.manualOverride),kt=Number.isFinite(Me.effectiveHeadroomNormalized)?Math.max(0,Me.effectiveHeadroomNormalized):Math.max(0,Me.headroomNormalized||0);let wn;if(he){const $n=_.get(Ye),or=Number.isFinite($n)?Math.max(0,$n-Me.normalized):Number.POSITIVE_INFINITY,an=Number.isFinite(Me.headroomNormalized)?Math.max(0,Me.headroomNormalized):Number.POSITIVE_INFINITY;wn=Ba(Me,{coverageCapacity:or,effectiveHeadroom:kt,endCapacity:an}),Me.capacityBeforeNormalized=wn}else wn=Math.max(0,Me.normalized),Me.capacityBeforeNormalized=wn;if(wn<=H)return;if(!it&&g===et.NORMALIZED&&we.has(Ye)){const $n=we.get(Ye);if(he&&$n!=null&&$n>0){let or=null;for(let an=$n-1;an>=0;an-=1){const Mn=Se[an];if(Mn===Ye)continue;const xr=Ce.get(Mn);if(!xr)continue;const mr=Le(xr,Mn);if(mr>wl){or={lighterName:Mn,lighterHeadroom:mr};break}}if(or){ee.blocked.push({channel:Ye,reason:"lighter-headroom",blockedBy:or.lighterName,headroom:or.lighterHeadroom});return}}else if(!he&&$n!=null&&$n<Se.length-1){let or=null;for(let an=$n+1;an<Se.length;an+=1){const Mn=Se[an];if(Mn===Ye)continue;const xr=Ce.get(Mn);if(!xr)continue;const mr=ae(xr);if(mr>wl){or={heavierName:Mn,heavierUsage:mr};break}}if(or){ee.blocked.push({channel:Ye,reason:"heavier-usage",blockedBy:or.heavierName,usage:or.heavierUsage});return}}}let Cn=0;if(Me.regionShareOverride){if(Cn=Me.densityShare||0,Cn<=H){if(he||!Me.allowNegativeFallback)return;Cn=Me.weightingShare||Me.share||0}}else Cn=Me.densityShare||Me.weightingShare||Me.share||0;if(Cn<=H&&(Cn=ut),Cn<=H)return;const An=wn;if(An>H){const $n=Math.pow(An,1.5);Cn*=1+$n}!he&&Number.isFinite(Me.pendingShadowBlendCap)&&(Cn*=nk),ue.push({name:Ye,info:Me,weight:ut,share:Cn,ladderIndex:we.has(Ye)?we.get(Ye):null})}),!ue.length)break;g===et.NORMALIZED&&ue.sort((Me,Ye)=>{const ut=Number.isFinite(Me.ladderIndex)?Me.ladderIndex:he?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY,jt=Number.isFinite(Ye.ladderIndex)?Ye.ladderIndex:he?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY;return he?ut-jt:jt-ut});let He=ue.reduce((Me,Ye)=>Me+Ye.share,0);He<=H&&(He=ue.length,ue.forEach(Me=>{Me.share=1}));const je=Y;let Ke=0;if(ue.forEach(Me=>{const{name:Ye,info:ut,weight:jt,share:it}=Me;if(Math.abs(je)<=H)return;let kt=je*(it/He)/jt;if(he?kt=Math.max(0,kt):kt=Math.min(0,kt),Math.abs(kt)<=H)return;const wn=Fe(Ye,ut,kt,jt,{deltaDensityForSample:de,allowReserveRelease:!1});if(ut.reserveLocked===!0){Re=!0,ut.reserveLocked=!1,ut.effectiveHeadroomNormalized=0;return}if(Math.abs(wn)>H){const Cn=wn/jt;L[Ye]=(L[Ye]||0)+Cn,Y-=wn,Ke+=Math.abs(wn),ee.sequence.push({channel:Ye,ladderIndex:Number.isFinite(Me.ladderIndex)?Me.ladderIndex:null,normalizedApplied:Cn,iteration:$,weight:jt})}}),Ke<=H){if(Re)continue;break}}return ee.remaining=Y,Ae=ee,L})(de);if(g===et.NORMALIZED){const T=fd();T.forEach((L,Y)=>{if(!L||L.active!==!0)return;const ee=Ce.get(Y);if(!ee){T.delete(Y);return}(Math.max(0,Number(ee.blendAppliedNormalized)||0)>H||de<=H)&&(L.progress=Math.min((L.progress||0)+1,L.window||jn)),L.lastSample=z,(L.progress||0)>=(L.window||jn)||!Number.isFinite(ee.blendCapNormalized)?T.delete(Y):(ee.blendProgress=L.progress||0,ee.blendWindow=L.window||jn,T.set(Y,L))})}if(g===et.NORMALIZED){const T=ug();de<-H?T.forEach((L,Y)=>{if(!L){T.delete(Y);return}const ee=Ce.get(Y);if(!ee){T.delete(Y);return}const be=Math.max(0,Number(ee.shadowBlendAppliedNormalized)||0),Le=Number.isFinite(ee.shadowBlendCapNormalized)?ee.shadowBlendCapNormalized:Number.POSITIVE_INFINITY;be>H&&Le<Number.POSITIVE_INFINITY&&be>=Le-wg*.25&&(L.progress=Math.min((L.progress||0)+1,L.window||Ki)),L.lastSample=z,(L.progress||0)>=(L.window||Ki)||!Number.isFinite(ee.shadowBlendCapNormalized)?(T.delete(Y),ee.shadowBlendCapNormalized=Number.POSITIVE_INFINITY):(ee.shadowBlendProgress=L.progress||0,ee.shadowBlendWindow=L.window||Ki,T.set(Y,L))}):de>-H&&dg()}if(g===et.NORMALIZED){const T=fd();T.forEach((L,Y)=>{if(!L||L.active!==!0)return;const ee=Ce.get(Y);if(!ee){T.delete(Y);return}(Math.max(0,Number(ee.blendAppliedNormalized)||0)>H||de<=H)&&(L.progress=Math.min((L.progress||0)+1,L.window||jn)),L.lastSample=z,(L.progress||0)>=(L.window||jn)||!Number.isFinite(ee.blendCapNormalized)?T.delete(Y):(ee.blendProgress=L.progress||0,ee.blendWindow=L.window||jn,T.set(Y,L))})}if(Ce.forEach((T,L)=>{if(!T||!T.curve)return;const Y=_.get(L),ee=Number.isFinite(Y)?Math.max(0,Y-T.normalized):Number.POSITIVE_INFINITY,be=Number.isFinite(T.headroomNormalized)?Math.max(0,T.headroomNormalized):Number.POSITIVE_INFINITY,Le=Number.isFinite(T.effectiveHeadroomNormalized)?Math.max(0,T.effectiveHeadroomNormalized):be;Number.isFinite(T.capacityBeforeNormalized)||(T.capacityBeforeNormalized=Ba(T,{coverageCapacity:ee,effectiveHeadroom:Le,endCapacity:be})),T.capacityAfterNormalized=Ba(T,{coverageCapacity:ee,effectiveHeadroom:Le,endCapacity:be})}),de<=-H&&z>0&&Ce.forEach((T,L)=>{if(!T||!T.curve||!Array.isArray(T.curve))return;const Y=T.curve[z-1],ee=T.curve[z];if(!(!Number.isFinite(Y)||!Number.isFinite(ee))&&ee>Y+H){const be=Y;T.curve[z]=be,T.current=be,T.normalized=T.endValue>0?be/T.endValue:0,T.headroom=Math.max(0,T.endValue-be),T.headroomNormalized=T.endValue>0?T.headroom/T.endValue:0}}),S&&IS(S,z,de,ge,St),g!==et.NORMALIZED&&Ce.forEach((T,L)=>{if(!T||!T.curve)return;const Y=Array.isArray(u[L])?u[L][z]:null;if(!Number.isFinite(Y)||Y<=0)return;const ee=Math.max(0,Math.round(Y*gg));if(T.curve[z]<ee){const be=Math.min(T.endValue>0?T.endValue:ve,ee);T.curve[z]=be,T.current=be,T.normalized=T.endValue>0?be/T.endValue:0,T.headroom=Math.max(0,(T.endValue>0?T.endValue:ve)-be),T.headroomNormalized=T.endValue>0?T.headroom/T.endValue:0}}),k){const T=[];ge&&typeof ge=="object"&&(Object.entries(ge).forEach(([$,he])=>{const ue=Ce.get($);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&$==="C"&&z===16&&console.log("[blendDebug]",{i:z,channel:$,blendCap:ue?.blendCapNormalized,blendApplied:ue?.blendAppliedNormalized}),T.push({channel:$,ladderIndex:we.has($)?we.get($):null,normalizedApplied:Number(he)||0,floorNormalized:ue?ue.coverageFloorNormalized:null,allowedNormalized:ue?ue.allowedNormalized:null,layerNormalized:ue?ue.layerNormalized:null,blendCapNormalized:ue&&Number.isFinite(ue.blendCapNormalized)?ue.blendCapNormalized:null,blendAppliedNormalized:ue?ue.blendAppliedNormalized:null,blendWindow:ue?ue.blendWindow:null,blendProgress:ue?ue.blendProgress:null,reserveState:ue?ue.reserveState:null,shadowBlendCapNormalized:ue&&Number.isFinite(ue.shadowBlendCapNormalized)?ue.shadowBlendCapNormalized:null,shadowBlendAppliedNormalized:ue?ue.shadowBlendAppliedNormalized:null,shadowBlendWindow:ue?ue.shadowBlendWindow:null,shadowBlendProgress:ue?ue.shadowBlendProgress:null,shadowBlendFromChannel:ue?ue.shadowBlendFromChannel:null})}),T.sort(($,he)=>{const ue=Number.isFinite($.ladderIndex)?$.ladderIndex:Number.POSITIVE_INFINITY,Re=Number.isFinite(he.ladderIndex)?he.ladderIndex:Number.POSITIVE_INFINITY;return ue-Re}));const L=Array.isArray(Ae?.blocked)?Ae.blocked.map($=>({channel:$?.channel||null,reason:$?.reason||null,blockedBy:$?.blockedBy||null,headroom:typeof $?.headroom=="number"?$.headroom:null,usage:typeof $?.usage=="number"?$.usage:null})):[],Y={},ee=new Map;let be=0;Ce.forEach(($,he)=>{const ue=Array.isArray($.curve)?Math.max(0,Number($.curve[z])||0):0;ee.set(he,ue),be+=ue}),Ce.forEach(($,he)=>{const ue=ee.get(he)||0,Re=$.endValue>0?$.endValue:Math.max(0,Number(r[he])||0),He=$.normalized,je=$.baselineValue||0,Ke=$.baselineNormalized||0,Me=$.baselineContribution||0,Ye=($.weight||0)*He,ut=_.get(he),jt=Number.isFinite(ut)?Math.max(0,ut-Ke):Re>0?Math.max(0,Re-je)/Re:0,it=Number.isFinite(ut)?Math.max(0,ut-He):$.headroomNormalized,kt=we.has(he)?we.get(he):null;Y[he]={baselineValue:je,correctedValue:ue,valueDelta:ue-je,normalizedBefore:Ke,normalizedAfter:He,normalizedDelta:He-Ke,weight:$.weight||0,shareBefore:Rt>0?je/Rt:0,shareAfter:be>0?ue/be:0,weightingShare:$.weightingShare,densityShareBefore:Rt>0?je/Rt:0,densityShareAfter:$.densityShare||0,headroomBefore:jt,headroomAfter:it,densityContributionBefore:Me,densityContributionAfter:Ye,densityContributionDelta:Ye-Me,momentum:$.momentum||0,ladderIndex:kt,ladderHeadroom:it,coverageFloorNormalized:$.coverageFloorNormalized??0,allowedNormalized:$.allowedNormalized??null,layerNormalized:$.layerNormalized??0,effectiveHeadroomAfter:$.effectiveHeadroomNormalized??it,frontReserveBase:$.frontReserveBase??0,frontReservePeak:$.frontReservePeak??0,frontReserveApplied:$.frontReserveApplied??0,frontReserveDarkerHeadroom:$.frontReserveDarkerHeadroom??0,reserveState:$.reserveState||null,reserveAllowance:$.reserveAllowanceNormalized??0,reserveAllowanceRemaining:$.reserveAllowanceRemaining??0,capacityBeforeNormalized:Number.isFinite($.capacityBeforeNormalized)?$.capacityBeforeNormalized:null,capacityAfterNormalized:Number.isFinite($.capacityAfterNormalized)?$.capacityAfterNormalized:null,reserveReleaseScale:$.reserveReleaseScale??1,reserveReleaseHeadroom:$.reserveReleaseHeadroom??$.effectiveHeadroomNormalized??it,blendCapNormalized:Number.isFinite($.blendCapNormalized)?$.blendCapNormalized:null,blendAppliedNormalized:$.blendAppliedNormalized??0,blendWindow:$.blendWindow??null,blendProgress:$.blendProgress??null,blendLimited:$.blendLimited===!0,pendingBlendCap:Number.isFinite($.pendingBlendCap)?$.pendingBlendCap:null,shadowBlendCapNormalized:Number.isFinite($.shadowBlendCapNormalized)?$.shadowBlendCapNormalized:null,shadowBlendAppliedNormalized:$.shadowBlendAppliedNormalized??0,shadowBlendWindow:$.shadowBlendWindow??null,shadowBlendProgress:$.shadowBlendProgress??null,shadowBlendFromChannel:$.shadowBlendFromChannel??null}});const Le=be;k[z]={index:z,inputPercent:z/bt*100,targetDensity:ne,measurementDensity:ie??null,deltaDensity:de,baselineInk:Rt,correctedInk:Le,inkDelta:Le-Rt,perChannel:Y,weightingMode:g},k[z].ladderSelection=T,k[z].ladderBlocked=L,k[z].ladderDirection=Ae?.direction||null,Ae&&(k[z].ladderTrace={direction:Ae.direction||null,remaining:typeof Ae.remaining=="number"?Ae.remaining:0,blocked:Array.isArray(Ae.blocked)?Ae.blocked.map($=>({channel:$?.channel||null,reason:$?.reason||null,blockedBy:$?.blockedBy||null,headroom:typeof $?.headroom=="number"?$.headroom:null,usage:typeof $?.usage=="number"?$.usage:null})):[],sequence:Array.isArray(Ae.sequence)?Ae.sequence.map($=>({channel:$?.channel||null,ladderIndex:typeof $?.ladderIndex=="number"?$.ladderIndex:null,normalizedApplied:typeof $?.normalizedApplied=="number"?$.normalizedApplied:0,iteration:typeof $?.iteration=="number"?$.iteration:null,weight:typeof $?.weight=="number"?$.weight:null})):[]});const ae=Array.isArray(me?.smoothingWindows)?me.smoothingWindows.map($=>$?{id:$.id??null,outgoingChannel:$.outgoingChannel??null,incomingChannels:Array.isArray($.incomingChannels)?$.incomingChannels.slice():[],position:$.position??$.t??0,outFactor:$.outFactor??null,forced:$.forced===!0}:null).filter(Boolean):[];ae.length&&(k[z].smoothingWindows=ae),F==null&&Math.abs(de||0)>1e-4&&(F=z)}Ce.forEach((T,L)=>{const Y=Vt.get(L);if(!Y)return;const ee=c[L],be=Array.isArray(ee)?Math.max(0,Number(ee[z])||0):0,Le=T.endValue>0?T.endValue:Math.max(0,Number(r[L])||0),ae=Le>0?ce(be/Le):0;if(!Y.locked&&ae>Y.maxNormalized+yg||Y.locked&&Y.maxNormalized>Sg&&ae>Y.maxNormalized+yg&&z-Y.peakIndex<=Math.floor(bt*HI)?(Y.maxNormalized=ae,Y.maxValue=be,Y.peakIndex=z):!Y.locked&&Y.maxNormalized>Sg&&ae+VI<Y.maxNormalized&&z/bt<=bg+.02&&(Y.locked=!0,mt.set(L,!0)),!Y.locked){const $=K.get(L);$&&z>=$.primaryEnd&&(Y.locked=!0)}}),za("sample.afterDistribution",T=>{if(z!==T)return null;const L=Array.isArray(O.measurementSamples)?O.measurementSamples[T]:null,Y=Array.from(Ce.entries()).map(([be,Le])=>{const ae=c[be],$=Array.isArray(ae)?ae[T]:0,he=Le.endValue,ue=he>0?ce($/he):0,Re=Le.weight>0?Le.weight*ue:0;return{channel:be,correctedValue:$,endValue:he,normalized:ue,weight:Le.weight,densityContribution:Re}}),ee=Y.reduce((be,Le)=>be+Le.densityContribution,0);return{sampleIndex:T,targetDensity:ne,measurementSample:L,correctedDensity:ee,perChannel:Y}}),Ce.forEach((T,L)=>{if(mt.get(L))return;const Y=K.get(L);if(!Y){mt.set(L,!0);return}z>=Y.effectiveEnd&&mt.set(L,!0)})}const Un=!!(O.autoRaiseContext&&O.autoRaiseContext.evaluated===!1);let Bt=null,Gt=null;const ir={};let Lt=n.slice();if(!Un&&Vf()&&(Bt=LI(c,{channelNames:n,endValues:r,thresholdPercent:Pi,debugSnapshots:k}),Bt&&Bt.normalizedSeriesByChannel&&Object.assign(ir,Bt.normalizedSeriesByChannel),Bt&&Array.isArray(Bt.appliedChannels)&&Bt.appliedChannels.length)){const z=new Set(Bt.appliedChannels);Array.isArray(Bt.channelsNeedingLimiter)&&Bt.channelsNeedingLimiter.forEach(J=>{z.delete(J)}),Lt=n.filter(J=>!z.has(J))}!Un&&Lt.length&&(Gt=iI(c,{channelNames:Lt,endValues:r}),Gt&&Object.assign(ir,Gt)),k&&Object.keys(ir).length&&(aI(k,{channelNames:n,normalizedSeriesByChannel:ir,correctedCurves:c,endValues:r,densityWeights:E}),N&&typeof N=="object"&&N.channelMaxima&&n.forEach(z=>{const J=c[z];if(!Array.isArray(J))return;const me=J.reduce((Pe,$e)=>{const Ce=Number($e)||0;return Ce>Pe?Ce:Pe},0);N.channelMaxima[z]=me}));const rt=new Map;Object.entries(c).forEach(([z,J])=>{if(!Array.isArray(J)||J.length!==Ie)return;const me=Vt.get(z);let Pe=me&&Number.isFinite(me.peakIndex)?me.peakIndex:0;if(!Number.isFinite(Pe)||Pe<0||Pe>bt){let Ce=0,St=-1/0;for(let At=0;At<J.length;At+=1){const It=Number(J[At])||0;It>St&&(St=It,Ce=At)}Pe=Ce}Pe=Math.max(0,Math.min(bt,Pe));const $e=Math.round(Math.min(bg,.3)*bt);Pe=Math.min(Pe,$e),rt.set(z,Pe)});const wt=[];d.forEach((z,J)=>{wt.push(`${J} channel reaches â‰¥99% ink near ${z}`)}),p.forEach((z,J)=>{z.length>=2&&wt.push(`Multiple channels (${z.join(", ")}) saturate near ${Cg(J)}`)});const Ct={};rt.forEach((z,J)=>{Ct[J]=z}),n.forEach(z=>{const J=c[z];u[z],Array.isArray(J)&&(c[z]=J)});const fr=new Map;n.forEach(z=>{const J=Math.max(0,Number(r[z])||0),me=c[z];if(!J||!Array.isArray(me)||!me.length){fr.set(z,0);return}let Pe=0;for(let $e=0;$e<me.length;$e+=1){const Ce=Math.max(0,Number(me[$e])||0),St=Math.max(0,Math.min(1,Ce/ve));St>Pe&&(Pe=St)}fr.set(z,Pe)}),w instanceof Map&&(w.clear(),fr.forEach((z,J)=>{w.set(J,z)}));const ar=MS(n,{coverageLimits:v,coverageBuffers:A,coverageThresholds:I,coverageUsage:w,coverageClampEvents:M}),qr=_a(ar.plain);if(O.densityCoverage=ar.map,O.densityCoverageSummary=qr,b.coverageByChannel=ar.map,b.coverageSummary=qr,N){N.coverageSummary=_a(qr),N.coverageLimits=qn(v),N.coverageBuffers=qn(A);const z={};M instanceof Map?M.forEach((J,me)=>{z[me]=Array.isArray(J)?J.map(Pe=>({...Pe||{}})):[]}):M&&typeof M=="object"&&Object.keys(M).forEach(J=>{const me=M[J];z[J]=Array.isArray(me)?me.map(Pe=>({...Pe||{}})):[]}),N.coverageClampEvents=z}{const z=N?{...N}:{};z.channelMaxima&&typeof z.channelMaxima=="object"&&Object.keys(z.channelMaxima).forEach($e=>{const Ce=c[$e];if(!Array.isArray(Ce))return;const St=Ce.reduce((At,It)=>{const Rt=Number(It)||0;return Rt>At?Rt:At},0);z.channelMaxima[$e]=St}),z.warnings=wt.slice(),z.peakIndices={...Ct},z.densityLadder=Se.slice(),z.ladderOrderIndex={...Ne};const J=Array.isArray(k)?k.slice():[],me=LC(J,{thresholdPercent:Pi,autoRaiseInProgress:!!(O.autoRaiseContext&&O.autoRaiseContext.evaluated===!1),channelNames:Array.isArray(z.channelNames)&&z.channelNames.length?z.channelNames.slice():Array.isArray(n)?n.slice():[]});Object.keys(me).length?z.snapshotFlags={count:Object.keys(me).length,thresholdPercent:Pi}:Object.prototype.hasOwnProperty.call(z,"snapshotFlags")&&delete z.snapshotFlags;const Pe={summary:z,snapshots:J,selectionIndex:F,snapshotFlags:me,flags:me};O.lastDebugSession=Pe,ps(Pe),typeof Qe=="object"&&Qe&&(Qe.__COMPOSITE_DEBUG_CACHE__=Pe),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] debug payload ready",{summaryKeys:Object.keys(z),snapshotCount:J.filter($e=>!!$e).length})}O.warnings=wt,O.peakIndices=Ct,O.active=!1,O.preparedContext=null,D&&typeof D=="object"&&(typeof D.setGlobalBaselineCurves=="function"&&D.setGlobalBaselineCurves(u),typeof D.setGlobalCorrectedCurves=="function"&&D.setGlobalCorrectedCurves(c),typeof D.setGlobalWarnings=="function"&&D.setGlobalWarnings(wt),typeof D.setGlobalBakedMeta=="function"&&D.setGlobalBakedMeta({source:"compositeLab",timestamp:Date.now(),channels:Array.isArray(n)?n.slice():[]}),typeof D.setCompositeCoverageSummary=="function"&&D.setCompositeCoverageSummary(O.densityCoverageSummary));const Pr=z=>du(z),En=()=>Eo();if(D&&typeof D=="object"&&(D.getCompositeDensityProfile=Pr,D.getCompositeCoverageSummary=En),Qe&&typeof Qe.LinearizationState=="object")try{Object.defineProperty(Qe.LinearizationState,"getCompositeDensityProfile",{value:Pr,configurable:!0,writable:!0}),Object.defineProperty(Qe.LinearizationState,"getCompositeCoverageSummary",{value:En,configurable:!0,writable:!0})}catch{Qe.LinearizationState.getCompositeDensityProfile=Pr,Qe.LinearizationState.getCompositeCoverageSummary=En}return Qe&&typeof Qe=="object"&&(Qe.getCompositeDensityProfile=Pr,Qe.getCompositeCoverageSummary=En),{curves:c,warnings:wt,peakIndices:Ct,weights:O.densityWeights instanceof Map?Array.from(O.densityWeights.entries()):[],measurementSamples:Array.isArray(O.measurementSamples)?O.measurementSamples.slice():[]}}function DS(){if(!ds())return!1;const e=O.lastDebugSession;return!e||!e.summary||!Array.isArray(e.snapshots)?!1:(ps(e),!0)}function fk(){const e=O.lastDebugSession;return!e||!e.summary||!Array.isArray(e.snapshots)?null:{summary:e.summary,snapshotCount:e.snapshots.filter(t=>!!t).length,selectionIndex:e.selectionIndex??null}}function du(e=0){const t=O.densityProfiles,n=O.densityConstants instanceof Map?O.densityConstants:null;if(Array.isArray(t)&&t.length>0){const u=O.densityCumulative||{},d=Array.isArray(O.channels)?O.channels:[];return Ag(e,t,n,u,d,O.measurementDeltas)}const r=D?.getGlobalData?.(),i=D?.globalCorrectedCurves;if(!r||!i)return null;const a=Rn(Aa(r));if(!a)return null;const o=Object.keys(i).filter(u=>{const d=i[u];return Array.isArray(d)&&d.length===Ie});if(!o.length)return null;const s={};o.forEach(u=>{const d=i[u];let p=0;for(let f=0;f<d.length;f+=1){const h=Number(d[f])||0;h>p&&(p=h)}s[u]=p});const l=uu(),c=kS(o,i,s,a,{weightingMode:l,smoothingPercent:a?.previewSmoothingPercent??Gn()});return Ag(e,c.profiles,c.constants,c.cumulativeDensity,o,c.measurementDeltas)}function Ag(e,t,n,r,i,a){if(!Array.isArray(t)||t.length===0)return null;const o=ce(Number.isFinite(e)?e/100:0),s=Math.max(0,Math.min(bt,Math.round(o*bt))),l=t[s];if(!l)return null;const c=n instanceof Map?n:new Map(n?Object.entries(n):[]),u={};return new Set([...Array.isArray(i)?i:[],...Array.from(c.keys())]).forEach(p=>{if(!p)return;const f=l.shares&&typeof l.shares[p]=="number"?l.shares[p]:0,h=c.get(p)||0;u[p]={share:f,constant:h,cumulative:r?.[p]||0}}),{input:Math.round(s/bt*100),densityDelta:l.density||Array.isArray(a)&&a[s]||0,perChannel:u}}function Eo(){if(O.densityCoverageSummary&&Object.keys(O.densityCoverageSummary).length)return _a(O.densityCoverageSummary);if(D&&typeof D.getCompositeCoverageSummary=="function"){const e=D.getCompositeCoverageSummary();if(e)return e}return null}D&&typeof D=="object"&&typeof D.getCompositeDensityProfile!="function"&&(D.getCompositeDensityProfile=e=>du(e));D&&typeof D=="object"&&typeof D.getCompositeCoverageSummary!="function"&&(D.getCompositeCoverageSummary=()=>Eo());Qe&&typeof Qe=="object"&&Qe.LinearizationState&&typeof Qe.LinearizationState=="object"&&typeof Qe.LinearizationState.getCompositeDensityProfile!="function"&&(Qe.LinearizationState.getCompositeDensityProfile=e=>du(e));Qe&&typeof Qe=="object"&&Qe.LinearizationState&&typeof Qe.LinearizationState=="object"&&typeof Qe.LinearizationState.getCompositeCoverageSummary!="function"&&(Qe.LinearizationState.getCompositeCoverageSummary=()=>Eo());Qe&&typeof Qe=="object"&&typeof Qe.getCompositeDensityProfile!="function"&&(Qe.getCompositeDensityProfile=e=>du(e));Qe&&typeof Qe=="object"&&typeof Qe.getCompositeCoverageSummary!="function"&&(Qe.getCompositeCoverageSummary=()=>Eo());const Hl={apply(e,t,n,r={}){try{const i=e.length;if(i<8||t<=0)return e;const a=!!r.applyWhite,o=!!r.applyBlack;if(!a&&!o)return e;const s=e.slice(),l=i-1,c=jr.getNumber("limitProximityPct"),u=jr.getNumber("slopeAbsolutePct"),d=Math.max(1,Math.round(jr.getNumber("sustainSamples"))),p=jr.getNumber("minWidthPct"),f=jr.getNumber("blackShoulderScanStartPct"),h=jr.getNumber("whiteToeScanEndPct"),g=jr.getNumber("fallbackPlateauPct"),b=new Array(i).fill(0);for(let C=1;C<i;C++)b[C]=s[C]-s[C-1];const S=Math.max(1,Math.round(c/100*t)),E=Math.max(0,u)/100,y=Math.max(1,t),v=Math.max(1,Math.round(p/100*l)),A=Math.max(d,Math.round(g/100*l));typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] begin",{channelName:n,Np:i,endValue:t,epsY:S,slopeThresholdFraction:E,sustain:d,minWidthIdx:v,arrHead:s.slice(0,8),arrTail:s.slice(-8)});let w=null;if(o){const C=Math.max(1,Math.floor(f/100*l));for(let x=C;x<=l-d;x++){if(!(t-s[x]<=S))continue;let k=!0;for(let N=0;N<d;N++)if(Math.abs(b[x+N])/y>E){k=!1;break}if(k){w=x;break}}}if(o&&w==null){let C=0;for(let P=l;P>=0&&t-s[P]<=S;P--)C++;const x=Math.max(A,v);C>=x&&(w=Math.max(1,Math.round(.88*l)),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] fallback white knee",{whiteStart:w,capCount:C,requiredCap:x}))}if(o&&w!=null){const C=Math.max(1,Math.round(S/2));if(t-s[w]>C){let x=w;for(;x<=l&&t-s[x]>C;)x++;x<=l&&t-s[x]<=C?(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] adjusting white knee forward",{prev:w,next:x}),w=x):(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] skipping white knee; delta too large",{whiteStart:w,value:s[w],capAllowance:C}),w=null)}}if(o&&w!=null){const C=Math.max(3,v);l-w<C&&(w=Math.max(1,l-C))}let M=null;if(a){const C=Math.min(l-1,Math.ceil(h/100*l));for(let x=C;x>=d;x--){if(!(s[x]<=S))continue;let k=!0;for(let N=0;N<d;N++)if(Math.abs(b[x-N])/y>E){k=!1;break}if(k){M=x;break}}}if(a&&M==null){let C=0;for(let P=0;P<=l&&s[P]<=S;P++)C++;const x=Math.max(A,v);C>=x&&(M=Math.min(l-1,Math.round(h/100*l)),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] fallback black toe",{blackEnd:M,floorCount:C,requiredFloor:x}))}if(a&&M!=null){const C=Math.max(1,Math.round(S/2));if(s[M]>C){let x=M;for(;x>=0&&s[x]>C;)x--;x>=0&&s[x]<=C?(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] adjusting black toe backward",{prev:M,next:x}),M=x):(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] skipping black toe; delta too large",{blackEnd:M,value:s[M],floorAllowance:C}),M=null)}}if(a&&M!=null){const C=Math.max(3,v);M<C&&(M=Math.min(l-1,C))}typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] detected indices",{whiteStart:w,blackEnd:M});let I=0;if(o&&w!=null){let C=w;const x=Math.max(0,C-Math.round(.1*l));for(;C>x&&t-s[C]<S;)C--;if(t-s[C]>=S&&(w=C),t-s[w]<S){const N=Math.max(Math.round(.02*t),2*S);let F=l;for(let j=Math.floor(.7*l);j<=l;j++)if(t-s[j]<=S){F=j;break}let U=Math.max(1,F-Math.round(.05*l));for(;U>1&&t-s[U]<N;)U--;w=Math.max(1,Math.min(w,U))}const P=l-w,k=typeof DEBUG_LOGS<"u"&&DEBUG_LOGS?s.slice(Math.max(0,w-2),Math.min(l+1,w+Math.max(6,Math.round(.2*P)))):null;if(P>=Math.max(3,v)){const N=Math.max(s[w],s[Math.max(0,w-1)]||0),F=Math.max(0,b[Math.max(1,w)]),U=0,j=l-w||1;for(let B=w;B<=l;B++){const G=(B-w)/j,V=G*G,K=V*G,se=2*K-3*V+1,W=K-2*V+G,fe=-2*K+3*V,Se=K-V;let we=se*N+W*F*j+fe*t+Se*U*j;we=Math.max(0,Math.min(t,we));const Ne=B>0?s[B-1]:0;s[B]=Math.max(Ne,Math.round(we))}if(I=Math.round(P/l*1e3)/10,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const B=s.slice(Math.max(0,w-2),Math.min(l+1,w+Math.max(6,Math.round(.2*P))));console.log("[AUTO LIMIT] black segment",{startIndex:w,width:P,before:k,after:B})}}else typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] white knee too narrow, skipping",{whiteStart:w,width:P,minWidthIdx:v})}let _=0;if(a&&M!=null){let C=M;const x=Math.min(l,C+Math.round(.1*l));for(;C<x&&s[C]<S;)C++;if(s[C]>=S&&(M=C),s[M]<S){const N=Math.max(Math.round(.02*t),2*S);let F=0;for(let j=Math.ceil(.3*l);j>=0;j--)if(s[j]<=S){F=j;break}let U=Math.min(l-1,F+Math.round(.05*l));for(;U<l-1&&s[U]<N;)U++;M=Math.min(M,U)}const P=M-0,k=typeof DEBUG_LOGS<"u"&&DEBUG_LOGS?s.slice(Math.max(0,M-Math.max(6,Math.round(.2*P))),Math.min(l+1,M+2)):null;if(P>=Math.max(3,v)){const N=s[M],F=0,U=Math.max(0,b[Math.max(1,M)]),j=Math.max(1,M-0);for(let B=0;B<=M;B++){const G=B/j,V=G*G,K=V*G,se=2*K-3*V+1,W=K-2*V+G,fe=-2*K+3*V,Se=K-V;let we=se*0+W*F*j+fe*N+Se*U*j;we=Math.max(0,Math.min(t,we));const Ne=B<l?s[Math.min(l,B+1)]:we;s[B]=Math.min(Math.max(s[B],Math.round(we)),Ne)}if(_=Math.round(P/l*1e3)/10,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const B=s.slice(Math.max(0,M-Math.max(6,Math.round(.2*P))),Math.min(l+1,M+2));console.log("[AUTO LIMIT] white segment",{endIndex:M,width:P,before:k,after:B})}}else typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[AUTO LIMIT] black toe too narrow, skipping",{blackEnd:M,width:P,minWidthIdx:v})}try{const C={debug:{epsY:S,slopeThresholdFraction:E,sustain:d,minWidthIdx:v,whiteStart:w,blackEnd:M}};o&&w!=null&&I>0&&(C.black={startIndex:w,widthPercent:I}),a&&M!=null&&_>0&&(C.white={endIndex:M,widthPercent:_}),n&&(C.black||C.white?Xf(n,C):Qf(n)),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&n&&console.log("[AUTO LIMIT] result",n,C)}catch{}return s}catch(i){return console.warn("Auto rolloff error:",i),e.slice()}},shouldApply(e){return e==="white"?m.autoWhiteLimitToggle?.checked||!1:e==="black"&&m.autoBlackLimitToggle?.checked||!1}};function Sm(e,t,n=!1,r={}){try{if(e===0)return{shortCircuit:!0,values:new Array(Ie).fill(0)};const i=Ee(),a=!!(r&&r.preferOriginalBaseline),o=i?.sources?.[t],s=lu(o),l=Array.isArray(i?.originalCurves?.[t])?i.originalCurves[t]:null;if(i&&i.curves&&i.curves[t]){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[buildBaseCurve] using loaded curve",{channelName:t,smartCurveDetected:n,sourceTag:i.sources?.[t],max:Math.max(...i.curves[t]),sample0:i.curves[t][0],sample128:i.curves[t][128],sample255:i.curves[t][255]});const p=i.curves[t];if(!Array.isArray(p)||p.length===0||Math.max(...p)===0)return{shortCircuit:!0,values:new Array(Ie).fill(0)};const f=a&&l?l:p;let h=(n||s)&&!a;if(!h&&s)try{const S=Math.max(...f),E=i?.baselineEnd?.[t];S>=ve*.99&&typeof E=="number"&&E>0&&(h=!0)}catch{}if(h)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[buildBaseCurve] treat as Smart (using stored Smart samples)",{channelName:t,endValue:e,curveMax:Math.max(...f)}),{shortCircuit:!1,values:f.slice()};typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[buildBaseCurve] treat as loaded measurement",{channelName:t,endValue:e,preferOriginalBaseline:a,hasOriginalCurve:!!l});const g=i.baselineEnd&&typeof i.baselineEnd[t]=="number"?i.baselineEnd[t]:Math.max(...f),b=g>0?e/g:0;return{shortCircuit:!1,values:f.map(S=>Math.round(S*b))}}const c=Te.get(t);if(c&&c.points&&c.points.length>=2){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[buildBaseCurve] falling back to ControlPoints sample",{channelName:t,endValue:e,pointCount:c.points.length});const p=c.interpolation==="linear"?"linear":"smooth",f=Te.normalize(c.points),h=new Array(Ie);for(let g=0;g<Ie;g++){const b=g/bt*100,S=Te.sampleY(f,p,b),E=Math.max(0,S);h[g]=Math.round(E/100*e)}return{shortCircuit:!1,values:h}}const u=new Array(Ie),d=e/bt;for(let p=0;p<Ie;p++)u[p]=Math.round(p*d);return{shortCircuit:!1,values:u}}catch(i){return console.warn("Error in buildBaseCurve:",i),{shortCircuit:!0,values:new Array(Ie).fill(0)}}}function vm(e,t={}){const{channelName:n,endValue:r,interpolationType:i,smoothingPercent:a,smartApplied:o}=t;if(!n||o)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[per-channel] skipped",{channelName:n,smartApplied:o}),e;let s=D.getPerChannelData(n);if(s||(s=mg.getPerChannelData(n)),!s)return e;let l=D.isPerChannelEnabled(n);if(l||(l=mg.isPerChannelEnabled(n)),!l)return e;typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[PER-CHANNEL DEBUG] Checking LAB bypass for channel:",n,{hasPerEntry:!!s,perEntryFormat:s?.format});const c=Aa(s)||s,u=Rn(c);if(!u||!Array.isArray(u.samples)||u.samples.length<2)return e;const d=typeof u.domainMin=="number"?u.domainMin:0,p=typeof u.domainMax=="number"?u.domainMax:1,f=Number.isFinite(a)?a:typeof u.previewSmoothingPercent=="number"?u.previewSmoothingPercent:0;ba(n,"per_baseValues",e);let h=f,g={...u,__debugChannelName:n,__debugStage:"per",smoothingAlgorithm:Wb(u.smoothingAlgorithm||"smoothing-splines")};f>0&&Array.isArray(u.previewSamples)&&(g={...g,samples:u.previewSamples.slice()},h=0),ba(n,"per_lutSamples",Array.isArray(g.samples)?g.samples:[]);let b=pu(e,g,d,p,r,i,h);return ba(n,"per_afterApply1DLUT",b),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[per-channel] apply1DLUT",{channel:n,samples:u.samples.length,domainMin:d,domainMax:p,first:g.samples[0],mid:g.samples[Math.floor(g.samples.length/2)],last:g.samples[g.samples.length-1],effectiveSmoothing:h}),b}function Em(e,t={}){const{channelName:n,endValue:r,applyLinearization:i,interpolationType:a,smoothingPercent:o,smartApplied:s}=t,l=D.getGlobalData(),c=D.globalApplied;if(!l||!c||!i)return e;const u=Ee()?.keyPointsMeta?.[n]||{},d=On();let p=!!u.bakedGlobal;if(!p&&typeof D?.isGlobalBaked=="function"&&D.isGlobalBaked()){const x=typeof D.getGlobalBakedMeta=="function"?D.getGlobalBakedMeta():null;x&&Array.isArray(x.channels)&&x.channels.length>0?p=x.channels.includes(n):p=!0}p&&d<.999&&(p=!1);const f=typeof D?.getGlobalDataSource=="function"?D.getGlobalDataSource():null;if(p&&f!=="baked"&&(p=!1),p||s)return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[global] skipped",{channelName:n,bakedGlobal:p,smartApplied:s}),e;O.active&&lk(n,e);const g=Aa(l)||l,b=Rn(g);if(!b||!Array.isArray(b.samples)||b.samples.length<2)return e;const S=typeof b.domainMin=="number"?b.domainMin:0,E=typeof b.domainMax=="number"?b.domainMax:1,y=Number.isFinite(o)?o:typeof b.previewSmoothingPercent=="number"?b.previewSmoothingPercent:0;let v=null;if(typeof D?.getGlobalBaselineCurves=="function")try{const x=D.getGlobalBaselineCurves();x&&Array.isArray(x[n])&&(v=x[n].slice())}catch(x){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[global] failed to read baseline curves from LinearizationState:",x)}if((!v||!v.length)&&typeof Ee=="function"){const P=Ee()?.plotBaseCurves?.[n];Array.isArray(P)&&P.length&&(v=P.slice())}(!v||!v.length||Array.isArray(e)&&v.length!==e.length)&&(v=Array.isArray(e)?e.slice():[]);let A=b,w=y;y>0&&Array.isArray(b.previewSamples)&&(A={...b,samples:b.previewSamples.slice()},w=0);const M=pu(e,A,S,E,r,a,w),I=d;if(!Array.isArray(M)||M.length===0||I>=.999)return M;if(I<=.001)return v.length?v:e;const _=Math.max(M.length,v.length),C=new Array(_);for(let x=0;x<_;x+=1){const P=Number.isFinite(v[x])?v[x]:0,k=Number.isFinite(M[x])?M[x]:P;C[x]=Math.round(P+(k-P)*I)}return typeof ba=="function"&&ba(n,"global_gainBlend",C.slice()),C}function PS(e,t,n,r){const i=Hl.shouldApply("white"),a=Hl.shouldApply("black");return!i&&!a?e:Hl.apply(e,t,n,{applyWhite:i,applyBlack:a})}const Vp=new Map;let xS=0;function BS(){Vp.clear(),xS+=1}function mk(e,t,n,r){const i=r?.smoothingPercent??0,a=r?.forceSmartApplied??null,o=Ni(t)?"smart":"linear";return`v${xS}:${t}:${e}:${n}:${i}:${a}:${o}`}function Yt(e,t,n=!1,r={}){try{if(e===0)return new Array(Ie).fill(0);const i=mk(e,t,n,r),a=Vp.get(i);if(a)return a.slice();const o=typeof DEBUG_LOGS<"u"&&DEBUG_LOGS;o&&console.log("[MAKE256] start",{channelName:t,endValue:e,applyLinearization:n}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("DEBUG: make256() called:",{endValue:e,channelName:t,applyLinearization:n,hasGlobalLinearizationData:!!D.getGlobalData(),globalLinearizationApplied:D.globalApplied,hasPerChannelLinearization:!!D.getPerChannelData(t)});const s=r||{};let l=Ni(t);o&&console.log("[MAKE256] smartApplied initial",{channelName:t,smartApplied:l}),Object.prototype.hasOwnProperty.call(s,"forceSmartApplied")&&(l=!!s.forceSmartApplied,o&&console.log("[MAKE256] smartApplied forced override",{channelName:t,smartApplied:l}));const c=Sm(e,t,l,s);if(c.shortCircuit)return c.values;let u=c.values.slice();o&&console.log("[MAKE256] after base",{channelName:t,first:u.slice(0,10),mid:u[Math.floor(u.length/2)],last:u.slice(-10)}),za("make256.base",y=>!Array.isArray(u)||y>=u.length?null:{channelName:t,sampleIndex:y,value:u[y],stage:"base"});const d=m.curveSmoothingMethod?.value||"cubic",p=D.getGlobalData(),f=D.globalApplied,h=D.getPerChannelData(t),g=p&&f&&pr(p)||h&&pr(h);let b=0;if(g){const y=pr(h)?h:p;y&&typeof y.previewSmoothingPercent=="number"?b=y.previewSmoothingPercent:b=Gn()}u=vm(u,{channelName:t,endValue:e,interpolationType:d,smoothingPercent:b,smartApplied:l}),o&&console.log("[MAKE256] after per-channel",{channelName:t,first:u.slice(0,10),mid:u[Math.floor(u.length/2)],last:u.slice(-10)}),za("make256.afterPerChannel",y=>!Array.isArray(u)||y>=u.length?null:{channelName:t,sampleIndex:y,value:u[y],stage:"afterPerChannel"}),u=Em(u,{channelName:t,endValue:e,applyLinearization:n,interpolationType:d,smoothingPercent:b,smartApplied:l}),o&&console.log("[MAKE256] after global",{channelName:t,first:u.slice(0,10),mid:u[Math.floor(u.length/2)],last:u.slice(-10)}),za("make256.afterGlobal",y=>!Array.isArray(u)||y>=u.length?null:{channelName:t,sampleIndex:y,value:u[y],stage:"afterGlobal"}),u=PS(u,e,t,l),o&&console.log("[MAKE256] final",{channelName:t,first:u.slice(0,10),mid:u[Math.floor(u.length/2)],last:u.slice(-10)}),za("make256.final",y=>!Array.isArray(u)||y>=u.length?null:{channelName:t,sampleIndex:y,value:u[y],stage:"final"});const S=r&&Object.prototype.hasOwnProperty.call(r,"normalizeToEnd")?!!r.normalizeToEnd:Hr(t),E=Number.isFinite(e)?Math.max(0,Math.min(ve,Math.round(e))):0;if(S&&E>0){let y=0;for(let v=0;v<u.length;v+=1){const A=u[v];Number.isFinite(A)&&A>y&&(y=A)}if(y>0&&Math.abs(y-E)>.5){const v=E/y;o&&console.log("[MAKE256] normalizeToEnd",{channelName:t,currentMax:y,targetMax:E,scaleRatio:v});for(let A=0;A<u.length;A+=1){const w=u[A]*v;u[A]=Math.max(0,Math.min(ve,Math.round(w)))}}}return Vp.set(i,u.slice()),u}catch(i){return console.error("Error in make256:",i),qc(`Curve generation failed for ${t}: ${i.message}`),new Array(Ie).fill(0)}}function wm(e,t,n,r,i){try{const a=e||{},o=typeof a=="object"&&a.__debugChannelName?a.__debugChannelName:null,s=typeof a.domainMin=="number"?a.domainMin:t,l=typeof a.domainMax=="number"?a.domainMax:n,c=Math.abs(l-s)>1e-9?l-s:1,u=Wb(typeof a=="object"&&a.smoothingAlgorithm||m?.tuningPostAlgorithm?.value||"smoothing-splines");let d=[],p=[],f=a.sourceSpace;const h=y=>{const v=new Array(y);for(let A=0;A<y;A++)v[A]=s+(y===1?0:A/(y-1)*c);return v},g=y=>Array.isArray(y)?y.slice():[];if(Array.isArray(e))d=g(e),i>0&&(d=cs.applySmoothingReduction(d,i,u)),p=h(d.length);else if(a&&typeof a=="object"){let y=!1;if(typeof a.getSmoothingControlPoints=="function"){let v=null;if(i>0)try{v=a.getSmoothingControlPoints(i)}catch(A){console.warn("getSmoothingControlPoints failed, falling back to base samples:",A)}if(v&&Array.isArray(v.samples)&&v.samples.length>=2){d=v.samples.slice();const A=Array.isArray(v.xCoords)&&v.xCoords.length===d.length?v.xCoords.slice():null;A?p=A.map(w=>s+ce(w)*c):p=h(d.length),v.sourceSpace&&(f=ft.normalizeSpace(v.sourceSpace)),y=!0}}if(!y){i>0&&Array.isArray(a.baseSamples)&&a.baseSamples.length?d=a.baseSamples.slice():Array.isArray(a.samples)&&a.samples.length?d=a.samples.slice():Array.isArray(a.originalSamples)&&a.originalSamples.length&&(d=a.originalSamples.slice()),d.length>=2&&i>0&&(d=cs.applySmoothingReduction(d,i,u));const v=Math.max(3,Math.round(d.length));p=new Array(v);for(let A=0;A<v;A++)p[A]=s+A/Math.max(1,v-1)*c;f=a.sourceSpace}}if(!Array.isArray(d)||d.length<2)return null;const b=ft.convertSamples(d,{from:f,to:ft.SPACE.PRINTER,metadata:a.conversionMeta||{}});d=b.values.map(ce),f=b.sourceSpace,Nc()&&(d[0]=0,d[d.length-1]=1),(!Array.isArray(p)||p.length!==d.length)&&(p=h(d.length)),o&&ba(o,`${a.__debugStage||"per"}_lutSamplesProcessed`,d.slice());const S=String(r||"cubic").toLowerCase();let E;if(S==="pchip"||S==="smooth")E=zr(p,d);else if(S==="catmull"){const y=Number(m?.catmullTension?.value)||0;E=Pb(p,d,Math.max(0,Math.min(1,y/100)))}else S==="linear"?E=y=>{if(y<=p[0])return d[0];if(y>=p[p.length-1])return d[d.length-1];let v=0;for(let x=0;x<p.length-1;x++)if(y>=p[x]&&y<=p[x+1]){v=x;break}const A=Math.min(v+1,p.length-1),w=p[v],M=p[A],I=d[v],_=d[A];if(M===w)return I;const C=(y-w)/(M-w);return(1-C)*I+C*_}:E=Db(p,d);return{interpolationFunction:E,lutDomainMin:s,lutDomainMax:l,domainSpan:c}}catch(a){return console.error("Error preparing LUT interpolation:",a),null}}function pu(e,t,n=0,r=1,i=ve,a="cubic",o=0){return _c()?OS(e,t,n,r,i,a,o):TS(e,t,n,r,i,a,o)}function TS(e,t,n=0,r=1,i=ve,a="cubic",o=0){try{if(!Array.isArray(e)||e.length===0)return[];const s=wm(t,n,r,a,o);if(!s)return e.slice();const{interpolationFunction:l,lutDomainMin:c,domainSpan:u}=s,d=Math.max(1,i||ve),p=typeof c=="number"?c:0,f=Math.abs(u)>1e-9?u:1,h=1e-6;if(uc){const k=e.map(N=>{const F=Number(N)||0,U=d>0?F/d:0,j=p+ce(U)*f,B=ce(l(j));return Math.round(B*d)});return k}const g=new Array(Ie);for(let k=0;k<Ie;k+=1){const N=Ie>1?k/(Ie-1):0,F=p+N*f,U=ce(l(F)),j=ce(N),B=j>h?j:h;g[k]=Mg(U/B)}const b=Math.max(0,Sl-cg),S=Math.min(1,Sl+cg),E=gk(g);let y=null,v=1/0,A=null,w=1/0;for(let k=1;k<Ie-1;k+=1){const N=E[k],F=Math.abs(N-1),U=Ie>1?k/(Ie-1):0,j=U>=b&&U<=S;if(F<w&&(w=F,A=k),j){if(F<v-1e-6)v=F,y=k;else if(Math.abs(F-v)<=1e-6&&y!==null){const B=Math.abs(U-Sl),G=Math.abs(y/(Ie-1)-Sl);B<G&&(y=k)}}}const M=y??A??Math.floor(Ie/2),I=Math.max(1,g[M]||1),_=g.map(k=>Mg(k/I));let C=0,x=0;const P=e.map((k,N)=>{const F=Number(k)||0;F>C&&(C=F);const U=e.length>1?N/(e.length-1):0,j=hk(_,U),B=Math.max(0,Math.min(ve,Math.round(F*j)));return B>x&&(x=B),B});if(C>0&&x>0&&Math.abs(x-C)>1){const k=C/x;for(let N=0;N<P.length;N+=1){const F=P[N]*k;P[N]=Math.max(0,Math.min(ve,Math.round(F)))}}return P}catch(s){return console.error("Error in apply1DLUT:",s),e.slice()}}function OS(e,t,n=0,r=1,i=ve,a="cubic",o=0){try{if(!Array.isArray(e)||e.length===0)return[];const s=wm(t,n,r,a,o);if(!s)return e.slice();const{interpolationFunction:l,lutDomainMin:c,lutDomainMax:u}=s,d=Math.max(1,i||ve),p=_S(d,l,c,u,e.length),f=dc(e),h=NS(e,p,f,{maxOutput:d}),g=FS(h);return g}catch(s){return console.error("Error in apply1DLUTActiveRange:",s),e.slice()}}function dc(e,{threshold:t=0}={}){if(!Array.isArray(e)||e.length===0)return{startIndex:-1,endIndex:-1,span:0,isActive:!1};const n=Number.isFinite(t)?t:0;let r=-1,i=-1;for(let o=0;o<e.length;o++)if(e[o]>n){r=o;break}for(let o=e.length-1;o>=0;o--)if(e[o]>n){i=o;break}const a=r>=0&&i>=r;return{startIndex:r,endIndex:i,span:a?i-r:0,isActive:a}}function _S(e,t,n=0,r=1,i=Ie){if(typeof t!="function"||i<=0)return new Array(Math.max(0,i)).fill(0);const a=new Array(i),o=Math.abs(r-n)>1e-9?r-n:1,s=Math.max(1,Number(e)||ve);for(let l=0;l<i;l++){const c=i===1?0:l/(i-1),u=n+c*o,d=ce(t(u));a[l]=Math.round(d*s)}return a}function NS(e,t,n,r={}){if(!Array.isArray(e)||e.length===0)return[];if(!Array.isArray(t)||t.length===0)return e.slice();const i=n&&typeof n=="object"?n:dc(e);if(!i||!i.isActive)return e.slice();const a=dc(t,{threshold:r.targetThreshold??0});if(!a.isActive)return e.slice();const o=new Array(e.length).fill(0),s=Math.max(1,Number(r.maxOutput)||ve),l=Math.max(1,i.span||0),c=Math.max(1,a.span||0),u=p=>Number.isNaN(p)?a.startIndex:Math.max(a.startIndex,Math.min(a.endIndex,p)),d=p=>{const f=u(p);return t[f]??0};for(let p=0;p<e.length;p++){if(p<i.startIndex||p>i.endIndex){o[p]=0;continue}const f=l===0?0:(p-i.startIndex)/l,h=a.startIndex+f*c;if(!Number.isFinite(h)){o[p]=0;continue}const g=Math.floor(h),b=Math.ceil(h),S=ce(h-g),E=d(g),y=d(b),v=(1-S)*E+S*y;o[p]=Math.round(Math.max(0,Math.min(s,v)))}return o}function FS(e){if(!Array.isArray(e)||e.length===0)return[];const t=e.slice();for(let n=1;n<t.length;n++)t[n]<t[n-1]&&(t[n]=t[n-1]);return t}function hk(e,t){if(!Array.isArray(e)||e.length===0)return 1;if(e.length===1)return e[0];const r=ce(Number(t)||0)*(e.length-1),i=Math.floor(r),a=Math.min(e.length-1,i+1),o=r-i,s=e[i],l=e[a];return s+(l-s)*o}function gk(e){if(!Array.isArray(e)||e.length===0)return[];const t=new Array(e.length);for(let n=0;n<e.length;n+=1){let r=0,i=0;for(let a=n-1;a<=n+1;a+=1)a>=0&&a<e.length&&(r+=e[a],i+=1);t[n]=i>0?r/i:e[n]}return t}function Mg(e){return Number.isFinite(e)?Math.max(II,Math.min(kI,e)):1}function Cm(){try{const e=lt(),t=["## QuadToneRIP "+e.channels.join(","),"# Printer: "+e.name,"# quadGEN modular build"],n=m.userNotes?.value?.trim();if(n&&(t.push("#"),t.push("# Notes:"),n.split(`
`).forEach(i=>{const a=i.trim();t.push(a?"# "+a:"#")})),D.hasAnyLinearization()){t.push("#"),t.push("# Linearization Applied:");const i=D.getGlobalData();i&&D.globalApplied&&t.push(`# - Global: ${i.filename||"unknown file"} (affects all channels)`),Object.keys(D.perChannelData).forEach(a=>{if(D.isPerChannelEnabled(a)){const o=D.getPerChannelData(a);t.push(`# - ${a}: ${o?.filename||"unknown file"}`)}})}return t.push(""),e.channels.forEach(i=>{const a=_I(i);if(!a)return;const o=a.querySelector(".end-input"),s=o?q.clampEnd(o.value):0;if(s>0){const l=Yt(s,i,!0),c=typeof globalThis<"u"?globalThis:typeof window<"u"?window:null;if(c&&c.__COMPOSITE_AUDIT__&&c.__COMPOSITE_AUDIT__.enabled)try{const u=c.__COMPOSITE_AUDIT__,d=Array.isArray(u.events)?u.events:u.events=[],p={channelName:i,stage:"export",valueSample_242:Array.isArray(l)&&l.length>242?l[242]:null,endValue:s};d.push({stage:"export.make256",payload:p,ts:Date.now()}),typeof u.log=="function"&&u.log("export.make256",p)}catch(u){console.warn("[COMPOSITE_AUDIT] export logging failed:",u)}l.forEach(u=>{t.push(u.toString())})}else for(let l=0;l<Ie;l++)t.push("0")}),t.join(`
`)+`
`}catch(e){return console.error("Error in buildFile:",e),`# Error generating .quad file
`}}Xe("processingPipeline",{make256:Yt,invalidateMake256Cache:BS,apply1DLUT:pu,apply1DLUTFixedDomain:TS,apply1DLUTActiveRange:OS,detectActiveRange:dc,calculateLinearizationTargets:_S,remapActiveRange:NS,enforceMonotonic:FS,buildFile:Cm,buildBaseCurve:Sm,applyPerChannelLinearizationStep:vm,applyGlobalLinearizationStep:Em,replayCompositeDebugSessionFromCache:DS,getCompositeDebugSessionCache:fk,setLegacyLUTMappingEnabled:DI,isLegacyLUTMappingEnabled:PI},{exposeOnWindow:typeof window<"u",windowAliases:["make256","invalidateMake256Cache","apply1DLUT","buildFile","buildBaseCurve"]});const Ci=typeof globalThis<"u"?globalThis:{},fu={colorMuse:`GRAY	LAB_L	LAB_A	LAB_B
0	97.15	0.00	0.00
5	97.14	0.00	0.00
10	95.90	0.00	0.00
15	93.30	0.00	0.00
20	90.06	0.00	0.00
25	85.89	0.00	0.00
30	79.22	0.00	0.00
35	71.65	0.00	0.00
40	64.43	0.00	0.00
45	58.21	0.00	0.00
50	52.13	0.00	0.00
55	46.63	0.00	0.00
60	41.83	0.00	0.00
65	38.50	0.00	0.00
70	35.63	0.00	0.00
75	31.53	0.00	0.00
80	29.94	0.00	0.00
85	27.34	0.00	0.00
90	25.15	0.00	0.00
95	22.14	0.00	0.00
100	18.93	0.00	0.00`,gammaCube:`TITLE "Gamma 2.2 Curve Example"
# Sample 1D LUT with gamma 2.2 curve
LUT_1D_SIZE 16
DOMAIN_MIN 0.0
DOMAIN_MAX 1.0

0.000000
0.033037
0.069675
0.109243
0.152036
0.198312
0.248303
0.302222
0.360259
0.422584
0.489349
0.560691
0.636732
0.717578
0.803322
1.000000`};function To(e,t,n="text/plain"){const r=new Blob([e],{type:n}),a=(Ci.document||(typeof document<"u"?document:null))?.defaultView,o=Ci.URL||a?.URL;if(!o?.createObjectURL||!o?.revokeObjectURL)throw new Error("URL API unavailable for downloadFile");const s=o.createObjectURL(r),l=document.createElement("a");l.href=s,l.download=t,document.body.appendChild(l),l.click(),o.revokeObjectURL(s),document.body.removeChild(l)}function Hp(e,t){return Do[e]?.params?.[t]||null}function qp(){try{const e=Ci.contrastIntent||{},t=String(e.id||"linear");if(t==="linear")return"LIN";if(t==="soft"||t==="hard"||t==="custom_gamma"){const n=Number(e.params?.gamma??(Hp(t,"gamma")||1));if(!isFinite(n)||n<=0)return"G100";const r=Math.round(n*100);return`G${String(r).padStart(3,"0")}`}return t==="filmic"||t==="custom_filmic"?"FILM":t==="pops_standard"?"POPS":t==="custom_points"||t.startsWith("custom")?"CUST":t.substring(0,4).toUpperCase()}catch{return"LIN"}}function bk(){try{if(D?.hasAnyLinearization)return D.hasAnyLinearization();if(Ci){const e=!!(Ci.linearizationData&&Ci.linearizationApplied),t=Ci.perChannelLinearization,n=t&&Object.keys(t).some(r=>Ci.perChannelEnabled?.[r]);return e||n}return!1}catch{return!1}}function ws(){try{const e=m.printerSelect||document.getElementById("printerSelect");if(!e)return"untitled";const t=dn[e.value];if(!t)return"untitled";let r=[t.name.replace(/^Epson\s+/,"").replace(/\s+/g,"")];const i=m.rows||document.getElementById("rows");if(i&&Array.from(i.children).forEach(o=>{if(o.id==="noChannelsRow")return;const s=o.querySelector("td span span:nth-child(2)"),l=o.querySelector(".end-input");if(s&&l){const c=s.textContent.trim(),u=q.clampEnd(l.value);if(u>0){const d=Math.round(q.computePercentFromEnd(u));r.push(c+d)}}}),bk()){const o=qp();o&&r.push(o),r.push("CORRECTED")}return r.join("_")}catch(e){return console.warn("Error generating filename:",e),"untitled"}}function wo(){try{const e=m.filenameInput||document.getElementById("filenameInput");if(!e)return;e.dataset.userEdited||(e.value=ws(),e.dispatchEvent(new Event("input")))}catch(e){console.warn("Error updating filename:",e)}}function yk(){const e=m.printerSelect;if(!e)throw new Error("Printer not selected");const t=dn[e.value];if(!t)throw new Error("Invalid printer selection");const n=["## QuadToneRIP "+t.channels.join(","),"# Printer: "+t.name,`# quadGEN ${Sa} by David Marsh`],r=m.userNotes?.value?.trim();r&&(n.push("#"),n.push("# Notes:"),r.split(`
`).forEach(l=>{const c=l.trim();n.push(c?"# "+c:"#")}));const i=D.getGlobalData?.()||null,a=!!(i&&D.globalApplied&&pr(i)),o=[];if(t.channels.forEach(l=>{if(!D.isPerChannelEnabled?.(l))return;const c=D.getPerChannelData?.(l);if(!c||!pr(c))return;const u=c.filename||"unknown file",d=Array.isArray(c.samples)?c.samples.length:0;o.push({channelName:l,filename:u,count:d})}),a||o.length>0){if(n.push("#"),n.push("# Linearization Applied (LAB measurements):"),a){const l=i.filename||"unknown file",c=Array.isArray(i.samples)?i.samples.length:0;n.push(`# - Global: ${l} (${c} points, affects all channels)`)}o.length>0&&(n.push("# - Per-channel:"),o.forEach(({channelName:l,filename:c,count:u})=>{n.push(`#   ${l}: ${c} (${u} points)`)})),typeof va=="function"&&va()&&(n.push("#   Normalization mode: log-density (optical)"),n.push("#   Note: Exported curve reflects Dmax-normalized optical calibration."))}return n.push("#"),n.push(...Sk()),t.channels.forEach((l,c)=>{const u=m.rows.children[c];if(!u||u.id==="noChannelsRow")return;const d=u.querySelector(".end-input"),p=q.clampEnd(d?d.value:0),f={normalizeToEnd:Hr(l)},h=Yt(p,l,!0,f),g=typeof globalThis<"u"?globalThis:typeof window<"u"?window:null;if(g&&g.__COMPOSITE_AUDIT__&&g.__COMPOSITE_AUDIT__.enabled)try{const b=g.__COMPOSITE_AUDIT__,S=Array.isArray(b.events)?b.events:b.events=[];S.push({stage:"export.make256",payload:{channelName:l,stage:"export",valueSample_242:Array.isArray(h)&&h.length>242?h[242]:null,endValue:p},ts:Date.now()}),typeof b.log=="function"&&b.log("export.make256",S[S.length-1].payload)}catch(b){console.warn("[COMPOSITE_AUDIT] export logging failed:",b)}n.push("# "+l+" curve"),n.push(...h.map(String))}),n.join(`
`)+`
`}function Sk(){const e=["# Limits summary:"],t=Ee(),n=t?.curves||{},r=t?.baselineEnd||{};return Array.from(m.rows.children).forEach(i=>{if(i.id==="noChannelsRow")return;const a=i.querySelector("td span span:nth-child(2)"),o=i.querySelector(".end-input"),s=i.getAttribute("data-channel");if(!a||!o)return;const l=a.textContent.trim(),c=s||l;let u=0;const d=Array.isArray(n[c])?n[c]:null;if(d&&d.length&&(u=Math.max(...d)),u<=0){const p=r[c];Number.isFinite(p)&&p>0&&(u=q.clampEnd(p))}if(u<=0&&(u=q.clampEnd(o.value)),u<=0)e.push(`#   ${l}: disabled`);else{const p=u/ve*100,h=Math.abs(p-Math.round(p))<1e-9?String(Math.round(p)):p.toFixed(2);e.push(`#   ${l}: max ${h}%`)}}),e}function vk(){try{const e=yk();if(!e||e.length===0)return{success:!1,message:"Failed to generate .quad file content. Check that channels are properly configured."};const t=m.filenameInput||document.getElementById("filenameInput");let n;const r=t?t.value.trim():"";if(r){const i=r.replace(/\.quad$/,"");n=`${Yo(i)}.quad`}else n=`${ws()}.quad`;return To(e,n,"text/plain"),{success:!0,message:`Successfully generated and downloaded ${n}`}}catch(e){return console.error("Error generating quad file:",e),{success:!1,message:`Error generating .quad file: ${e.message}`}}}function GS(){To(fu.colorMuse,"LAB-Data-sample.txt","text/plain")}function RS(){To(fu.gammaCube,"LUT_sample.cube","text/plain")}function Ek(e){return new Promise((t,n)=>{const r=new FileReader;r.onload=i=>{t(i.target.result)},r.onerror=i=>{n(new Error(`Failed to read file: ${i.message}`))},r.readAsText(e)})}const Lg={8:["K","C","M","Y","LC","LM","LK","LLK"],10:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]};function wk(e){const t=e.split(`
`).map(c=>c.trim());let n=[],r=!1;for(let c=0;c<t.length;c++){const u=t[c].trim();if(u.startsWith("## QuadToneRIP ")){n=u.substring(15).split(",").map(p=>p.trim()),r=!0;break}}const i=[];let a=[];for(let c=0;c<t.length;c++){const u=t[c].trim();if(u&&!u.startsWith("#")){if(/^\d+$/.test(u)){const d=parseInt(u,10);if(d<0||d>65535)throw new Error(`Invalid data value ${d} at line ${c+1}. QuadToneRIP values must be 0-65535.`);i.push(d)}else if(a.push(`Line ${c+1}: "${u}"`),a.length>10)break}}if(i.length<256)throw new Error(`Insufficient data: found only ${i.length} values, need at least 256 for one channel`);if(a.length>0){const c=a.slice(0,3).join(", ");console.warn(`Found ${a.length} non-numeric lines in data section: ${c}`)}if(!r||n.length===0){const c=Math.floor(i.length/256);if(c===0)throw new Error(`Insufficient data: found ${i.length} values, need at least 256 for one channel`);Lg[c]?(n=Lg[c],console.log(`ðŸ“„ parseQuadFile: no header found, inferred ${c} channels using default names: ${n.join(",")}`)):(n=Array.from({length:c},(u,d)=>`CH${d+1}`),console.log(`ðŸ“„ parseQuadFile: no header found, inferred ${c} channels with generic names`))}const o=n.length*256;if(i.length<o)throw new Error(`Insufficient data: found ${i.length} values, expected ${o} (${n.length} channels Ã— 256 points each)`);const s={},l=[];for(let c=0;c<n.length;c++){const u=n[c],d=c*256,p=d+255;if(p>=i.length)throw new Error(`Not enough data for channel ${u}: need point ${p+1}, have ${i.length}`);const f=i.slice(d,d+256);s[u]=f,l.push(Math.max(...f))}return{channels:n,values:l,curves:s}}function Ck(e,t){for(const[n,r]of Object.entries(t))if(r.channels.length===e.length&&r.channels.every((i,a)=>i===e[a]))return n;return null}async function Ak(e){if(!e.name.toLowerCase().endsWith(".quad"))return{success:!1,error:`Unsupported file type. Expected .quad file, got: ${e.name}`};if(e.size>10*1024*1024)return{success:!1,error:`File too large: ${(e.size/(1024*1024)).toFixed(1)}MB. Maximum supported size is 10MB.`};if(e.size<100)return{success:!1,error:`File too small: ${e.size} bytes. This doesn't appear to be a valid .quad file.`};try{const t=await e.text(),n=t.split(`
`).filter(l=>{const c=l.trim();return c&&/^\d+$/.test(c)});if(n.length<256)return{success:!1,error:`File does not appear to be a valid .quad file (found only ${n.length} numeric values, need at least 256).`};const r=wk(t);if(!r||!r.channels||!Array.isArray(r.channels))return{success:!1,error:"Failed to parse .quad file (invalid format)."};const i=lt(),a=Array.isArray(i?.channels)?i.channels:[],o=a.filter(l=>Array.isArray(r.channels)&&r.channels.includes(l));if(o.length===0)return{success:!1,error:`Reference file '${e.name}' has no channels in common with the active printer profile.`,warning:!0};const s={filename:e.name,channels:r.channels.slice(),curves:{}};return o.forEach(l=>{const c=r.curves?.[l];Array.isArray(c)&&(s.curves[l]=c.slice())}),{success:!0,filename:e.name,data:s,matchedCount:o.length,totalCount:a.length,unmatchedCount:a.length-o.length}}catch(t){return{success:!1,error:`Failed to load reference file: ${t.message}`}}}const Mk=2.5,Cl=e=>Math.max(0,Math.min(1,e));function Al(e){return Number.isFinite(e)?Math.abs(e)<=Mk?0:e:0}function Ig(e){return!Number.isFinite(e)||e<0?0:e>100?100:e}function kg(e){if(e==null)return null;const t=String(e).trim();return t.length?t:null}function Dg(e){return(e||"").trim().toUpperCase()}function Lk(e){return e.slice(1).join(" ").trim()}function Ik(e){if(!e)return null;const n=e.replace(/[^A-Z0-9]/g,"").match(/(?:SPEC|SPECTRAL|NM)(\d{3})$/);if(!n)return null;const r=parseInt(n[1],10);return Number.isFinite(r)?r:null}function ii(e,...t){for(const n of t)if(e[n]!==void 0&&e[n]!=="")return e[n];return null}function kk(e){return e.filter(n=>!n.labOnly&&n.cmykC===0&&n.cmykM===0&&n.cmykY===0).map(n=>({input:Number.isFinite(n.derivedInput)?n.derivedInput:n.cmykK,labL:n.labL}))}function Dk(e){if(!e.length)return[];const t=4.5,n=1.5,r=e.filter(c=>Number.isFinite(c.labA)&&Number.isFinite(c.labB)?Math.abs(c.labA)<=t&&Math.abs(c.labB)<=t:Math.abs(c.cmykC-c.cmykM)<=n&&Math.abs(c.cmykM-c.cmykY)<=n),i=r.length>=3?r:e,a=i.map(c=>Number.isFinite(c.totalInk)?c.totalInk:NaN).filter(c=>Number.isFinite(c));if(!a.length)return[];const o=Math.max(...a);if(!(o>0))return[];const s=new Map;for(const c of i){if(!Number.isFinite(c.totalInk))continue;const u=c.totalInk/o*100,d=Math.max(0,Math.min(100,u));if(!Number.isFinite(d))continue;const p=d.toFixed(4),f=Math.abs(c.labA||0)+Math.abs(c.labB||0);if(s.has(p)){const h=s.get(p);f<h.chroma&&s.set(p,{input:d,labL:c.labL,chroma:f})}else s.set(p,{input:d,labL:c.labL,chroma:f})}const l=Array.from(s.values()).filter(c=>Number.isFinite(c.labL)).sort((c,u)=>c.input-u.input).map(({input:c,labL:u})=>({input:c,labL:u}));return l.length>=3?l:[]}function Pk(e){const t=[];for(let n=0;n<e.length;n++){const r=e[n];Number.isFinite(r.labL)&&Number.isFinite(r.derivedInput)&&t.push({input:r.derivedInput,labL:r.labL})}if(t.length>=3)return t.sort((n,r)=>n.input-r.input),t;if(e.length>=3){const n=[],r=Math.max(1,e.length-1);for(let i=0;i<e.length;i++){const a=e[i];if(!Number.isFinite(a.labL))continue;const o=i/r*100;n.push({input:o,labL:a.labL})}if(n.length>=3)return n}return[]}function il(e,t,n={}){const r=e.split(/\r?\n/),i=[],a=[];let o=[];const s={},l=[],c=[];let u=!1,d=!1,p=null,f=null,h=0;const g=B=>{const G=Dg(B),V=i.length;i.push({name:B,canonical:G,index:V});const K=Ik(G);K!==null&&a.push({name:B,canonical:G,index:V,nm:K})};for(let B=0;B<r.length;B++){const G=r[B];if(!G)continue;const V=Rw(G);if(!V.length)continue;const K=Dg(V[0]);if(K==="CGATS.17"||K==="CTI3")continue;if(K==="BEGIN_DATA_FORMAT"){u=!0;continue}if(K==="END_DATA_FORMAT"){u=!1,o=a.slice().sort((W,fe)=>W.nm-fe.nm||W.index-fe.index);continue}if(K==="BEGIN_DATA"){if(!i.length)throw new Error("CGATS file missing data format definition before BEGIN_DATA");d=!0,h=0;continue}if(K==="END_DATA"){d=!1;break}if(u){V.forEach(g);continue}if(d){const W=i.length;if(W===0)throw new Error("CGATS file missing data format definition before data rows");if(V.length<W)throw new Error(`CGATS data row ${h+1} has ${V.length} columns but expected ${W}`);if(V.length>W)throw new Error(`CGATS data row ${h+1} has ${V.length} columns but expected ${W}`);const fe=Object.create(null),Se={};for(let st=0;st<W;st++){const R=i[st],Q=V[st]!==void 0?V[st]:"";Se[R.name]=Q,fe[R.canonical]=Q}const we=kg(fe.SAMPLE_ID),Ne=kg(fe.SAMPLE_NAME),ct=fe.LAB_L,mt=fe.LAB_A,Vt=fe.LAB_B,xt=ln(ct),Un=ln(mt),Bt=ln(Vt),Gt=ln(fe.XYZ_X),ir=ln(fe.XYZ_Y),Lt=ln(fe.XYZ_Z),rt=ln(fe.CMYK_C),wt=ln(fe.CMYK_M),Ct=ln(fe.CMYK_Y),fr=ln(fe.CMYK_K);let ar=NaN,qr=null;const Pr=["CMYK_K","INPUT","GRAY_PERCENT","GRAY_%","GRAY","PERCENT_INPUT","PCT_INPUT","PCT","TARGET","INTENT","CHANNEL_K","DEVICE_K"];for(const st of Pr)if(fe[st]!==void 0){const R=ln(fe[st]);if(Number.isFinite(R)){ar=R,qr=st;break}}const En=ln(fe.RGB_R),z=ln(fe.RGB_G),J=ln(fe.RGB_B);if(!Number.isFinite(ar)&&Number.isFinite(En)&&Number.isFinite(z)&&Number.isFinite(J)){const st=Q=>Math.max(0,Math.min(255,Q));ar=(1-(st(En)+st(z)+st(J))/3/255)*100,qr="RGB"}const me=Number.isFinite(ar)?Ig(ar):NaN,Pe=Al(rt),$e=Al(wt),Ce=Al(Ct),St=Number.isFinite(fr)?fr:Number.isFinite(me)?me:0,At=Ig(St),It=Al(At),Rt=Math.max(0,Pe)+Math.max(0,$e)+Math.max(0,Ce)+Math.max(0,It);Number.isFinite(xt)&&xt>=0&&xt<=100&&l.push({labL:xt,labA:Number.isFinite(Un)?Un:null,labB:Number.isFinite(Bt)?Bt:null,cmykK:At,cmykC:Pe,cmykM:$e,cmykY:Ce,totalInk:Rt,derivedInput:Number.isFinite(me)?me:NaN,inputSource:qr,labOnly:!Number.isFinite(me),sampleId:we,sampleName:Ne});const Ht={};(Number.isFinite(rt)||Number.isFinite(wt)||Number.isFinite(Ct)||Number.isFinite(fr))&&(Ht.cmyk={c:Number.isFinite(rt)?rt:null,m:Number.isFinite(wt)?wt:null,y:Number.isFinite(Ct)?Ct:null,k:Number.isFinite(fr)?fr:Number.isFinite(me)?me:null}),(Number.isFinite(En)||Number.isFinite(z)||Number.isFinite(J))&&(Ht.rgb={r:Number.isFinite(En)?En:null,g:Number.isFinite(z)?z:null,b:Number.isFinite(J)?J:null});const Tt=Object.keys(Ht).length>0;let zt=null;Number.isFinite(xt)&&(zt={L:xt,a:Number.isFinite(Un)?Un:null,b:Number.isFinite(Bt)?Bt:null});let Bn=null;(Number.isFinite(Gt)||Number.isFinite(ir)||Number.isFinite(Lt))&&(Bn={X:Number.isFinite(Gt)?Gt:null,Y:Number.isFinite(ir)?ir:null,Z:Number.isFinite(Lt)?Lt:null});let qt=null;if(o.length){const st=[],R=[];for(const X of o){st.push(X.nm);const le=V[X.index],pe=ln(le);R.push(Number.isFinite(pe)?pe:null)}R.some(X=>Number.isFinite(X))&&(qt={nm:st,values:R})}c.push({ordinal:h+1,id:we,name:Ne||we,device:Tt?Ht:null,lab:zt,xyz:Bn,spectrum:qt,derivedInput:Number.isFinite(me)?me:null,inputSource:qr||null,raw:Se}),h++;continue}const se=Lk(V);if(s[K]=se,K==="NUMBER_OF_FIELDS"){const W=parseInt(V[1],10);Number.isFinite(W)&&(p=W)}else if(K==="NUMBER_OF_SETS"){const W=parseInt(V[1],10);Number.isFinite(W)&&(f=W)}}if(!o.length&&a.length&&(o=a.slice().sort((B,G)=>B.nm-G.nm||B.index-G.index)),!l.length)throw new Error("No valid measurement data found in CGATS file");if(p!==null&&p!==i.length)throw new Error(`CGATS field count mismatch: NUMBER_OF_FIELDS declares ${p} but parsed ${i.length}`);if(f!==null&&f!==c.length)throw new Error(`CGATS row count mismatch: NUMBER_OF_SETS declares ${f} but found ${c.length}`);const b=parseInt(s.SPECTRAL_BANDS,10),S=ln(s.SPECTRAL_START_NM),E=ln(s.SPECTRAL_END_NM);if(Number.isFinite(b)&&o.length&&o.length!==b)throw new Error(`CGATS spectral metadata mismatch: SPECTRAL_BANDS declares ${b} but found ${o.length}`);if(o.length){const B=o[0].nm,G=o[o.length-1].nm,V=1;if(Number.isFinite(S)&&Math.abs(B-S)>V)throw new Error(`CGATS spectral metadata mismatch: SPECTRAL_START_NM=${S} but first spectral column is ${B}`);if(Number.isFinite(E)&&Math.abs(G-E)>V)throw new Error(`CGATS spectral metadata mismatch: SPECTRAL_END_NM=${E} but last spectral column is ${G}`)}const y={};Object.keys(s).forEach(B=>{y[B]=s[B]});const v={originator:ii(s,"ORIGINATOR"),created:ii(s,"CREATED"),descriptor:ii(s,"DESCRIPTOR"),instrument:ii(s,"INSTRUMENT","INSTRUMENTATION"),illuminant:ii(s,"ILLUMINANT","ILLUMINATION_NAME","ILLUMINANT_NAME"),observer:ii(s,"OBSERVER","OBSERVER_ANGLE","OBSERVER_NAME"),geometry:ii(s,"MEASUREMENT_GEOMETRY","GEOMETRY"),aperture:ii(s,"MEASUREMENT_APERTURE","APERTURE"),backing:ii(s,"MEASUREMENT_BACKING","BACKING"),spectral:o.length?{declaredBands:Number.isFinite(b)?b:null,declaredStartNm:Number.isFinite(S)?S:null,declaredEndNm:Number.isFinite(E)?E:null,actualBands:o.length,actualStartNm:o.length?o[0].nm:null,actualEndNm:o.length?o[o.length-1].nm:null}:null,declaredSetCount:f,actualSetCount:c.length},A={source:{filename:t||null,format:"CGATS.17"},schema:{fields:i.map(B=>B.name),canonicalFields:i.map(B=>B.canonical),numberOfFields:i.length,declaredFieldCount:p,spectralColumns:o.map(B=>({name:B.name,nm:B.nm,index:B.index}))},meta:v,patches:c,raw:{header:y,text:e}};let w=kk(l),M="K-only";if(w.length<3){const B=Dk(l);if(B.length>=3)w=B,M="composite";else{const G=Pk(l);G.length>=3&&(w=G,M="LAB")}if(w.length<3)throw new Error("CGATS file contains no suitable monochrome measurement data. Need minimum 3 points spanning 0-100% range.")}const I=w.map(B=>({input:B.input,lab:B.labL}));I.sort((B,G)=>B.input-G.input);const _=I.map(B=>({input:Math.max(0,Math.min(100,Number(B.input))),lab:Math.max(0,Math.min(100,Number(B.lab)))})),C=n.normalizationMode||rr(),x=$c(_,{neighbors:fn.get("K_NEIGHBORS",6),sigmaFloor:fn.get("SIGMA_FLOOR",.02),sigmaCeil:fn.get("SIGMA_CEIL",.15),sigmaAlpha:fn.get("SIGMA_ALPHA",3),normalizationMode:C}),P=B=>Cl(Hi(B)),k=(B=1)=>{const G=x.createEvaluator(Math.max(.1,B)),V=G(0),K=G(1);return se=>{const W=Cl(se),fe=Cl(P(W));if(fe<=V)return 0;if(fe>=K)return 1;let Se=0,we=1;for(let Ne=0;Ne<40;Ne++){const ct=(Se+we)/2,mt=G(ct);if(!Number.isFinite(mt))break;mt<fe?Se=ct:we=ct}return Cl(we)}},N=k(1),F=new Array(256);for(let B=0;B<256;B++){const G=B/255;F[B]=N(G)}F[0]=0,F[255]=1;const U=ls(F);return{valid:!0,domainMin:0,domainMax:1,samples:_f(U),originalData:_,format:`CGATS.17 (${M})`,measurementSet:A,sourceSpace:ft.SPACE.PRINTER,rawCgatsText:e,filename:t||"measurements.cgats",measurementIntent:"positive",edited:!1,getSmoothingControlPoints(B){const G=Math.max(0,Math.min(90,Number(B)||0)),V=1+G/100,K=k(V),se=new Array(256);for(let Ne=0;Ne<256;Ne++){const ct=Ne/255;se[Ne]=K(ct)}const W=ls(se),fe=Math.max(3,21-Math.floor(G/10)),Se=[],we=[];for(let Ne=0;Ne<fe;Ne++){const ct=Ne/(fe-1||1),mt=Math.round(ct*255);we.push(ct),Se.push(W[mt])}return{samples:Se,xCoords:we,controlPointCount:fe,needsDualTransformation:!1}}}}ri({parseCGATS17:il});Xe("cgatsParser",{parseCGATS17:il},{exposeOnWindow:typeof window<"u",windowAliases:["parseCGATS17"]});const pc={8:["K","C","M","Y","LC","LM","LK","LLK"],10:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]};function Am(e){try{console.log("ðŸ“„ parseQuadFile: parsing real .quad file data");const t=e.split(`
`).map(u=>u.trim());let n=[],r=!1;for(let u=0;u<t.length;u++){const d=t[u].trim();if(d.startsWith("## QuadToneRIP ")){n=d.substring(15).split(",").map(f=>f.trim()),r=!0;break}}const i=[];let a=[];for(let u=0;u<t.length;u++){const d=t[u].trim();if(d&&!d.startsWith("#")){if(/^\d+$/.test(d)){const p=parseInt(d,10);if(p<0||p>65535)throw new Error(`Invalid data value ${p} at line ${u+1}. QuadToneRIP values must be 0-65535.`);i.push(p)}else if(a.push(`Line ${u+1}: "${d}"`),a.length>10)break}}if(i.length<256)throw new Error(`Insufficient data: found only ${i.length} values, need at least 256 for one channel`);if(a.length>0){const u=a.slice(0,3).join(", ");console.warn(`Found ${a.length} non-numeric lines in data section: ${u}`)}if(!r||n.length===0){const u=Math.floor(i.length/256);if(u===0)throw new Error(`Insufficient data: found ${i.length} values, need at least 256 for one channel`);pc[u]?(n=pc[u],console.log(`ðŸ“„ parseQuadFile: no header found, inferred ${u} channels using default names: ${n.join(",")}`)):(n=Array.from({length:u},(d,p)=>`CH${p+1}`),console.log(`ðŸ“„ parseQuadFile: no header found, inferred ${u} channels with generic names`))}const o=n.length*256;if(i.length<o)throw new Error(`Insufficient data: found ${i.length} values, expected ${o} (${n.length} channels Ã— 256 points each)`);const s={},l=[],c={};for(let u=0;u<n.length;u++){const d=n[u],p=u*256,f=p+255;if(f>=i.length)throw new Error(`Not enough data for channel ${d}: need point ${f+1}, have ${i.length}`);const h=i.slice(p,p+256);s[d]=h;const g=Math.max(...h);l.push(g),c[d]=g}return console.log(`ðŸ“„ parseQuadFile: successfully parsed ${n.length} channels with ${i.length} data points`),{curves:s,baselineEnd:c,channels:n,values:l,filename:"loaded.quad",valid:!0}}catch(t){return console.error("Error parsing .quad file:",t),{valid:!1,error:t.message}}}function fc(e,t="curve.acv"){try{console.log("ðŸ“ˆ parseACVFile: parsing real ACV file data");const n=new DataView(e);if(e.byteLength<6)throw new Error("Invalid ACV file - too small (minimum 6 bytes required)");const r=n.getUint16(0,!1),i=n.getUint16(2,!1);if(i===0)throw new Error("Invalid ACV file - no curves found");let a=4;const o=n.getUint16(a,!1);if(a+=2,o===0)throw new Error("Invalid ACV file - first curve has no points");const s=a+o*4;if(e.byteLength<s)throw new Error(`ACV file truncated - expected ${s} bytes, got ${e.byteLength}`);const l=[];for(let h=0;h<o;h++){const g=n.getUint16(a,!1),b=n.getUint16(a+2,!1);l.push({input:b/255,output:g/255}),a+=4}l.sort((h,g)=>h.input-g.input);const c=l.map(h=>h.input),u=l.map(h=>h.output),d=zr(c,u),p=new Array(256);for(let h=0;h<256;h++){const g=h/255;let b=d(g);const S=1-g,E=1-d(S);p[h]=Math.max(0,Math.min(1,E))}const f=l.map(h=>({input:(1-h.input)*100,output:(1-h.output)*100}));return console.log(`ðŸ“ˆ parseACVFile: successfully parsed ${o} points from ${t}`),{valid:!0,format:"ACV",filename:t,samples:p,originalSamples:p.slice(),rawSamples:p.slice(),controlPointsTransformed:f,sourceSpace:ft.SPACE.PRINTER,domainMin:0,domainMax:1,interpolationType:"pchip",conversionMeta:{version:r,totalCurves:i,pointCount:o,printerSpaceOriented:!0}}}catch(n){return console.error("Error parsing ACV file:",n),{valid:!1,error:n.message}}}function Mm(e,t="lut.cube"){try{const n=e.split(/\r?\n/);let r=0,i=1,a=null;const o=[];for(const d of n){const p=d.trim();if(!(!p||p.startsWith("#")||/^TITLE/i.test(p))&&/^LUT_3D_SIZE/i.test(p))return mu(e)}for(const d of n){const p=d.trim();if(!p||p.startsWith("#")||/^TITLE/i.test(p))continue;if(/^LUT_1D_SIZE/i.test(p)){const h=p.match(/LUT_1D_SIZE\s+(\d+)/i);h&&(a=parseInt(h[1],10));continue}if(/^DOMAIN_MIN/i.test(p)){const h=p.split(/\s+/);h[1]!==void 0&&(r=parseFloat(h[1]));continue}if(/^DOMAIN_MAX/i.test(p)){const h=p.split(/\s+/);h[1]!==void 0&&(i=parseFloat(h[1]));continue}const f=p.split(/\s+/).map(h=>parseFloat(h)).filter(h=>Number.isFinite(h));f.length>=1&&f.length<=3&&o.push(f[0])}const s=256;if(a==null&&o.length>s)throw new Error(`1D LUT lists ${o.length} samples without LUT_1D_SIZE; limit is ${s}.`);if(a!==null&&o.length>=a&&(o.length=a),(!Number.isFinite(r)||!Number.isFinite(i)||r===i)&&(r=0,i=1),!o.length)throw new Error("No 1D LUT samples found.");const l=ft.convertSamples(o,{from:ft.SPACE.IMAGE,to:ft.SPACE.PRINTER,metadata:{filename:t}}),c=l.values.map(d=>ce(Number(d)||0)),u=Nc()?_f(c):c;return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[mod] parseCube1D",{filename:t,declaredSize:a,sampleCount:o.length,domainMin:r,domainMax:i}),{valid:!0,format:"1D LUT",filename:t,lutSize:a||o.length,samples:u,originalSamples:u.slice(),rawSamples:l.values.slice(),sourceSpace:l.sourceSpace,conversionMeta:l.meta,domainMin:r,domainMax:i,interpolationType:"pchip"}}catch(n){return console.error("Error parsing 1D CUBE file:",n),{valid:!1,error:n.message}}}function mu(e,t="lut3d.cube"){try{const n=e.split(/\r?\n/);let r=0,i=1,a=null;const o=[];for(const f of n){const h=f.trim();if(!h||h.startsWith("#")||/^TITLE/i.test(h))continue;if(/^LUT_3D_SIZE/i.test(h)){const b=h.match(/LUT_3D_SIZE\s+(\d+)/i);b&&(a=parseInt(b[1],10));continue}if(/^DOMAIN_MIN/i.test(h)){const b=h.split(/\s+/);b[1]!==void 0&&(r=parseFloat(b[1]));continue}if(/^DOMAIN_MAX/i.test(h)){const b=h.split(/\s+/);b[1]!==void 0&&(i=parseFloat(b[1]));continue}const g=h.split(/\s+/);if(g.length===3){const b=parseFloat(g[0]),S=parseFloat(g[1]),E=parseFloat(g[2]);!isNaN(b)&&!isNaN(S)&&!isNaN(E)&&o.push([b,S,E])}}if(!a)throw new Error("3D LUT size not found. Expected LUT_3D_SIZE declaration.");const s=a*a*a;if(o.length!==s)throw new Error(`3D LUT data mismatch. Expected ${s} points, found ${o.length}.`);const l=256,c=new Array(l),u=Math.abs(i-r)>1e-9?i-r:1;for(let f=0;f<l;f++){const h=f/(l-1),b=xk([h,h,h],o,a,r,u);c[f]=(b[0]+b[1]+b[2])/3}const d=ft.convertSamples(c,{from:ft.SPACE.IMAGE,to:ft.SPACE.PRINTER,metadata:{lutSize:a}}),p=_f(d.values.map(f=>Number(f)||0));return{valid:!0,format:"3D LUT",filename:t,lutSize:a,samples:p,originalSamples:p.slice(),rawSamples:d.values.slice(),sourceSpace:d.sourceSpace,conversionMeta:d.meta,domainMin:r,domainMax:i,is3DLUT:!0,interpolationType:"pchip"}}catch(n){return console.error("Error parsing 3D CUBE file:",n),{valid:!1,error:n.message}}}function xk(e,t,n,r,i){const[a,o,s]=e,l=Math.max(0,Math.min(1,(a-r)/i)),c=Math.max(0,Math.min(1,(o-r)/i)),u=Math.max(0,Math.min(1,(s-r)/i)),d=l*(n-1),p=c*(n-1),f=u*(n-1),h=Math.floor(d),g=Math.min(n-1,h+1),b=Math.floor(p),S=Math.min(n-1,b+1),E=Math.floor(f),y=Math.min(n-1,E+1),v=d-h,A=p-b,w=f-E,M=(C,x,P)=>C*n*n+x*n+P,I=[t[M(h,b,E)],t[M(g,b,E)],t[M(h,S,E)],t[M(g,S,E)],t[M(h,b,y)],t[M(g,b,y)],t[M(h,S,y)],t[M(g,S,y)]],_=[0,0,0];for(let C=0;C<3;C++){const x=I[0][C]*(1-v)+I[1][C]*v,P=I[2][C]*(1-v)+I[3][C]*v,k=I[4][C]*(1-v)+I[5][C]*v,N=I[6][C]*(1-v)+I[7][C]*v,F=x*(1-A)+P*A,U=k*(1-A)+N*A;_[C]=F*(1-w)+U*w}return _}async function hu(e,t){try{let n,r,i=t;if(e instanceof File){if(i=i||e.name,(i?i.toLowerCase().split(".").pop():"")==="acv")return r=await e.arrayBuffer(),fc(r,i);n=await e.text()}else if(e instanceof ArrayBuffer)r=e;else if(ArrayBuffer.isView(e)){const l=e;r=l.buffer.slice(l.byteOffset,l.byteOffset+l.byteLength)}else e&&typeof e.arrayBuffer=="function"?r=await e.arrayBuffer():typeof e=="string"?n=e:n=e!=null?String(e):"";const a=i?i.toLowerCase().split(".").pop():"";if(!r&&typeof n!="string"&&n!=null&&(n=Array.isArray(n)?n.join(`
`):String(n)),r&&a==="acv")return fc(r,i);if(!n&&r){const l=typeof TextDecoder<"u"?new TextDecoder("utf-8",{fatal:!1}):null;if(!l)throw new Error("TextDecoder is not available to decode linearization file");n=l.decode(new Uint8Array(r))}const o=typeof n=="string"?n:"",s=rr();if(a==="ti3"||o.includes("CGATS")||o.includes("BEGIN_DATA")){const l=il(o,i,{normalizationMode:s});return Nl(l,{normalizationMode:s})}else if(a==="txt"||a==="lab"){const l=uo(o,i,{normalizationMode:s});return Nl(l,{normalizationMode:s})}else{if(a==="cube")return o.includes("LUT_1D_SIZE")?Mm(o,i):mu(o,i);{const l=uo(o,i,{normalizationMode:s});return Nl(l,{normalizationMode:s})}}}catch(n){return console.error("Error in parseLinearizationFile:",n),{valid:!1,error:n.message}}}function gu(e,t={}){try{console.log("ðŸ“ parseManualLstarData: processing manual L* measurements");const n=e?.isValid??e?.valid??!1,r=Array.isArray(e?.measuredPairs)?e.measuredPairs:[];if(!e||!n||r.length===0)return{valid:!1,error:"Invalid validation data provided"};const i=r,a=i.map(y=>Number(y.x)),o=i.map(y=>Number(y.l));if(i.length<2)return{valid:!1,error:"At least 2 measurement pairs are required"};const c=(a.length>0?Math.max(...a):0)>100?255:100,d=i.map(y=>{const v=Math.max(0,Math.min(c,Number(y.x))),A=Math.max(0,Math.min(100,Number(y.l)));return{input:v/c*100,lab:A,originalInput:Number(y.x)}}).filter(y=>Number.isFinite(y.input)&&Number.isFinite(y.lab)).sort((y,v)=>y.input-v.input);if(d.length<2)return{valid:!1,error:"Not enough valid measurement pairs to build a curve"};const p=t.normalizationMode||rr(),f=Gn(),h=er(d,{normalizationMode:p,skipDefaultSmoothing:!0,useBaselineWidenFactor:!0}),g=er(d,{normalizationMode:p,useBaselineWidenFactor:!0})||h;if(!Array.isArray(g)||g.length===0)return{valid:!1,error:"Failed to reconstruct manual L* samples"};const b=f>0?Ir(f):1,S=er(d,{normalizationMode:p,widenFactor:b})||g,E=y=>{const v=Math.max(0,Math.min(600,Number(y)||0)),A=Ir(v),w=er(d,{widenFactor:A,normalizationMode:p})||g,M=Math.max(3,21-Math.floor(v/10)),I=[],_=[];for(let C=0;C<M;C++){const x=M===1?0:C/(M-1),P=Math.round(x*255);_.push(x),I.push(w[Math.max(0,Math.min(255,P))])}return{samples:I,xCoords:_,controlPointCount:M,needsDualTransformation:!1}};return console.log(`ðŸ“ parseManualLstarData: successfully processed ${d.length} L* measurements`),{valid:!0,format:"Manual L* Entry",filename:`Manual-L-${d.length}pts`,domainMin:0,domainMax:1,samples:g.slice(),baseSamples:g.slice(),rawSamples:(h||g).slice(),previewSamples:S.slice(),previewSmoothingPercent:f,originalData:d.map(y=>({input:y.input,lab:y.lab,originalInput:y.originalInput})),sourceSpace:ft.SPACE.PRINTER,getSmoothingControlPoints:E}}catch(n){return console.error("Error parsing manual L* data:",n),{valid:!1,error:n.message}}}function zS(e){try{if(console.log("ðŸ’¬ parseIntentPaste placeholder called"),!e||typeof e!="string")return{ok:!1,error:"No text provided"};const t=e.toLowerCase(),r=["curve","bright","dark","contrast","highlight","shadow","midtone"].some(i=>t.includes(i));return{ok:r,text:e.trim(),detected:r?"curve_intent":"unknown"}}catch(t){return console.error("Error parsing intent paste:",t),{ok:!1,error:t.message}}}function US(e,t){const n=t?t.toLowerCase().split(".").pop():"";return n==="quad"?{valid:e.split(`
`).filter(i=>{const a=i.trim();return a&&/^\d+$/.test(a)}).length>=256,format:"quad",parser:"parseQuadFile"}:n==="ti3"||e.includes("CGATS")||e.includes("BEGIN_DATA")?{valid:!0,format:"cgats",parser:"parseCGATS17"}:n==="acv"?{valid:!0,format:"acv",parser:"parseACVFile"}:n==="cube"||e.includes("LUT_1D_SIZE")||e.includes("LUT_3D_SIZE")?{valid:!0,format:"cube",parser:e.includes("LUT_1D_SIZE")?"parseCube1D":"parseCube3D"}:n==="txt"||n==="lab"?{valid:!0,format:"lab",parser:"parseLabData"}:{valid:!1,format:"unknown",error:"Unsupported file format"}}function $S(e){try{if(!e||typeof e!="string")return{valid:!1,error:"No file content provided"};const t=e.split(`
`).map(a=>a.trim()).filter(a=>a),n=t.find(a=>a.startsWith("## QuadToneRIP"));let r=[];n&&(r=n.substring(15).split(",").map(a=>a.trim()));const i=t.filter(a=>/^\d+$/.test(a));if(i.length<256)return{valid:!1,error:`Insufficient data: found ${i.length} values, need at least 256 for one channel`};if(r.length===0){const a=Math.floor(i.length/256);pc[a]?r=pc[a]:r=Array.from({length:a},(o,s)=>`CH${s+1}`)}return{valid:!0,channels:r,message:`Valid .quad file with ${r.length} channels`}}catch(t){return{valid:!1,error:t.message}}}Xe("parsers",{parseQuadFile:Am,parseACVFile:fc,parseCube1D:Mm,parseCube3D:mu,parseCGATS17:il,parseLabData:uo,parseManualLstarData:gu,parseLinearizationFile:hu,parseIntentPaste:zS,validateFileFormat:US,validateQuadFile:$S,cieDensityFromLstar:Fs,lstarToY_CIE:Kb,log10_safe:Yb,rebuildLabSamplesFromOriginal:er},{exposeOnWindow:!0,windowAliases:["parseQuadFile","parseACVFile","parseCube1D","parseCube3D","parseCGATS17","parseLabData","parseManualLstarData","parseLinearizationFile","parseIntentPaste","validateFileFormat","validateQuadFile","cieDensityFromLstar","lstarToY_CIE","log10_safe"]});function Cs(){if(!m.rows)return;const e=Array.from(m.rows.children),t=document.getElementById("noChannelsRow");if(!t)return;const n=e.filter(i=>i.id!=="noChannelsRow");n.length>0&&n.every(i=>{const a=i.querySelector(".end-input");return parseInt(a.value)===0})?t.classList.remove("hidden"):t.classList.add("hidden")}function fi(){const e=document.getElementById("disabledChannelsCompact"),t=document.getElementById("disabledChannelsRow");if(!e||!t||!m.rows)return;t.innerHTML="";const n=m.rows?Array.from(m.rows.children).filter(r=>r.getAttribute("data-channel")):[];if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[chips] building",n.length),n.length===0){e.classList.remove("show");return}e.classList.add("show"),n.forEach(r=>{const i=r.getAttribute("data-channel"),a=r.querySelector(".percent-input"),o=r._virtualCheckbox||{checked:!r.hasAttribute("data-user-disabled")};if(!i||!a)return;const s=ni[i]||"#000000";typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[chips] chip",i,{checked:o.checked,compact:r.getAttribute("data-compact")});const l=document.createElement("div");l.className="disabled-channel-chip",l.dataset.channel=i,o.checked&&l.classList.add("active");const c=document.createElement("input");c.type="checkbox",c.className="channel-checkbox",c.checked=!!o.checked;const u=document.createElement("span");u.className="channel-color",u.style.backgroundColor=s;const d=document.createElement("span");d.className="channel-name",d.textContent=i,l.appendChild(c),l.appendChild(u),l.appendChild(d),c.addEventListener("change",p=>{p.stopPropagation(),r._virtualCheckbox&&(r._virtualCheckbox.checked=c.checked,r._virtualCheckbox.dispatchEvent(new Event("change"))),l.classList.toggle("active",c.checked)}),l.addEventListener("click",p=>{p.target!==c&&(c.checked=!c.checked,c.dispatchEvent(new Event("change")))}),t.appendChild(l)})}function VS(e,t){e&&(t?(e.setAttribute("data-compact","true"),fi()):(e.setAttribute("data-compact","false"),fi()))}ri({updateCompactChannelsList:fi,updateChannelCompactState:VS,updateNoChannelsMessage:Cs});Xe("compactChannels",{updateCompactChannelsList:fi,updateChannelCompactState:VS,updateNoChannelsMessage:Cs},{exposeOnWindow:typeof window<"u",windowAliases:["updateCompactChannelsList","updateChannelCompactState"]});const jp=typeof window<"u"?window:globalThis,zo=256,Bk=.25;function Tk(e,t,n){if(e==="pchip")return zr(t,n);if(e==="catmull"){const r=Number(m?.catmullTension?.value??50)/100;return Pb(t,n,r)}return Db(t,n)}function Ok(){const e=D.getGlobalData();if(!D.globalApplied||!e)return"";const n=String(e.format||"").toUpperCase();if(!(n.includes("LAB")||n.includes("MANUAL")))return"";try{const i=Rn(e);let a=Array.isArray(i.samples)?i.samples.slice():null,o=null;const s=m?.tuningSmoothingPercent,l=s&&Number(s.value)||0;if(typeof e.getSmoothingControlPoints=="function"){const I=e.getSmoothingControlPoints(l)||{};Array.isArray(I.samples)&&I.samples.length>=2&&(a=I.samples.slice(),Array.isArray(I.xCoords)&&I.xCoords.length===a.length&&(o=I.xCoords.slice()))}if(!Array.isArray(a)||a.length<2)return"";const c=a.length;(!o||o.length!==c)&&(o=Array.from({length:c},(I,_)=>_/(c-1)));const u=m?.curveSmoothingMethod?.value||"cubic",d=Tk(u,o,a);let p=1/0,f=-1/0,h=0,g=0,b=null,S=null;for(let I=0;I<zo;I++){const _=I/(zo-1),C=ce(d(_)),x=ce(Hi(_)),P=(C-x)*100;if(P<p&&(p=P,h=I),P>f&&(f=P,g=I),S!==null&&(S<0&&P>0||S>0&&P<0||P===0)){if(P===0)b=_;else{const k=P-S,N=Math.abs(k)>1e-12?-S/k:0;b=(I-1+ce(N))/(zo-1)}S=P;break}S=P}const E=I=>`${I>=0?"+":""}${I.toFixed(1)}%`,y=I=>I>0?"add ink":I<0?"reduce ink":"no change",v=`${E(f)} (${y(f)}) @ ${(g/(zo-1)*100).toFixed(1)}% input`,A=`${E(p)} (${y(p)}) @ ${(h/(zo-1)*100).toFixed(1)}% input`,w=b!=null?`, zero â‰ˆ ${(b*100).toFixed(1)}% input`:"";return`Î” vs target (${m?.contrastIntentSelect?.selectedOptions?.[0]?.textContent?.trim()||jp?.contrastIntent?.name||"Linear"}): ${v}, ${A}${w}`}catch(i){return typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabTechSummary] Failed to build global delta summary:",i),""}}function _k(e){const n=lt()?.channels||[];if(!n.length)return"";const r=at?.(),i=[];return n.forEach(a=>{try{let o=0;if(r&&typeof r.get=="function"){const b=r.get(`printer.channelValues.${a}.endValue`);typeof b=="number"&&(o=b)}if(!o&&m?.rows){const b=m.rows.querySelector(`tr[data-channel="${a}"]`);if(b){const S=b.querySelector(".end-input");S&&(o=parseInt(S.value,10)||0)}}if(!o)return;const s=Hr(a),l=Yt(o,a,!1,{normalizeToEnd:s}),c=Yt(o,a,!0,{normalizeToEnd:s});if(!Array.isArray(l)||!Array.isArray(c)||l.length!==c.length)return;let u=1/0,d=-1/0;for(let b=0;b<c.length;b++){const S=(c[b]-l[b])/ve*100;S<u&&(u=S),S>d&&(d=S)}const p=b=>`${b>=0?"+":""}${b.toFixed(1)}%`;i.push(`${a}:${p(d)}/${p(u)}`);const f=o/ve*100,h=Math.max(Math.abs(d),Math.abs(u));Math.abs(f-Math.abs(h))<=Bk&&e.push(`${a} hit its ${f.toFixed(1)}% limit; diff â‰ˆ ${p(d)} (raise End before recalibrating)`)}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabTechSummary] Failed to compute channel change for",a,o)}}),i.length?`Channel changes (max/min vs original): ${i.join("; ")}`:""}function Co(){const e=[];typeof va=="function"&&va()&&e.push("Normalization: log-density mode active â€” exported .quad comments include this note.");const n=Ok();n&&e.push(n);const r=[],i=_k(r);i&&e.push(i),r.forEach(a=>e.push(`âš ï¸ ${a}`)),e.length&&e.forEach(a=>{xn.addChatMessage("system",a)})}typeof jp<"u"&&(jp.postGlobalDeltaChatSummary=()=>{try{Co()}catch(e){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabTechSummary] Legacy summary invocation failed:",e)}});const _t=typeof window<"u"?window:globalThis,Gr=typeof document<"u",Nk=160,Pg=640,Fk="Â ";function HS(){try{const e=lt(),t=[`## QuadToneRIP ${e.channels.join(",")}`,`# Printer: ${e.name}`,`# quadGEN ${Sa} by David Marsh`];return Gk(t),Rk(t),t.push("#"),t.push(...Uk()),$k(t,e.channels),`${t.join(`
`)}
`}catch(e){return console.error("Error building .quad file:",e),Xk()}}function Gk(e){const t=m.userNotes?.value?.trim();t&&(e.push("#"),e.push("# Notes:"),t.split(`
`).forEach(n=>{const r=n.trim();e.push(r?`# ${r}`:"#")}))}function Rk(e){const{data:t,applied:n}=Vk(),r=Hk(),i=zk(r),a=!!(t&&n),o=i.length>0;if(!(!a&&!o)){if(e.push("#"),e.push("# Linearization Applied:"),a){const s=ur(t.filename||"unknown file",!!t.edited),l=Pt(t);e.push(`# - Global: ${s} (${l}, affects all channels)`);const c=Wk(),{intentLine:u,tagLine:d}=Kk(c);u&&e.push(u),d&&e.push(d)}o&&(e.push("# - Per-channel:"),i.forEach(s=>{e.push(`#   ${s}`)}))}}function zk(e){const t=[];return Object.keys(e).forEach(n=>{const r=e[n];if(!qk(n))return;const i=jk(n,r),a=ur(i,!!r?.edited),o=Pt(r),s=r?.measurementIntent?` (measured: ${r.measurementIntent})`:"";t.push(`${n}: ${a} (${o})${s}`)}),t}function Uk(){const e=["# Limits summary:"];return Kw().forEach(n=>{const r=n.querySelector("td span span:nth-child(2)")?.textContent?.trim()||n.getAttribute("data-channel")||"Channel",i=n.querySelector(".end-input"),a=q.clampEnd(i?i.value:0),o=q.computePercentFromEnd(a);if(a===0)e.push(`#   ${r}: disabled`);else{const l=Math.abs(o-Math.round(o))<1e-9?String(Math.round(o)):o.toFixed(2);e.push(`#   ${r}: = ${l}%`)}}),e}function $k(e,t){const n=Yw();t.forEach(r=>{const a=n.get(r)?.querySelector(".end-input"),o=q.clampEnd(a?a.value:0),s=Yt(o,r,!0,{normalizeToEnd:Hr(r)}),l=typeof globalThis<"u"?globalThis:typeof window<"u"?window:null;if(l&&l.__COMPOSITE_AUDIT__&&l.__COMPOSITE_AUDIT__.enabled)try{const c=l.__COMPOSITE_AUDIT__,u=Array.isArray(c.events)?c.events:c.events=[],d={channelName:r,stage:"export",valueSample_242:Array.isArray(s)&&s.length>242?s[242]:null,endValue:o};u.push({stage:"export.make256",payload:d,ts:Date.now()}),typeof c.log=="function"&&c.log("export.make256",d)}catch(c){console.warn("[COMPOSITE_AUDIT] export logging failed:",c)}e.push(`# ${r} curve`),e.push(...s.map(String))})}function Vk(){try{if(D&&typeof D.getGlobalData=="function"){const e=D.getGlobalData();if(e)return{data:e,applied:!!D.globalApplied}}}catch(e){console.warn("Unable to read LinearizationState global data:",e)}try{const e=gt();if(e.linearizationData)return{data:e.linearizationData,applied:!!e.linearizationApplied}}catch(e){console.warn("Unable to read appState global linearization:",e)}return Gr?{data:_t.linearizationData||null,applied:!!_t.linearizationApplied}:{data:null,applied:!1}}function Hk(){const e={};try{const t=D?.perChannelData;t&&Object.keys(t).forEach(n=>{e[n]||(e[n]=t[n])})}catch(t){console.warn("Unable to read LinearizationState per-channel data:",t)}try{const n=gt().perChannelLinearization||{};Object.keys(n).forEach(r=>{e[r]||(e[r]=n[r])})}catch(t){console.warn("Unable to read appState per-channel linearization:",t)}return Gr&&_t.perChannelLinearization&&Object.keys(_t.perChannelLinearization).forEach(t=>{e[t]||(e[t]=_t.perChannelLinearization[t])}),e}function qk(e){try{if(D&&typeof D.isPerChannelEnabled=="function"){const t=D.isPerChannelEnabled(e);if(typeof t=="boolean")return t}}catch(t){console.warn("Unable to read per-channel enable state from LinearizationState:",t)}try{const t=gt();if(t.perChannelEnabled&&e in t.perChannelEnabled)return!!t.perChannelEnabled[e]}catch(t){console.warn("Unable to read appState per-channel enabled map:",t)}return Gr&&_t.perChannelEnabled?!!_t.perChannelEnabled[e]:!1}function jk(e,t){return Gr&&_t.perChannelFilenames&&_t.perChannelFilenames[e]?_t.perChannelFilenames[e]:t?.filename?t.filename:"unknown file"}function Wk(){if(Gr&&_t.contrastIntent)return _t.contrastIntent;try{const e=gt();if(e.contrastIntent)return e.contrastIntent}catch(e){console.warn("Unable to read contrast intent from appState:",e)}return null}function Kk(e){const t=String(e?.id||"linear"),n=e?.params||{},r=e?.name;let i;if(t==="linear")i="Linear";else if(t==="soft"||t==="hard"||t==="custom_gamma"){const s=Number(n.gamma??qS(t,"gamma")??1);i=`Gamma ${Number.isFinite(s)?s.toFixed(2):"1.00"}`}else if(t==="filmic"||t==="custom_filmic"){const s=Number(n.filmicGain??n.gain??.55),l=Number(n.shoulder??.35),c=Number.isFinite(s)?s.toFixed(2):"0.55",u=Number.isFinite(l)?l.toFixed(2):"0.35";i=`Filmic (gain ${c}, shoulder ${u})`}else t==="pops_standard"?i="POPSâ€‘Compat (Standard)":t==="custom_points"?i="Custom":r?i=r:i=t;const a=`#   Intent: ${i}`,o=`#   Intent tag: ${Yk(t,n)}`;return{intentLine:a,tagLine:o}}function Yk(e,t){if(e==="linear")return"LIN";if(e==="soft"||e==="hard"||e==="custom_gamma"){const n=Number(t.gamma??qS(e,"gamma")??1);if(!Number.isFinite(n)||n<=0)return"G100";const r=Math.round(n*100);return`G${String(r).padStart(3,"0")}`}return e==="filmic"||e==="custom_filmic"?"FILM":e==="pops_standard"?"POPS":e==="custom_points"?"CUST":"LIN"}function qS(e,t){const n=Do?.[e];return!n||!n.params?null:n.params[t]}function Xk(){const e=Qk();return`${["## QuadToneRIP K","# Printer: Unknown",`# quadGEN ${Sa} by David Marsh`,"#","# Limits summary:","#   K: = 100%","# K curve",...e.map(String)].join(`
`)}
`}function Qk(){const e=[];for(let t=0;t<256;t+=1)e.push(Math.round(t/255*65535));return e}function Uo(e){return String(e).replace(/[&<>"']/g,t=>{switch(t){case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";case'"':return"&quot;";case"'":return"&#39;";default:return t}})}function Zk(e){const t=e.startsWith("#")?e.slice(1):e,n=t.length===3?t.split("").map(i=>i+i).join(""):t,r=parseInt(n,16);return Number.isNaN(r)||n.length!==6?{r:0,g:0,b:0}:{r:r>>16&255,g:r>>8&255,b:r&255}}function gd(e){const t=e/255;return t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function Jk(e){const{r:t,g:n,b:r}=Zk(e),i=gd(t),a=gd(n),o=gd(r);return .2126*i+.7152*a+.0722*o}function e1(e){try{const t=Jk(e),n=(1+.05)/(t+.05);return(t+.05)/.05>=n?"#111827":"#ffffff"}catch{return"#111827"}}function t1(e,t){const n=ni[e]||"#666666",r=t[e]||(t[e]=e1(n));return` style="--ln-bg: ${n}; --ln-fg: ${r};"`}function jS(e){try{const t=String(e||"").split(`
`);let n=null,r=-1;const i=Object.create(null);return t.map((a,o)=>{const s=a.trim();let l,c=null;if(s.length===0)l=Fk;else if(/^##\s/.test(s))l=`<span class="quad-meta">${Uo(a)}</span>`;else if(/^#(?=\s|$)/.test(s)){const p=s.match(/^#\s+([A-Za-z]{1,3})\s+curve$/);p&&(n=p[1],r=-1),l=`<span class="quad-comment">${Uo(a)}</span>`}else if(/^\d+$/.test(s)){const p=["quad-number"];if(n){c=n,r+=1;const f=(t[o+1]||"").trim(),h=r===0,g=!f||/^#(?=\s|$)/.test(f);g&&(n=null,r=-1),(h||g)&&p.push("quad-emph")}l=`<span class="${p.join(" ")}">${Uo(a)}</span>`}else l=`<span class="quad-error">${Uo(a)}</span>`;const u=c?` data-ch="${c}"`:"",d=c?t1(c,i):"";return`<span class="quad-line"${u}${d}>${l}</span>`}).join("")}catch{return Uo(String(e||""))}}function n1(e){if(m.previewFull)try{const t=(e.match(/\n/g)||[]).length+1,n=String(Math.max(1,t)).length;m.previewFull.style.setProperty("--lnw",`calc(${n}ch + 2ch)`),m.previewFull.style.setProperty("--lngap","1ch")}catch(t){console.warn("Error adjusting preview line number gutter:",t)}}function WS(){const e=m.previewFull;!e||e.dataset.copyHandlerAttached==="true"||(e.addEventListener("copy",t=>{try{const n=e.dataset.raw||e.textContent||"";t.clipboardData.setData("text/plain",n),t.preventDefault()}catch(n){console.warn("Preview copy handler error:",n)}}),e.dataset.copyHandlerAttached="true")}function nn(e={}){requestAnimationFrame(()=>{try{const t=HS();if(!m.previewFull)return;m.previewFull.dataset.raw!==t&&(m.previewFull.dataset.raw=t,m.previewFull.innerHTML=jS(t),n1(t)),WS(),e.onlyNotes||(Je(),typeof wo=="function"&&wo(),Li());try{Er()}catch{}}catch(t){console.error("Preview update error:",t),showStatus()}})}jw(nn);function r1(){const e=document.getElementById("previewResizer"),t=m.previewFull;if(!e||!t)return;const n=()=>{const f=Gr?_t.getComputedStyle(t).maxHeight:`${Pg}px`,h=parseInt(f,10);return Number.isFinite(h)?h:t.clientHeight},r=f=>{const h=Math.max(Nk,Math.min(Pg,f));t.style.maxHeight=`${h}px`};let i=0,a=0,o=!1;const s=f=>{o=!0,i=f.clientY,a=n(),document.body.classList.add("select-none"),Gr&&(_t.addEventListener("mousemove",l),_t.addEventListener("mouseup",c)),f.preventDefault()},l=f=>{if(!o)return;const h=f.clientY-i;r(a+h)},c=()=>{o&&(o=!1,document.body.classList.remove("select-none"),Gr&&(_t.removeEventListener("mousemove",l),_t.removeEventListener("mouseup",c)))},u=f=>{f.touches.length===1&&(o=!0,i=f.touches[0].clientY,a=n(),document.body.classList.add("select-none"),Gr&&(_t.addEventListener("touchmove",d,{passive:!1}),_t.addEventListener("touchend",p)),f.preventDefault())},d=f=>{if(!o||f.touches.length!==1)return;const h=f.touches[0].clientY-i;r(a+h),f.preventDefault()},p=()=>{o&&(o=!1,document.body.classList.remove("select-none"),Gr&&(_t.removeEventListener("touchmove",d),_t.removeEventListener("touchend",p)))};e.addEventListener("mousedown",s),e.addEventListener("touchstart",u,{passive:!1})}function i1(){if(nn(),m.userNotes){let e=null;m.userNotes.addEventListener("input",()=>{clearTimeout(e),e=setTimeout(()=>{nn({onlyNotes:!0})},200)})}r1(),WS()}Gr&&(_t.buildFile=HS,_t.updatePreview=nn,_t.highlightQuad=jS);const xg="Linear";class a1{constructor(){this.windowRef=typeof window<"u"?window:null}getWindow(){return typeof window<"u"&&(this.windowRef=window),this.windowRef}getRemapDelegate(){const t=this.getWindow();if(!t||typeof t.canApplyIntentRemap!="function")return null;try{return t.canApplyIntentRemap.bind(t)}catch{return t.canApplyIntentRemap}}hasLegacyQuadLoaded(){const t=this.getWindow();if(!t)return!1;if(typeof t.hasLoadedQuadCurves=="function")try{return!!t.hasLoadedQuadCurves()}catch{return!1}return!!t.loadedQuadData}getLegacyLinearizationFlags(){const t=this.getWindow();if(!t)return{hasGlobal:!1,hasPerEnabled:!1};const n=!!(t.linearizationData&&t.linearizationApplied),r=t.perChannelLinearization||{},i=t.perChannelEnabled||{},a=Object.keys(r).some(o=>i[o]);return{hasGlobal:n,hasPerEnabled:a}}getLegacyIntentName(){const t=this.getWindow();return!t||!t.contrastIntent?xg:t.contrastIntent.name||xg}registerIntentHelpers(t={}){const n=this.getWindow();n&&Object.entries(t).forEach(([r,i])=>{n[r]===void 0&&(n[r]=i)})}}let bd=null;function o1(){return bd||(bd=new a1),bd}const Nr=o1();let yd=!1;function bu(e){return Do[e]||null}function Lm(){return Object.values(Do).sort((e,t)=>e.displayOrder-t.displayOrder)}function Wp(){return Lm().map(t=>`<option value="${t.id}">${t.label}</option>`).join(`
`)}function Bg(){try{const e=m.contrastIntentSelect;if(e){const n=Wp(),r=e.innerHTML,i=r.indexOf("\x3C!-- Preset options will be populated dynamically"),a=r.indexOf("-->")+3,o=r.substring(a);e.innerHTML=n+o}const t=m.intentPresetSelect;t&&(t.innerHTML=Wp()),console.log("âœ… Intent dropdown presets populated:",Lm().length,"presets")}catch(e){console.error("Failed to initialize preset dropdowns:",e)}}function KS(){try{if(D?.hasAnyLinearization)return D.hasAnyLinearization();const e=Nr.getLegacyLinearizationFlags(),{hasGlobal:t,hasPerEnabled:n}=e;return t||n}catch(e){return console.warn("Error checking linearization state:",e),!1}}function As(){try{const e=Nr.getLegacyLinearizationFlags?.()||{hasGlobal:!1,hasPerEnabled:!1},t=Nr.hasLegacyQuadLoaded?.()||!!Ee()?.curves,n=D?.getGlobalData?D.getGlobalData():null,r=D?!!D.globalApplied:!1,i=!!e?.hasGlobal,o=t&&!(!!n&&r||i),s=typeof Nr.getWindow=="function"?Nr.getWindow.bind(Nr):null,l=s?s():null,u=l&&l.canApplyIntentRemap===As?null:Nr.getRemapDelegate?.();if(u&&u!==As){if(yd)return console.warn("Legacy remap delegate recursion detected; using modular fallback."),o;try{yd=!0;const d=u();return d===!0?!0:d===!1||d===void 0||d===null?o:!!d}catch(d){return console.warn("Legacy remap delegate threw error, falling back to modular decision:",d),o}finally{yd=!1}}return o}catch(e){return console.warn("Error checking intent remap capability:",e),!1}}function Ao(){if(!m.contrastIntentSelect)return;const e=KS(),t=As(),n=e||t;n?(m.contrastIntentSelect.disabled=!1,m.contrastIntentSelect.removeAttribute("disabled")):(m.contrastIntentSelect.disabled=!0,m.contrastIntentSelect.setAttribute("disabled",""));const r=document.querySelector('label[for="contrastIntentSelect"]');n?(m.contrastIntentSelect.style.opacity="1",m.contrastIntentSelect.style.cursor="pointer",r&&(r.style.opacity="1")):(m.contrastIntentSelect.style.opacity="0.5",m.contrastIntentSelect.style.cursor="not-allowed",r&&(r.style.opacity="0.5"));const i=m.applyIntentToQuadBtn;if(i){t?(i.disabled=!1,i.style.opacity="1",i.style.cursor="pointer"):(i.disabled=!0,i.style.opacity="0.5",i.style.cursor="not-allowed");const a=Nr.getLegacyLinearizationFlags(),o=!!Ee()?.curves||Nr.hasLegacyQuadLoaded();!!(D?.getGlobalData?D.getGlobalData():null)&&!!D?.globalApplied||a.hasGlobal;const c=gt()?.contrastIntent?.name||Nr.getLegacyIntentName(),u=t?`Bake ${c} intent into the loaded curve`:o?"Disable or remove global measurement data (LAB/CGATS/TI3) to enable intent remap":"Load a .quad to enable intent remap";i.setAttribute("title",u)}console.log("ðŸŽ¯ Intent dropdown state updated:",{hasLinearization:e,allowRemap:t,enableControls:n,dropdownDisabled:m.contrastIntentSelect.disabled})}function s1(){Nr.registerIntentHelpers({CONTRAST_INTENT_PRESETS:Do,generatePresetDropdownHTML:Wp,initializePresetDropdowns:Bg,getAllPresets:Lm,getPreset:bu,hasAnyLinearization:KS,canApplyIntentRemap:As,updateIntentDropdownState:Ao}),Bg(),Ao(),console.log("âœ… Intent system initialized")}function YS(e){if(!e)return!1;const t=String(e.format||"").toUpperCase();return!t.includes("LAB")&&!t.includes("MANUAL")?!1:Array.isArray(e.originalData)&&e.originalData.length>0}function l1(e,t,n=1e-4){if(!Array.isArray(e)||!Array.isArray(t)||e.length!==t.length)return!1;for(let r=0;r<e.length;r+=1){const i=e[r],a=t[r];if(!a||Math.abs(i.input-a.input)>n||Math.abs(i.output-a.output)>n)return!1}return!0}function c1(e,t){const n=t||{},r=Array.isArray(n.measurementSeed?.points)?n.measurementSeed.points:null,i=Te.get(e)?.points||null,a=Array.isArray(r)&&r.length>=2,o=a&&Array.isArray(i)?l1(r,i):!1,s=Object.prototype.hasOwnProperty.call(n,"smartTouched"),l=!!n.smartTouched;let c=!1;return s?c=l:a?c=!o:c=l,{smartTouched:l,hasSmartTouchedFlag:s,hasSeed:a,seedMatches:o,touched:c,pointCount:Array.isArray(i)?i.length:null}}function u1(e){const t=$t(()=>({keyPointsMeta:{}}));t.keyPointsMeta=t.keyPointsMeta||{};const n=t.keyPointsMeta[e];n&&(n.smartTouched&&(n.smartTouched=!1),n.bakedGlobal&&delete n.bakedGlobal,t.normalizeToEndChannels&&typeof t.normalizeToEndChannels=="object"&&delete t.normalizeToEndChannels[e])}function yu(e,t={}){const{skipUiRefresh:n=!0,forceReinitialize:r=!0}=t,i=$t(()=>({keyPointsMeta:{}}));i.keyPointsMeta=i.keyPointsMeta||{};const a=i.keyPointsMeta[e]||{},o=a.measurementSeed,s=a.interpolationType||"smooth";let l=!1;if(o&&Array.isArray(o.points)&&o.points.length>=2)try{const c=Array.isArray(o.originalPoints)&&o.originalPoints.length>=2;let u,d=!0;if(c){const p=m.rows?Array.from(m.rows.children).find(g=>g.getAttribute("data-channel")===e):null,f=p?parseFloat(p.querySelector(".percent-input")?.value||"0"):0,h=Number.isFinite(f)&&f>0?f:100;u=o.originalPoints.map(g=>{const b=Number(g.output),S=h>0?b/h*100:b;return{input:Number(g.input),output:Math.max(0,Math.min(100,S))}})}else u=o.points.map(p=>({input:Number(p.input),output:Number(p.output)}));if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[revert-controls] attempting seed restore",{channelName:e,hasOriginal:c,sourceCount:Array.isArray(u)?u.length:null}),ga(e,u,s,{measurementSeed:o,smartTouched:!1,skipUiRefresh:n,includeBakedFlags:!1,pointsAreRelative:d}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[revert-controls] restoredFromSeed",e,{hasOriginal:c,sourceCount:Array.isArray(u)?u.length:null}),n)try{Je()}catch(p){console.warn(`[revert-controls] Chart refresh failed after seeding ${e}:`,p)}l=!0}catch(c){console.warn(`[revert-controls] Failed to persist measurement seed for ${e}:`,c)}if(!l&&r)try{Zs(e,{forceIfEditModeEnabling:!0})}catch(c){console.warn(`[revert-controls] Failed to reinitialize Smart points for ${e}:`,c)}u1(e);try{const c=D?.getPerChannelData?.(e);c&&typeof D.setPerChannelData=="function"&&D.setPerChannelData(e,c,!0)}catch(c){console.warn(`[revert-controls] Failed to re-enable measurement state for ${e}:`,c)}return{channel:e,restoredFromSeed:l}}function Im(e,t={}){if(!Array.isArray(e))return{seeded:[],reinitialized:[]};const n=[],r=[];return e.forEach(i=>{yu(i,t)?.restoredFromSeed?n.push(i):r.push(i)}),{seeded:n,reinitialized:r}}function Mo(){const e=Ee(),t=D.getGlobalData(),n=YS(t),r=typeof D.getGlobalBakedMeta=="function"?D.getGlobalBakedMeta():null,i=!!r,a=!!D.globalApplied,o=n&&a&&!i,s=!!t?.edited,l=lt()?.channels||[],c=e?.keyPointsMeta||{},u={};let d=!1;return o&&l.forEach(p=>{const f=c1(p,c?.[p]);u[p]=f,f.touched&&(d=!0)}),{isMeasurement:o,wasEdited:s,hasSmartEdits:d,channelStates:u,globalData:t,isBaked:i,bakedMeta:r}}function Qr(){let e=null;try{const t=Mo(),{isMeasurement:n,wasEdited:r,hasSmartEdits:i,isBaked:a,channelStates:o}=t;e=o;const s=document.getElementById("revertGlobalToMeasurementBtn");if(s){const l=!a&&n&&(i||r);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[REVERT CONTROLS] Global button state",JSON.stringify({isMeasurement:n,wasEdited:r,hasSmartEdits:i,isBaked:a,shouldEnable:l,smartTouchedMap:e})),l?(s.disabled=!1,s.removeAttribute("disabled")):(s.disabled=!0,s.setAttribute("disabled","disabled"))}}catch(t){console.warn("[revert-controls] global revert toggle error:",t)}try{Array.from(m.rows?.children||[]).forEach(n=>{const r=n?.getAttribute?.("data-channel");if(!r)return;const i=n.querySelector(".per-channel-revert");if(!i)return;const a=D.getPerChannelData(r),o=!!(a&&YS(a)),s=Ee()?.keyPointsMeta?.[r],l=e?.[r],c=l?l.touched:!!s?.smartTouched,u=c,d=o&&u;i.disabled=!d,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&r==="MK"&&console.log("[DEBUG BUTTON]",{channel:r,hasMeasurement:o,hasEdits:u,enabled:d,touched:c,metaSmart:s?.smartTouched}),d?(i.classList.remove("invisible"),i.title=o?`Revert ${r} to measurement source`:"Clear Smart (restore loaded .quad)"):i.classList.add("invisible")})}catch(t){console.warn("[revert-controls] per-channel revert toggle error:",t)}}Hw(Qr);ri({updateRevertButtonsState:Qr,computeGlobalRevertState:Mo});Xe("revertControls",{updateRevertButtonsState:Qr,computeGlobalRevertState:Mo,resetChannelSmartPointsToMeasurement:yu,resetSmartPointsForChannels:Im},{exposeOnWindow:typeof window<"u",windowAliases:["updateRevertButtonsState","computeGlobalRevertState","resetChannelSmartPointsToMeasurement","resetSmartPointsForChannels"]});const d1={Unreleased:{date:"â€”",title:"",sections:{ADDED:[],CHANGED:[],FIXED:[],REMOVED:[],DOCS:[]},aboutDialog:[]},"5.0.1":{date:"2026-01-24",title:"Smart Curve drag fix",sections:{ADDED:[],CHANGED:[],FIXED:["Smart Curve point markers now follow the cursor during drag operations instead of snapping back to the previous curve position."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Smart Curve drag fix",desc:"Point markers now visually follow the cursor during drag, providing immediate feedback instead of snapping back."}]},"5.0.0":{date:"2026-01-24",title:"Channel Builder & LAB correction fix",sections:{ADDED:["Channel Builder wizard for creating multi-ink .quad files from L* measurements. 4-tab guided workflow: Reference K â†’ Add Channels â†’ Preview â†’ Apply. Define reference K from measurements or import from current .quad, then add secondary channels by entering their density profiles. Session state persists across page reloads."],CHANGED:[],FIXED:["LAB correction now applies at correct input positions for non-linear .quad curves. Previously, gain sampling used output ink level instead of input position, causing spot markers and actual corrections to diverge for non-linear curves."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Channel Builder wizard",desc:"New guided workflow for building multi-ink .quad files from L* measurements. Define a reference K channel, then add secondary channels with their density profiles."},{label:"LAB correction domain fix",desc:"Spot markers and actual corrections now align for all curve shapes including S-curves, shoulders, and other non-linear .quad curves."}]},"4.3.5":{date:"2025-01-19",title:"Bell curve improvements & .quad parser fix",sections:{ADDED:["Bell curve classifier now reports asymmetry metrics (asymmetryRatio, isLeftSkewed, isRightSkewed) for diagnostic insight into peak shape.","Bell curve classifier now reports Gaussian fit quality (gaussianFitQuality) as RÂ² coefficient measuring how well the curve matches an ideal Gaussian."],CHANGED:["Bell apex shift and width scaling now use Gaussian falloff (exp(-dÂ²/2ÏƒÂ²)) instead of linear exponential, providing smoother weighting without cusp artifacts at the apex.","Bell curve resampling now uses PCHIP (monotone cubic Hermite) interpolation instead of linear interpolation, better preserving curve shape during transforms.","Curve shape classification now uses Savitzky-Golay smoothing by default (configurable), which preserves peak height better than moving average.","Chart rendering performance improved via static layer caching and RAF batching for update triggers.","Binary search optimization in interpolation functions reduces lookup complexity from O(n) to O(log n).","Error handling improvements in LAB redistribution pipeline for more robust correction processing.","Refactored toggle handlers to use centralized utilities (syncToggleState, initializeToggle)."],FIXED:[".quad file parser now supports externally-created files that lack the ## QuadToneRIP header. Channel count is inferred from data and standard names applied for 8-channel (P600/P800) and 10-channel (P700/P900) configurations.","XSS prevention via HTML escaping in status messages."],REMOVED:[],DOCS:["Added docs/features/bell-curve-improvements-plan.md documenting multi-agent audit results and implementation status."]},aboutDialog:[{label:"External .quad support",desc:"Parser now loads .quad files created by external tools (no header required). Channels inferred from data count."},{label:"Bell curve diagnostics",desc:"Classifier now reports asymmetry metrics and Gaussian fit quality (RÂ²) for better peak shape analysis."},{label:"Gaussian weighting",desc:"Bell apex shift and width scaling use smooth Gaussian falloff instead of linear exponential, eliminating cusp artifacts."},{label:"Performance improvements",desc:"Static layer caching, RAF batching, and binary search optimization reduce rendering and lookup overhead."}]},"4.3.4":{date:"2025-10-30",title:"LAB smoothing improvements",sections:{ADDED:[],CHANGED:["LAB smoothing defaults improved for better handling of sparse measurement regions: K_NEIGHBORS increased from 2 to 4 (more neighboring points influence smoothing), SIGMA_CEIL increased from 0.15 to 0.30 (allows wider Gaussian kernels in sparse regions).","Plot smoothing and LAB smoothing sliders now support up to 600% (previously capped at 300%) for extreme smoothing cases with noisy data or sparse measurement sets.","LAB smoothing slider now scales linearly instead of using power curve (exponent changed from 1.35 to 1.0), providing more predictable and monotonic smoothing behavior across the full range."],FIXED:["LAB smoothing slider no longer produces undulations (ripples that appear and disappear) as you increase the percentage. The combination of linear scaling and raised sigma ceiling prevents differential ceiling saturation across curve regions."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"LAB smoothing improvements",desc:"Better handling of sparse measurement regions with improved defaults (K_NEIGHBORS=4, SIGMA_CEIL=0.30) and extended slider range up to 600%."},{label:"Linear smoothing scaling",desc:"LAB smoothing slider now scales linearly (exponent 1.0 instead of 1.35), eliminating undulation artifacts and providing more predictable behavior."}]},"4.3.3":{date:"2025-10-29",title:"Correction gain fix",sections:{ADDED:[],CHANGED:[],FIXED:["Correction gain at 100% now applies full LAB linearization corrections instead of reverting to baseline curves. The zero-smoothing and normalization code paths no longer overwrite LAB-corrected curves with baseline data."],REMOVED:[],DOCS:["Updated correction gain, LAB ingestion, and global correction loader documentation with architectural details about Simple Scaling correction method and required guards to prevent baseline overwrite.","Added regression test coverage (tests/e2e/correction-gain-100-baseline.spec.ts) validating that 100% gain applies full LAB corrections and that 99% and 100% gain produce identical results."]},aboutDialog:[{label:"Correction gain 100% fix",desc:"At 100% gain, LAB corrections are now fully applied. Previously, zero-smoothing and normalization paths were overwriting corrected curves with baseline."}]},"4.3.2":{date:"2025-10-30",title:"Light blocking overlay fixes",sections:{ADDED:[],CHANGED:[],FIXED:["Light blocking overlay reference line now remains fully visible at all zoom levels instead of being cut off when zooming past 100%.","Light blocking overlay now updates immediately when channel density values change instead of requiring focus loss and mouse hover to refresh."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Light blocking overlay zoom fix",desc:"The reference line now scales correctly with zoom level and stays visible when zoomed in past 100%."},{label:"Light blocking real-time updates",desc:"The overlay refreshes immediately as you type density values instead of waiting for blur and mouseover."}]},"4.3.1":{date:"2025-10-29",title:"Global correction layout fix",sections:{ADDED:[],CHANGED:[],FIXED:["Global Correction tab content now stays inside the right-panel column, eliminating the doubled-width layout when you switch tabs."],REMOVED:[],DOCS:["Panel-system reference and manual regression matrix now cover the Global Correction tab layout guard plus the associated Playwright check."]},aboutDialog:[{label:"Global Correction layout guard",desc:"The Global Correction pane reattaches to the vertical tab wrapper on load, so selecting the ðŸŒ tab no longer stretches the right panel."}]},"4.3.0":{date:"2025-10-28",title:"Bell width scale",sections:{ADDED:["Bell-classified channels now show a Bell Width card beneath Bell Apex with linkable left/right percent inputs, Â±2â€¯% (Shift=Â±5â€¯%) nudges, and a Reset button so you can widen or tighten either side of the bell without reseeding Smart points."],CHANGED:["Curve-shape metadata now reports left/right span samples plus bellWidthScale state (factors + link flag), and Smart key points reuse the same distance-weighted pipeline so width edits keep ordinals intact."],FIXED:["Bell Width controls now disable Â± buttons while a request runs, apply link toggle changes immediately, and clamp manual percent inputs (40â€“250%) so reversing direction takes effect on the very next click.","Bell Width Smart curves now account for the previous width factor, so the first opposite-direction nudge moves Smart key points immediately instead of coasting in the old direction.","Reset now re-plots the original bell curve (not just Smart key points), so the curve instantly snaps back to the baseline when you set both sides to 100â€¯%.","Smart-mode Bell Width edits now regenerate the plotted samples so the chart follows the moved Smart key points instead of leaving the handles floating over an unchanged curve."],REMOVED:[],DOCS:["Updated `docs/features/bell_curve_shift.md`, `docs/manual_tests.md`, and Help â†’ Glossary/Version History to cover the Bell Width Scale workflow, metadata fields, and regression plan.","Documented the Smart bell-width regression alongside a new Playwright test (`tests/e2e/bell-width-scale.spec.ts`) and before/after screenshots so the plotted curve/Smart-handle sync stays traceable."]},aboutDialog:[{label:"Bell Width Scale",desc:"When Edit Mode is on and a channel detects as Bell youâ€™ll now see a Bell Width card (below Bell Apex) with left/right % inputs, link toggle, Â±2â€¯%/Â±5â€¯% nudges, and Reset so you can widen or tighten either slope without moving the apex."}]},"4.2.7":{date:"2025-10-26",title:"Bell apex refinements",sections:{ADDED:["Bell-classified channels expose a Bell Apex control in the Edit Curve panel with Â± nudges and numeric entry so you can shift the detected apex horizontally without reloading Smart curves."],CHANGED:["Curve-shape metadata now includes apex input/output percents plus bell-shift state, giving automation and the Help overlay direct insight into how far each bell has moved."],FIXED:[],REMOVED:[],DOCS:["Help â†’ ReadMe/Glossary/Version History and `docs/manual_tests.md` now cover the Bell Apex control, metadata fields, automation entry point, and Playwright regression."]},aboutDialog:[{label:"Bell Apex Shift",desc:"When Edit Mode is on and a channel detects as Bell youâ€™ll see a Bell Apex card in the Edit Curve panel with Â± buttons (Shift-click for bigger hops) and a numeric field; Smart ordinals stay put as you shift the apex."}]},"4.2.6":{date:"2025-10-27",title:"Curve-shape detector & icon badges",sections:{ADDED:["Curve-shape detector labels bell vs monotonic channels with ðŸ””/ðŸ“ˆ/âž¡ï¸ icon badges in the channel table and exposes metadata through `window.getChannelShapeMeta()` for automation."],CHANGED:["Badges now render glyphs onlyâ€”no colored pillâ€”keeping the sidebar tidy while tooltips reveal apex input and confidence."],FIXED:[],REMOVED:[],DOCS:["Help â†’ Glossary plus `docs/manual_tests.md` cover the curve-shape icon badges, apex/confidence tooltips, and Playwright regression."]},aboutDialog:[{label:"Curve-shape badges",desc:"Channel rows now show ðŸ”” (Bell), ðŸ“ˆ (Monotonic), or âž¡ï¸ (Flat) icons with apex/confidence tooltips, and `window.getChannelShapeMeta()` exposes the same metadata to scripts/tests."}]},"4.2.5":{date:"2025-10-26",title:"Global corrections override baked curves",sections:{ADDED:[],CHANGED:[],FIXED:["Loading a new LAB/CGATS/manual correction now reshapes baked `.quad` files right away instead of staying linear until you reduce the correction gain."],REMOVED:[],DOCS:["Manual regression checklist now includes a â€œGlobal Correction Overrides Baked Metadataâ€ test and the investigation lives in `artifacts/linearization_gain_bug.md`."]},aboutDialog:[{label:"Baked metadata cleared automatically",desc:"Fresh global corrections now override stale `bakedGlobal` flags so the plotted curve follows the dashed overlay at 100â€¯% gain, even on previously baked `.quad` files."}]},"4.2.4":{date:"2025-10-25",title:"Manual L* modal restored",sections:{ADDED:[],CHANGED:[],FIXED:["â€œEnter L* Valuesâ€ once again opens the Manual L* modal so you can enter measured patches without touching the source."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Manual L* flow",desc:"The full Manual Luminosity modal is backâ€”click â€œEnter L* Valuesâ€ under Global Correction to add measurements."}]},"4.2.3":{date:"2025-10-24",title:"Status banners back on-chart",sections:{ADDED:[],CHANGED:["Session status and status alerts sit on the chart edges again and stretch with the plotted width, so they stay aligned as you resize the panel."],FIXED:["Restored the legacy `window.elements` helper so automation and smoke tests can reach the channel table without custom wiring."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Chart-edge banners",desc:"Session status (top-left) and status alerts (top-right) now float over the chart again and resize with it."},{label:"Automation helper",desc:"`window.elements` is back, keeping smoke tests and scripts working without extra bootstrapping."}]},"4.2.2":{date:"2025-10-23",title:"Right-panel layout restoration",sections:{ADDED:[],CHANGED:[],FIXED:["Right panel (Edit Curve / Global Correction vertical tabs) now spans the full page height while Channels / Lab Tech / Preview stay anchored under the main chart column, resolving the collapsed side-panel layout."],REMOVED:[],DOCS:["Updated `docs/ui/panel-system.md` to document the three-child app-layout contract (main-content-area, panelDivider, rightPanel) so future HTML edits preserve the side panel."]},aboutDialog:[{label:"Side panel restored",desc:"Edit Curve and Global Correction tabs render beside the chart again instead of collapsing into the bottom tab stack."},{label:"Panel structure doc",desc:"Panel-system reference now calls out the required app-layout children, making it easier to keep the side panel wired correctly."}]},"4.2.1":{date:"2025-10-20",title:"Ink-load overlay & docs refresh",sections:{ADDED:["Cumulative ink-load overlay lives under âš™ï¸ Options, sums every enabled channel, and flips from dashed gray to solid red once totals clear the configurable warning threshold; tooltips now report the per-input total with an overshoot warning."],CHANGED:[],FIXED:[],REMOVED:[],DOCS:["Help â†’ ReadMe and Glossary call out the new ink-load overlay toggle, threshold control, and tooltip behaviour."]},aboutDialog:[{label:"Ink-load overlay",desc:"Toggle the cumulative ink trace in âš™ï¸ Options to monitor total coverage; dashed gray segments sit under your warning threshold while solid red highlights overshoot."},{label:"Help updates",desc:"ReadMe and Glossary now spell out the ink-load overlay controls and what the threshold warning cues look like."}]},"4.2.0":{date:"2025-10-19",title:"Reference overlay & Edit Mode polish",sections:{ADDED:["Light-blocking overlay can now load a reference `.quad`, letting you compare live curves against a saved baseline without leaving quadGEN."],CHANGED:["Edit UI is reorganized so Smart-curve controls live together and overlay toggles sit near the chart for faster access."],FIXED:["Dragging a Smart point now keeps neighboring markers aligned and preserves any ink-limit increase once you release the point."],REMOVED:[],DOCS:["Edit Mode spec documents that drag-based ink-limit raises persist after the move completes."]},aboutDialog:[{label:"Reference overlay",desc:"Load a reference `.quad` into the light-blocking overlay to spot deviations between your current curve and a saved baseline."},{label:"Streamlined Edit Mode",desc:"Curve-edit controls, overlay toggles, and Smart tools now sit together so you can tweak points and overlays without tab hopping."},{label:"Ink-limit drag persistence",desc:"Dragging a Smart point past the ink cap bumps the channel limit and keeps that headroom once you let go."}]},"4.1.0":{date:"2025-10-17",title:"Spot markers & correction gain blend",sections:{ADDED:["Manual L* modal remembers your last Patch % layout after Save/Generate so recurring manual workflows reopen with familiar spacing.","Measurement spot marker overlay (âš™ï¸ Options â†’ Show measurement spot markers) lines badges along a 70â€¯% rail with green checks for Â±1â€¯% tolerance and directional arrows showing how much to lighten or darken each patch.","Correction gain slider (ðŸŒ Global Correction) blends the identity ramp with the measured correction so you can audition partial mixes while charts, spot markers, previews, and exports stay in sync."],CHANGED:["Auto-raise ink limits now starts disabled; enable it per session when a correction needs extra headroom.","Correction overlay once again draws the dashed linear baseline for instant identity comparisons; light-blocking overlay now supports reference `.quad` file loading for visual comparison.","Measurement spot markers stay pinned to the unzoomed 70â€¯% rail and scale with the correction gain sliderâ€”0â€¯% shows all green checks, higher percentages expand the arrows and labels."],FIXED:["Plot smoothing reverted to the legacy boundary window to eliminate the reversal introduced by the earlier adaptive experiment."],REMOVED:[],DOCS:["Manual regression checklist now calls out the auto-raise default, notes the current highlight reversal at high smoothing, and documents the measurement spot marker overlay behaviour.","Plot-smoothing start/tail notes explain the present head/tail blend order for future rework.","Help ReadMe/Glossary highlight the correction overlay baseline return, the light-blocking overlayâ€™s missing reference guide, and the new measurement spot marker workflow.","Manual L* feature spec records that patch layouts persist after Save/Generate."]},aboutDialog:[{label:"Measurement spot markers",desc:"Enable the spot marker overlay in âš™ï¸ Options to see green checks for LAB readings within Â±1â€¯% and proportional arrows when a patch needs darkening or lightening; markers stay fixed on a 70â€¯% rail even while you zoom."},{label:"Correction gain slider",desc:"Blend between the identity ramp (0â€¯%) and the full LAB correction (100â€¯%); scrubbing now batches updates for ~150â€¯ms, then redraws the chart, markers, and exports with the selected mix."},{label:"Auto-raise default",desc:"Auto-raise ink limits loads disabled so you can opt in per session whenever a correction needs extra headroom."}]},"4.0.0":{date:"2025-10-15",title:"Options overlays & density workflow refresh",sections:{ADDED:["Options panel now includes light blocking and correction target overlays, plus default-on curve dragging and snapshot flags for faster Edit Mode work.","Channel ink locks and import-time auto-raise keep corrections aligned with ink ceilings.","Channel Density column ships with studio presets and a Compute button so manual versus solver constants stay traceable in the UI."],CHANGED:["Simple Scaling is the primary correction method with automatic density solver integration when needed.","Light mode loads by default, LAB smoothing starts at 0â€¯%, and overlays scale to the active ink ceiling for clearer comparisons.","Composite solver reuses normalized coverage ceilings, momentum weighting, and ladder tapers to hand off corrections smoothly while retaining guardrails."],FIXED:["Global .cube and .acv imports now stay monotone and correctly oriented, so baseline ramps reflect the intended shape.","Resetting LAB or plot smoothing to 0â€¯% restores baseline amplitude and ink-limit fields without manual clean-up.","Smart key points and undo history remain stable after channel-percent nudges or auto-raise adjustments."],REMOVED:[],DOCS:["Workflow guidance now lives in docs/quadgen_user_guide.md, and the print linearization guide consolidates LAB processing, manual density defaults, and Simple Scaling notes.","Auto-raise, density solver, and ingestion specs document smoothing interoperability and manual density inputs; Help ReadMe and Glossary mirror the updates."]},aboutDialog:[{label:"Options overlays",desc:"Toggle light blocking and correction targets directly from âš™ï¸ Options; curve dragging and snapshot flags now load enabled so edits feel immediate."},{label:"Density inputs",desc:"Channel Density fields ship with presets plus a Compute buttonâ€”manual overrides, solver results, and coverage badges now stay traceable in one place."},{label:"Simple Scaling default",desc:"Simple Scaling handles LAB corrections by default, while the density solver remains one click away when multi-ink redistribution is required."}]},"3.1.4":{date:"2025-10-07",title:"L* vs log-density normalization toggle",sections:{ADDED:["Log-density normalization toggle appears in both the Global Correction panel and Manual L* entry so operators can flip between perceptual (L*) and optical-density workflows."],CHANGED:["Perceptual L* remains the default for direct printer linearization; enabling the toggle converts LAB/CGATS/manual data to CIE log density (Dmax-normalized) for digital-negative calibration."],FIXED:["Global LAB/CGATS loads no longer mark the correction as baked just for toggling; the Global enable switch stays available for regression checks."],REMOVED:[],DOCS:["Print linearization guide, Help Version History, and internal references updated to explain when to use L* versus log density and note the new default."]},aboutDialog:[{label:"Normalization Toggle",desc:"Switch between perceptual L* and log-density processing directly from the Global Correction panel or Manual L* entry."},{label:"Digital-Negative Ready",desc:"Log-density mode converts LAB/CGATS/manual data with Dmax normalization so optical workflows land on the correct tone scale without double scaling."}]},"3.1.3":{date:"2025-10-07",title:"Baked ink-limit workflow refinements",sections:{ADDED:["Vitest coverage now exercises the rebased ink-limit workflow so undo/redo and baked-status metadata stay reliable."],CHANGED:["Smoke gate (`npm run test:smoke`) runs just the Playwright load check while the active-range diagnostics remain paused.","Percent and End inputs immediately show the effective ink limits when corrections (.cube/.txt) are active.","Undo/redo and revert flows restore the rebased ink limits so manual edits resume from the baked baseline instead of the original .quad."],FIXED:["Processing detail labels now surface â€œGlobal (baked)â€ so the graph header matches the rebased correction state.","Global LUT baking samples each correction once, keeping LUTs like `negative.cube` at their expected peak ink (~87 %)."],REMOVED:["Scaling State audit panel disappeared from Help â†’ Version History; telemetry now lives in diagnostics scripts."],DOCS:["Ink-limit simplification checklist documents the rebase execution plus the revert-alignment steps."]},aboutDialog:[{label:"Baked Workflow",desc:"Ink limit fields, history, and status badges now update to the rebased baseline the moment a correction is baked."},{label:"LUT Sampling",desc:"Global LUTs are sampled once per bake so sub-100% ramps (like negative plates) stay on target."}]},"3.1.2":{date:"2025-10-06",title:"Active-range flag & LUT clamp defaults",sections:{ADDED:["Active-range linearization flag (`enableActiveRangeLinearization`) stays opt-in with fresh Vitest coverage across delayed-onset, zero-ink, and tiny-span cases.","Cube endpoint anchoring flag now defaults off so sub-100% LUT maxima (like negative plates) load without manual toggles."],CHANGED:["apply1DLUT shares its interpolation prep across fixed and active-range paths while keeping the legacy route intact when the flag is disabled.","Smoke gate (`npm run test:smoke`) runs only the Playwright check; the active-range diff diagnostics are sidelined while the pipeline work is paused."],FIXED:["Global LUT application honours the cube-endpoint anchoring flag so LUT-driven scaling actually shows up in exported curves."],REMOVED:[],DOCS:["Print linearization guide documents active-range mapping plus the new flag toggle.","Active-range migration checklist now tracks the diagnostics hook status and how to re-enable the diff script when feature work resumes.","Help â†’ Version History and internal guides now explain how to disable or restore the cube endpoint clamp."]},aboutDialog:[{label:"Active-range Flag",desc:"Opt-in flag stays available with expanded tests and docs covering delayed-onset and zero-ink scenarios."},{label:"LUT Clamp Toggle",desc:"Cube endpoint anchoring defaults off so negative-density LUTs scale curves; re-enable the clamp when legacy exports need 0/100 endpoints."}]},"3.1.1":{date:"2025-10-06",title:"Quad export metadata polish",sections:{ADDED:[],CHANGED:["Exported .quad limit summary now reports the highest ink value present after corrections instead of mirroring the on-screen ink limit."],FIXED:["Linearization intent comments only appear when LAB/CGATS measurements are active, so LUT-only exports stay clean."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Accurate Ink Limits",desc:"Exported .quad headers now reflect the true peak ink after corrections, not just the UI cap."},{label:"Scoped Intent Notes",desc:"â€œLinearization Appliedâ€ comments show up only when LAB/CGATS data is baked into the export."}]},"3.1.0":{date:"2025-10-05",title:"Scaling coordinator rollout",sections:{ADDED:["Targeted Vitest coverage asserts AI-driven scaling requests travel through the coordinator with the correct metadata.","Help â†’ Version History now includes a Scaling State audit panel with live counters plus refresh/reset controls for the declarative-state rollout.","New scaling-state workflow tests (Vitest + Playwright) cover flag toggles, rapid scaling, and undo/redo parity."],CHANGED:["Global Scale calls are now queued behind undo-safe transactions when the coordinator flag is on; toggle via `enableScalingCoordinator(true)`.","Window/global scaling helpers queue through the coordinator and expose `legacy*` fallbacks for diagnostics utilities.","`scalingStateAudit` records per-reason counters and the diagnostics harness aggregates them for telemetry; dev builds enable `__USE_SCALING_STATE` by default."],FIXED:["Smart point parity for preloaded `.quad` curves samples relative ink, keeping Edit Mode key points aligned when channels are limited.","Lab Tech scaling commands now surface coordinator failures instead of reporting success on rejected queue operations.","Scaling-state parity remains intact when clamping back to 100 % ink; `maxAllowed` resets alongside legacy globals.","Undo/redo history refresh uses UI hooks, eliminating the missing-trigger warnings seen in scaling-state Playwright runs.","Contrast intent reapply is idempotentâ€”the original baseline is reused so repeated picks no longer compound the curve.","Per-channel ink limit edits rescale the original `.quad` samples and skip default Smart ramps while Edit Mode is off, preventing linearized plots."],REMOVED:[],DOCS:["Phase 0 scaling checklist, regression matrix, and in-app notes updated for handoff.","CLAUDE.md and AGENTS.md now document the coordinator flag (`enableScalingCoordinator`) and window bridge.","Scaling UI migration checklist and Smart/LAB parity diagnostics updates captured in `docs/features/SCALING_IMPROVEMENT_PLANS.md`.","Clamp-to-100 parity fix, undo trigger corrections, and private-lab rollout workflow documented across Phase 2 plan/checklists and `docs/manual_tests.md`."]},aboutDialog:[{label:"Scaling Coordinator",desc:"Global Scale now routes through the transaction-aware coordinator, with diagnostics fallbacks and expanded telemetry."},{label:"Smart Curve Parity",desc:"Preloaded .quad curves keep their shapeâ€”Smart points and ink-limit edits stay aligned without auto-created ramps."},{label:"Workflow Coverage",desc:"Fresh Vitest and Playwright suites exercise scaling-state toggles, undo/redo parity, and AI-driven queue usage."},{label:"Docs Refresh",desc:"Phase 0 handoff notes, scaling plans, and manual test guides now cover the coordinator rollout and parity fixes."}]},"3.0.4":{date:"2025-10-04",title:"Smart baking guard",sections:{ADDED:[],CHANGED:[],FIXED:["Smart curve baking now reseeds the full LAB measurement set and marks the graph status as *BAKED* on first enable, avoiding the two-point collapse regression.","Global revert button disables once LAB data is baked into Smart curves so you arenâ€™t led to a silent no-op; undo remains available for rollbacks."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Smart Baking",desc:"LAB corrections converted into Smart curves keep every measurement point and display the *BAKED* tag immediately."},{label:"Revert Guard",desc:"Once a correction is baked, the global revert control deactivatesâ€”undo is the path back to raw measurements."}]},"3.0.3":{date:"2025-10-03",title:"Smart scaling polish",sections:{ADDED:["Added a Playwright regression that verifies inserting a Smart point with MK limited to 50% lands on the plotted curve.","Added a Playwright regression that exercises global Scale with Edit Mode enabled so Smart curves stay aligned after ink-limit changes."],CHANGED:[],FIXED:["Smart point insertion and recompute now respect per-channel ink limits, eliminating the double-scaled plots and missing markers introduced after the scaling tweaks.","Global scale now preserves Smart curve positioning by skipping the redundant relative-output rescale, preventing the 0.8^2 shrink when scaling after edits, and per-channel edits reapply the active Scale so you canâ€™t bypass the multiplier."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Smart Points",desc:"Editing Smart curves with reduced ink limits no longer double scales the plot or drops control points."},{label:"Regression Suite",desc:"New Playwright coverage keeps Smart-point insertion and global Scale interactions stable."}]},"3.0.2":{date:"2025-10-03",title:"Global + Nudge polish",sections:{ADDED:["Added a Playwright regression to confirm the Edit Mode Delete button removes an interior Smart key point as expected.","Added a Playwright regression that covers LK ink-limit edits after toggling Edit Mode so the state stays in sync.","Added a Playwright regression that flips the global correction toggle to ensure LAB data can be disabled and re-enabled.","Added a Playwright regression that verifies Edit Mode nudges stay at a 1% step even with zoom and reduced ink limits."],CHANGED:[],FIXED:["Edit Mode Delete button removes the selected Smart key point again instead of doing nothing.","LK per-channel scaling now increases the ink limit when you raise the percentage after leaving Edit Mode.","Global correction toggle now actually disables the loaded LAB correction until you turn it back on.","Edit Mode nudges now move points by exactly 1% in chart space; zoom and reduced ink limits no longer amplify the step."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Smart Point Nudges",desc:"Edit Mode nudges now move Smart points by exactly 1% even after you zoom the chart or limit channel ink."},{label:"LAB Toggle",desc:"Global LAB/LUT corrections truly disable when you flip the toggle off, matching the legacy behaviour."},{label:"Regression Coverage",desc:"Playwright tests cover Delete button, LK scaling, global toggle, and Smart-point nudges."}]},"3.0.1":{date:"2025-10-02",title:"Intent remap parity",sections:{ADDED:["Added a Playwright regression to confirm the Intent dropdown enables after loading a .quad file."],CHANGED:[],FIXED:["Restored PoPS Matte, PoPS Uncoated, and PoPS Uncoated (softer) intent presets so the modular dropdown matches the legacy single-file build.","Intent dropdown now enables automatically after loading a .quad whenever no LAB/CGATS measurement is active."],REMOVED:["Removed the legacy parity harnesses that relied on `quadgen.html`; automated tests now target modular quadGEN only."],DOCS:[]},aboutDialog:[{label:"Contrast Intent Parity",desc:"PoPS Matte/Uncoated presets return to the modular dropdown, matching the legacy quadGEN lineup."},{label:"Intent Remap",desc:"Intent dropdown now enables automatically after you load a .quad when no LAB/CGATS data is active."},{label:"Regression Coverage",desc:"New Playwright regression verifies the Intent controls stay enabled after loading .quad files."},{label:"Test Suite Cleanup",desc:"Legacy parity harnesses tied to quadgen.html were retired so automated checks focus on the modular build."}]},"3.0.0":{date:"2025-10-01",title:"Modular milestone",sections:{ADDED:[],CHANGED:["Modularization work: retired `src/extracted_javascript.js`; every UI panel, parser, and history hook now imports shared ES modules.","Modularization work: rebuilt global/per-channel revert and Edit Mode to share the measurement-seed/state helpers used by Lab Tech.","Modularization work: consolidated file ingestion (.quad, LAB/CGATS/CTI3, Manual L*, LUT, ACV) onto the modular printer-space pipeline with consistent smoothing/metadata.","Modularization work: reorganized the workspace (`src/`, `scripts/`, `docs/`, `archives/`) and documented a regeneration toolchain (architecture map, doc index, Playwright guard).","Benefits: clear separation of concernsâ€”state management, UI, parsing, and math live in focused modules, simplifying onboarding and review.","Benefits: undo/redo, Lab Tech automation, and manual UI share codepaths, reducing drift and regression risk.","Benefits: file handling parity across sources enables centralized future tweaks with consistent smoothing/anchoring.","Benefits: cleaner project tree keeps builds/tests/docs aligned with the modular distribution.","Benefits: modular structure improves portability; the same source can be bundled for web, packaged for desktop, or embedded in other tooling."],FIXED:["Channel percent/end inputs no longer revert while you type; values commit on change instead of every keystroke."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Modularization Work",desc:"Modularization work: retired `src/extracted_javascript.js`; every UI panel, parser, and history hook now imports shared ES modules."},{label:"Modularization Work",desc:"Modularization work: rebuilt global/per-channel revert and Edit Mode to share the measurement-seed/state helpers used by Lab Tech."},{label:"Modularization Work",desc:"Modularization work: consolidated file ingestion (.quad, LAB/CGATS/CTI3, Manual L*, LUT, ACV) onto the modular printer-space pipeline with consistent smoothing/metadata."},{label:"Modularization Work",desc:"Modularization work: reorganized the workspace (`src/`, `scripts/`, `docs/`, `archives/`) and documented a regeneration toolchain (architecture map, doc index, Playwright guard)."},{label:"Benefits",desc:"Benefits: clear separation of concernsâ€”state management, UI, parsing, and math live in focused modules, simplifying onboarding and review."},{label:"Benefits",desc:"Benefits: undo/redo, Lab Tech automation, and manual UI share codepaths, reducing drift and regression risk."},{label:"Benefits",desc:"Benefits: file handling parity across sources enables centralized future tweaks with consistent smoothing/anchoring."},{label:"Benefits",desc:"Benefits: cleaner project tree keeps builds/tests/docs aligned with the modular distribution."},{label:"Benefits",desc:"Benefits: modular structure improves portability; the same source can be bundled for web, packaged for desktop, or embedded in other tooling."}]},"2.6.4":{date:"2025-09-27",title:"Legacy LAB/CGATS alignment",sections:{ADDED:[],CHANGED:[],FIXED:["Legacy LAB loader and manual L* entry now use the printer-space inversion helper (density smoothing + PCHIP) so symmetric datasets cross at 50% without flattening.","Legacy CGATS/CTI3 imports share the same inversion helper, keeping plotted curves monotone with anchored endpoints and matching smoothing previews."],REMOVED:[],DOCS:["Updated CGATS.17 spec summary in the Help documentation to note the shared inversion workflow."]},aboutDialog:[{label:"LAB & CGATS Parity",desc:"Legacy quadGEN now matches the modular printer-space inversion, so LAB, manual, and CGATS curves line up."},{label:"Documentation",desc:"CGATS.17 spec entry explains the shared inversion + smoothing behaviour."}]},"2.6.3":{date:"2025-09-21",title:"Scale control handoff",sections:{ADDED:[],CHANGED:["Lab Tech AI exposes scale_channel_ends_by_percent, so the assistant can drive the global Scale control directly.","Use the Scale field above the channel list to adjust every End value proportionally.","Global Scale input now auto-clamps once any channel would reach 100% (65,535) and accepts entries up to 1000% for proportional boosts.","Graph labels track the highest ink value on each curve so low-limit channels no longer display inflated percentages.","Removed the dotted intent reference overlay when only a .quad curve is loaded for a cleaner plot."],FIXED:["Global Scale control now scales against per-channel baselines, so 90% â†’ 95% applies once instead of stacking and channel edits no longer throw baseline errors.","Printer initialization defers intent guards until a .quad is loaded, eliminating the missing hasLoadedQuadCurves reference on startup."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Scale Control",desc:"Global Scale reuses cached baselinesâ€”90%â†’95% no longer compounds and channel edits stay clean."},{label:"Scale Field",desc:"Use the Scale field above the channel list to adjust every End value proportionally."},{label:"Auto Clamp",desc:"Scaling stops automatically when the first channel would hit 100% ink (65,535), and the input now accepts up to 1000%."},{label:"Chart Labels",desc:"Ink labels sit at the peak ink value, so flat curves report the true endpoint."},{label:"Clean Plot",desc:"The dotted intent reference is hidden when only a .quad is loaded, keeping the chart uncluttered."},{label:"Lab Tech",desc:"Assistant can set the Scale via scale_channel_ends_by_percent without touching individual channels."}]},"2.6.2":{date:"2025-09-20",title:"1D LUT limit increase",sections:{ADDED:[],CHANGED:["1D .cube parser now accepts up to 256 samples even without a LUT_1D_SIZE header."],FIXED:["Channel percent/end inputs no longer revert while you type; values commit on change instead of every keystroke."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"1D LUT Support",desc:"1D .cube imports now handle up to 256 samples; include LUT_1D_SIZE when possible for clarity."}]},"2.6.1":{date:"2025-09-20",title:"Intent remap guard + opt-in sweeps",sections:{ADDED:[],CHANGED:["Intent tuning sweep tests now skip by default; set QUADGEN_ENABLE_TUNING_SWEEPS=1 to run the long-form harness."],FIXED:["Apply Intent remains available after loading a global .acv or .cube; it only disables when active LAB/CGATS/TI3 measurement data is applied."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Intent Remap Guard",desc:"Apply Intent stays available after loading global .acv/.cube data unless a LAB/CGATS/TI3 measurement is active."}]},"2.6.0":{date:"2025-09-20",title:"CGATS parity + rolloff pause",sections:{ADDED:["Recognized Argyll CTI3 (.ti3) measurement files alongside CGATS.17 for LAB linearization imports."],CHANGED:["Standardized all user-facing terminology to say â€œKey Pointâ€ across labels, tooltips, and status messages.","Auto white/black limit rolloff controls are temporarily hidden while we retune the detector; no automatic knees apply in this build."],FIXED:["CGATS.17 importer now treats CMY values within Â±2.5% as neutral, keeping K-only ramps aligned with their LAB counterparts."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"CGATS.17 Support",desc:"Import CGATS.17 grayscale measurement sets natively for LAB linearization."},{label:"Argyll CTI3",desc:"Load Argyll-style .ti3 files directlyâ€”handled with the same parser and parity checks as CGATS.17."},{label:"Auto Rolloff",desc:"White/black auto limit knees are offline for now; curves export exactly as plotted."}]},"v2.5.3":{date:"2025-09-19",title:"Glossary hardware refresh",sections:{ADDED:["Glossary now covers Colorimeters, Spectrophotometers, and the Epson P900, with direct links to recommended devices."],CHANGED:[],FIXED:["Channel percent/end inputs no longer revert while you type; values commit on change instead of every keystroke."],REMOVED:[],DOCS:["ReadMe and Help updated with Epson trademark notice plus Nix Spectro L guidance for spectrophotometer workflows."]},aboutDialog:[{label:"Glossary/documentation",desc:"Added more glossary entries, other documentation edits."}]},"v2.5.2":{date:"2025-09-19",title:"LAB revert guard + debug trims",sections:{ADDED:["Lab Tech now understands extended zoom phrases like â€œzoom way inâ€ or â€œzoom all the way out,â€ mapping them to the chart controls automatically.","Automated smoke test (`tests/load_quad_smoke.spec.js`) verifies `.quad` loading succeeds without runtime errors."],CHANGED:[],FIXED:["Edit Mode now seeds Smart curves from every LAB patch (up to 64) and restores the original measurement ink limit after Smart edits, so toggling Edit Mode or reverting no longer hides patches or shrinks endpoints.","Revert to Measurement now clears LAB linearization data before restoring the .quad, eliminating shrunken endpoints when Edit Mode is re-enabled."],REMOVED:[],DOCS:["Updated in-app ReadMe installation links and `docs/quadgen_user_guide.md` to point to the primary domain `https://quadgen.ink/`.","Replaced â€œmasterâ€ terminology with â€œreferenceâ€ in documentation and in-app help to reflect preferred language.","Added a glossary entry defining â€œreference curveâ€ to keep Help â†’ Glossary aligned with the new terminology."]},aboutDialog:[{label:"LAB Revert Guard",desc:"Global revert now restores the original measurement ink limit, so Edit Mode comes back with the full patch set intact."}]},"v2.5.1":{date:"2025-09-18",title:"Zoom presets + curve stability",sections:{ADDED:["Chart zoom controls (+/âˆ’) rescale the ink plot, persist per browser, and expose Lab Tech commands (`set_chart_zoom`, `nudge_chart_zoom`).","Tests/chart_zoom.spec.js exercises the zoom helpers (percentâ†”Y mapping, persistence, button guards).","Lab Tech understands simple â€œzoom inâ€ / â€œzoom outâ€ phrasing and routes it to the controls."],CHANGED:["Zoom now steps through clean 10% increments, clamps to the highest active ink limit, and leaves one highlight step even when a channel peaks at 100% so you can still inspect the curve without losing awareness of the ceiling.","Graph grids, axes, overlays, and tooltips all derive from the active zoom so the Y-axis always matches what you see."],FIXED:["Undo/redo of Smart key-point edits keeps the rest of the curve stable; only the edited point moves when you step backward or forward.","â€œ+â€ now magnifies (lower max) and â€œâˆ’â€ zooms out, matching expectations."],REMOVED:[],DOCS:["Help â†’ ReadMe & Detailed Workflow, QUADGEN_README.md, and AGENTS.md document the zoom workflow and automation hooks."]},aboutDialog:[{label:"Zoom Presets",desc:"Use the +/âˆ’ control (or Lab Tech commands) to step through 10% zoom levels; when a channel peaks at 100% quadGEN still lets you inspect one more step and flattens anything above the displayed max."},{label:"Stable Undo",desc:"Smart key-point undo/redo keeps the rest of your curve anchored so only the edited point moves."}]},"v2.5.0":{date:"2025-09-17",title:"Intent remap automation + button polish",sections:{ADDED:["Apply Intent now bakes the selected preset into the loaded .quad even when no LAB/manual data is activeâ€”ideal for branching variants from a reference linear profile.","Lab Tech assistant can call apply_intent_to_loaded_quad() to bake the current preset without manual clicks."],CHANGED:[],FIXED:["Channel percent/end inputs no longer revert while you type; values commit on change instead of every keystroke."],REMOVED:[],DOCS:[]},aboutDialog:[{label:"Added",desc:"Apply Intent to bake contrast intents into your loaded .quadâ€”even without LAB data."},{label:"Lab Tech Automation",desc:"Lab Tech can invoke apply_intent_to_loaded_quad() to bake the current preset on command."}]},"v2.4.0":{date:"2025-09-16",title:"Centralized printer-space pipeline + smoothing defaults",sections:{ADDED:["Printer-space sanity fixtures with FEATURE_EXPECTATIONS guide so you can spot curve regressions quickly.","Node scripts cover DataSpace conversions, make256 helpers, and automated intent sweeps; history flow spec stubbed for headless undo/redo.","Debug-only Intent Tuning panel (enable DEBUG_INTENT_TUNING) to audition smoothing and LAB overrides inside quadGEN.","â€œApply to Loaded Curveâ€ button lets you bake the active intent into a loaded .quad without re-running LAB corrections."],CHANGED:["Auto white/black limit rolloff controls are temporarily hidden and no longer apply knees while we retune the detector for consistency.","Measurement rebuild keeps the legacy baseline widen Ã—1 pass (slider default 0%) and still honours LAB bandwidth overrides (K=2, Ïƒ_floor=0.036, Ïƒ_ceil=0.15, Ïƒ_alpha=2.0); dial the smoothing slider above 0% only when you need extra cleanup.","DataSpace now owns every imageâ†’printer conversion; loaders tag missing sourceSpace metadata and make256 helpers were split out for clarity.","Undo/redo shares a single timeline so intent swaps, channel edits, and history snapshots stay in sync.","Debug tuning panel drops the experimental intent blend slider to focus on smoothing/LAB controls, and automated intent tolerance is now 8% to match the new defaults.","Cached per-channel row lookups trim DOM thrash during LAB updates and history playback.","Intent dropdown previews the selected curve on the chart before you bake it into a .quad."],FIXED:["Undo now clears per-channel measurement switches alongside loaded data.","Legacy printer-space datasets without explicit sourceSpace metadata no longer get flipped on reload.","Undo/redo preserves the LAB / Manual L* smoothing hook so scripted smoothing continues to work.","Contrast intent status banner reports the active preset instead of always showing Linear.","Intent remap honours existing ink limits, reverting to Linear restores the original .quad curve, and undo/redo preserves that exact shape."],REMOVED:[],DOCS:["Updated QUADGEN_DATA_TYPES.md, QUADGEN_DEVELOPMENT.md, QUADGEN_AI_INTEGRATION.md, and AGENTS.md with sourceSpace guidance and regression workflows."]},aboutDialog:[{label:"Auto Rolloff Hidden",desc:"White/black auto limit toggles are offline while we recalibrate the detector."},{label:"Printer-space Pipeline",desc:"DataSpace now owns every conversion and the new fixtures/tests catch double-flip regressions early."},{label:"Smoothing Defaults",desc:"LAB rebuilds now open at 0% smoothing (baseline widen Ã—1.0); raise the 0â€“300% slider only when your measurements need additional noise reduction."},{label:"Intent Remap",desc:"Use Apply to Loaded Curve to bake the selected intent into a linearized .quadâ€”no external LUT required. Intent previews now render as soon as you pick a preset."}]},"v2.3.0":{date:"2025-09-16",title:"Auto endpoint rolloff (white/black) + UX",sections:{ADDED:["Auto endpoint rolloff now has independent white/black limit toggles so you can knee only the side that needs protection.","Glossary: added Auto white limit, Auto black limit, and Endpoint rolloff entries.","Chart markers: dashed red/blue lines indicate detected knee start/end while the respective Auto limit is on.","Lab Tech assistant: new set_auto_white_limit / set_auto_black_limit commands to toggle Auto endpoint rolloff from chat."],CHANGED:["Threshold: proximity epsilon increased to 3% of End for clearer shoulders on long plateaus.","Auto endpoint rolloff now exposes independent white/black limit checkboxes (defaults: white OFF, black ON) with persisted preferences and per-side baking guards.",".quad generation and channel controls now use the full 0â€“65,535 16-bit scale instead of 0â€“64,000; UI ranges and validation updated accordingly so ink limits align with QuadToneRIP conventions.","Chart background: Enhanced visual structure with subtle accent lines - darker 50% crossover grid lines and boundary lines from 100,0â†’100,100 and 0,100â†’100,100 to improve coordinate reference."]},aboutDialog:[{label:"Auto Rolloff Controls",desc:"Independent white/black knees with 3% proximity threshold keep endpoints smooth without flattening the curve."},{label:"Lab Tech Integration",desc:"New chat commands toggle Auto white/black limits directly from the assistant."},{label:"Ink Limit Alignment",desc:"Full 0â€“65,535 scaling and dashed knee markers keep the UI aligned with QuadToneRIP expectations."}]},"v2.2.3":{date:"2025-09-15",title:"Intent system fixes + Documentation improvements",sections:{ADDED:[`Help glossary entries for "Image space" and "Printer space": Added comprehensive definitions explaining the coordinate system differences that are central to quadGEN's data transformation pipeline. Image space (0=black pixel, 100=white pixel) vs printer space (0=white/no ink, 100=black/maximum ink) with explicit (0,0) and (100,100) coordinate meanings for both systems.`,"PoPS (Prints on Paper Studio) glossary entry: Added definition with link to their website and note about contrast intent presets included in quadGEN.","MIT License: Added complete license text to Help ReadMe section with proper attribution and scope clarification.","Prints on Paper Studio attribution: Added formal attribution in Help ReadMe Credits section for contrast intent definitions used with permission under GNU Public License."],CHANGED:["Contrast intent system architecture: Centralized all preset definitions (Linear, Soft, Hard, Filmic) into single source object. Removed sliders from Preset tab in favor of descriptive text. Preset dropdowns now populate dynamically from central definitions, making preset management more maintainable."],FIXED:["Intent system image-to-printer space conversion: Fixed critical issue where custom pasted intent data wasn't being transformed consistently with preset intents. All intent types now use the same image-to-printer space transformation pipeline (horizontal flip + vertical inversion) as ACV/LUT files, ensuring consistent behavior across preset and custom intents.","Custom intent data parsing for 0-255 range: Fixed parsing failure when pasting intent data with 0-255 range values (common in image editing workflows). Parser now auto-detects range (0-100 vs 0-255) and normalizes appropriately, preventing data truncation and visualization artifacts.","LAB linearization with custom intents: Resolved issue where LAB linearization would revert to linear when custom intent data was applied, caused by NaN values in the correction algorithm due to improper intent data transformation.","Auto-detection for mixed-range data: Added consistent range detection logic to parseIntentPaste(), parseLabData(), parseManualLstarData(), and buildManualLinearizationFromOriginal() functions. Input values auto-detect 0-100 vs 0-255 ranges while maintaining CIE LAB standard (L* values always 0-100)."]},aboutDialog:[{label:"Intent System Overhaul",desc:"Fixed critical image-to-printer space conversion issues, 0-255 range parsing, and LAB linearization compatibility with custom intents."},{label:"Enhanced Documentation",desc:"Added comprehensive glossary entries for coordinate systems, PoPS attribution, and complete MIT license in Help section."},{label:"Data Range Auto-Detection",desc:"Improved parsing across multiple functions to handle both 0-100 and 0-255 input ranges automatically."},{label:"Architecture Improvements",desc:"Centralized intent preset definitions and improved preset management workflow."}]},"v2.2.2":{date:"2025-09-15",title:"UI refinements + Intent behavior improvements",sections:{CHANGED:["Edit Mode panel layout: Consolidated Calculate points controls onto single row with centered field labels and aligned Recompute button. Improved Point section spacing and reduced graph container margins for tighter UI layout.","Edit Mode help modal: Clarified data conversion to Smart curves, added Calculate points section explaining Max error %/Max points/Recompute functionality, and improved terminology throughout.",'Global Correction & Intent help modal: Added correction process overview, warning section explaining when Intent takes effect, and link to Detailed Workflow. Modal title changed from "Correction vs. Intent" to "Global Correction & Intent". Reorganized content with card-based layout for improved readability and visual hierarchy.',"Intent dropdown behavior: Now automatically disables when no linearization data is loaded (visual feedback with grayed appearance). Eliminates confusion about why Intent appears inactive with .quad files only."],FIXED:['Edit Mode revert button: Fixed issue where the revert button would appear to work but continue showing "Smart Curve" status when used in Edit Mode. The button now properly clears Smart curve data and displays the original loaded .quad status without automatic restoration interference.']},aboutDialog:[{label:"UI Layout Refinements",desc:"Improved Edit Mode panel layout, Point section spacing, and graph container margins for better space utilization."},{label:"Enhanced Help Modals",desc:"Clarified Edit Mode help with Smart curve explanation and reorganized Global Correction help with card-based layout."},{label:"Intent Dropdown Feedback",desc:"Intent dropdown now disables and grays out when no linearization data is loaded, eliminating user confusion."},{label:"Edit Mode Revert Fix",desc:'Fixed revert button issue that continued showing "Smart Curve" status after reverting in Edit Mode.'}]},"v2.2.1":{date:"2025-09-14",title:"ACV/LUT orientation parity + Undo pairing fixes",sections:{ADDED:["Custom Intent: new Import Target (ACV/LUT) tab â€” load .acv/.cube as a target intent (not a correction), with endpoint anchoring, monotonic enforcement, and optional blend with current target."],FIXED:["ACV/LUT orientation centralized in parsers (flip + invert once); removed duplicate reverse+invert in loaders â€” Photoshop â€œlightenâ€ now shows less ink (down hump).","Undo pairing for load actions now uses the most recent matching â€œBefore:â€ state â€” undoing multiple global loads steps back to the immediately previous correction."],CHANGED:[]},aboutDialog:[{label:"Import Target (ACV/LUT)",desc:"New Custom Intent tab to load .acv/.cube as a target intent; includes anchor/monotonic options and blend with current."},{label:"Orientation Parity",desc:"ACV and LUT imports apply flip+invert once in the parser; loaders no longer reapply."},{label:"Undo Pairing",desc:"Undo of consecutive loads returns to the previous correction, not an empty state."}]},"v2.2.0":{date:"2025-09-13",title:"Local-Ïƒ LAB reconstruction, Manual L* parity, console clarity",sections:{FIXED:["Manual L* and LAB status lines clarified: Î” vs linear now labels positions as % input; removed duplicate method note","Preview update ReferenceError fixed in LAB smoothing provider (removed stale radius reference)"],CHANGED:["LAB/Manual L* mapping now uses CIE luminance â†’ density (âˆ’log10(Y)) with Dmax normalization (replaces min/max L* normalization); improves shadow convergence; existing .quad files unaffected","LAB reconstruction now uses Gaussian-weighted regression with a local adaptive bandwidth based on median neighbor spacing (robust to uneven spacing and dense datasets)","Manual L* now uses the same CIE density + local-Ïƒ Gaussian reconstruction as LAB (full parity)"],ADDED:[]},aboutDialog:[{label:"CIE Density Mapping",desc:"LAB/Manual L* now use CIE luminance â†’ density (âˆ’log10(Y)) for corrections; better shadow handling, stable highlights."},{label:"Local-Ïƒ Reconstruction",desc:"Gaussian weights now adapt to local patch spacing for smoother, robust LAB curves."},{label:"Manual L* Parity",desc:"Manual L* uses the same reconstruction as LAB for consistent results."},{label:"Console Clarity",desc:"Î” vs linear shows â€œ% inputâ€; method note appears once on load/apply."}]},"v2.1.0":{date:"2025-09-13",title:"Edit Mode reliability, Revert fixes, channel-colored labels",sections:{FIXED:["Double-scaling eliminated when toggling Edit Mode OFFâ†’ON on Smart-sourced channels","Ordinal labels no longer collapse to the X-axis when switching to a newly enabled channel","Revert to measurement clears lingering Smart source tags (no linear ramp fallback)","Revert preserves the selected channel in Edit Mode and redraws overlays/labels correctly"],ADDED:[".quad Preview: lightweight syntax highlighting and non-copying line numbers",".quad Preview: per-line channel gutter tint with auto-contrast line numbers","Revert UI: added global and per-channel Revert buttons with integrated Undo/Redo","Help: new Detailed Workflow tab plus Version History moved into Help window","Lab Tech console (light mode): One Lightâ€“inspired text theme with terminal-style lines","Dark mode toggle: header button (ðŸŒ™/â˜€ï¸) to switch themes; sessions start in light mode and quadGEN remembers your choice (still follows system changes when you reset to system preference)"],CHANGED:["Ordinal label chips now match the exact channel ink color with automatic black/white text for contrast","Edit channel selection instantly redraws overlays to reflect the selected channel","Dark mode polish: improved input/scrollbar contrast, help tab selection contrast, and preview readability"]},aboutDialog:[{label:"Edit Reliability",desc:"No more double-apply on Smart curves when toggling Edit Mode."},{label:"Revert UX",desc:"Revert keeps your selected channel and restores measurement plotting."},{label:"Channel-Colored Labels",desc:"Ordinal labels use the exact plot color for the selected channel."},{label:".quad Preview",desc:"Syntax highlighting, line numbers, and channel-colored gutter."},{label:"Lab Tech Theme",desc:"Polished console theme (light mode) for readability."},{label:"Dark Mode Toggle",desc:"Added header toggle (ðŸŒ™/â˜€ï¸); remembers your choice and follows system preference."}]},"v2.0.5":{date:"2025-09-13",title:"Edit toggle double-scaling fix + stability",sections:{FIXED:["Edit toggle OFFâ†’ON no longer double-applies global on Smart-sourced channels","Entering Edit Mode after load no longer reverts plotted curve to a linear ramp while key points stay at prior shape","Undo/Redo restore bakedGlobal meta with interpolation to keep plots/overlays aligned","Revert preserves selected channel in Edit Mode and clears Smart source tags so plots/labels reflect the measurement again"]},aboutDialog:[{label:"Edit Toggle",desc:"No more double application when toggling Edit Mode; Smart-sourced channels are treated as baked."},{label:"Plot Alignment",desc:"Plot stays aligned to key points when entering Edit Mode after loading data."},{label:"Revert UX",desc:"Revert keeps your selected channel and restores measurement plotting (no MK fallback labels)."}]},"v2.0.4":{date:"2025-09-11",title:"Edit Mode Ã— Linearization Fixes + Dark Mode Polish",sections:{FIXED:["Global linearization applies even when Smart points exist (Edit Mode ON)","Recompute samples the current plotted curve (respects global/per-channel corrections and End)","Double-apply guard: recomputed Smart curves â€œbakeâ€ global correction once (no extra global on top)"],CHANGED:["Near-linear detection tightened (0.5%â†’0.2%, 5â†’11 samples) to avoid collapsing lightly corrected curves","Dark mode: input fields (percent/end, filename, L*, edits) use darker backgrounds and clearer focus","Dark mode: toggle sliders use darker tracks and high-contrast knobs; key-point ordinal labels use theme text color"]},aboutDialog:[{label:"Global + Smart",desc:"Global corrections now work with Edit Mode ON; recompute bakes global once to avoid double application."},{label:"Recompute Source",desc:"Recompute uses the currently plotted curve so points match what you see."},{label:"Dark Mode",desc:"Improved readability for inputs, toggles, and labels."}]},"v2.0.3":{date:"2025-09-10",title:"Detailed Workflow Guide in Help",aboutDialog:[{label:"Detailed Workflow",desc:"Added a new Help tab with a step-by-step calibration guide (LAB and EDN workflows), including ink-limit verification and target printing."},{label:"ReadMe/Help Polish",desc:"Improved Installation links, Glossary entries, and formatting; Help button updated with icon."}]},"v2.0.2":{date:"2025-09-10",title:"Tabbed Help + About Removed",aboutDialog:[{label:"Help Tabs",desc:"Help window now has ReadMe, Glossary, and Version History tabs."},{label:"Version History",desc:"Moved from the separate About dialog into Help â†’ Version History."},{label:"About Removed",desc:"Removed the About button and popup; all info is available in Help."}]},"v2.0.1":{date:"2025-09-09",title:"Embedded Help Window",aboutDialog:[{label:"Help Content",desc:"Help window now displays embedded documentation (Overview, Quick Start, Features, Troubleshooting, External References). No separate inline help to maintain."},{label:"Header",desc:"Help header matches the main app (logo + version)."},{label:"Formatting",desc:"Help content is styled for readability; headings, lists, links, and code are preserved."}]},"v2.0":{date:"2025-09-09",title:"Edit Mode, Smart Curves, Robust History",sections:{ADDED:["Edit Mode: gates all keyâ€‘point edits and overlay visibility; APIs respect mode state","Undo/Redo: full history for insert/adjust/delete/recompute and Edit Mode toggles","Smart Curve: renamed from â€œAI curveâ€; writes source tag â€œsmartâ€, reads legacy â€œaiâ€; legacy AI function names remain as aliases","Absolute coordinates: XY input and Up/Down nudges use absolute Y (postâ€‘End); Left/Right adjust X (preâ€‘scale)","Redo parity: redo restores Smart key points + interpolation and recomputes curves to match overlays","Inkâ€‘limit guard: blocks edits that would exceed End when End cannot be raised, with a clear status message"]},aboutDialog:[{label:"Edit Mode",desc:"All keyâ€‘point edits require Edit Mode; overlays show only when ON"},{label:"History",desc:"Undo/Redo covers edits and Edit Mode toggles"},{label:"Smart Curves",desc:"â€œAI curveâ€ â†’ â€œSmart Curveâ€; reads ai/smart, writes smart; APIs keep AI aliases"},{label:"Absolute Y",desc:"XY input and Up/Down use absolute Y; Left/Right nudges X"},{label:"Redo Parity",desc:"Redo restores key points + interpolation, then recomputes curves"},{label:"Ink Guard",desc:"Blocks edits that exceed End when End is effectively locked"}]},"v1.9.0":{date:"2025-09-06",title:"Gaussian LAB, Overlay Alignment, Preserved Smart Shape",sections:{CHANGED:["LAB processing now uses Gaussian Weighted Correction (densityâ€‘independent); smoothing slider widens Gaussian influence radius","LAB â†’ Smart conversion preserves plotted shape using adaptive keyâ€‘point fit (defaults: 0.15% max error, 21 max points)","Keyâ€‘point overlay and adapter overlays now align exactly with Endâ€‘scaled curves (absolute plotting)"],FIXED:["Removed localized â€œbubbleâ€ artifacts when applying LAB to dense .quad curves","Preâ€‘conversion overlay markers now use interpolated Y (no nearestâ€‘index drift)"]},aboutDialog:[{label:"Gaussian LAB",desc:"Densityâ€‘independent LAB correction; smoother results on dense .quad curves"},{label:"Preserved Shape",desc:"LAB â†’ AI conversion fits points to the plotted curve"},{label:"Overlay Accuracy",desc:"Markers and labels align with Endâ€‘scaled curves"},{label:"Simplifier Defaults",desc:"Tighter default fit (0.15% / 21 points)"}]},"v1.8.6":{date:"2025-09-05",title:"LAB Wedgie Parity & Manual L* Simplification",sections:{ADDED:["LAB .txt import now uses wedgie-style inversion to a linear target (parity with Manual L*)","Documentation updated to reflect wedgie inversion for measurement data"],CHANGED:["Manual L* modal simplified: removed Target X%/L* and link; Measured-only table","Unified processing: Target X% = Measured X%; Target L* = 100â†’0"],FIXED:["Original measured points overlay and format labels consistent across LAB and Manual L*","Measurement intent marker applies to LAB formats regardless of suffix","ACV overlay: â€œShow key pointsâ€ displays original ACV anchor points (global and perâ€‘channel); no 32â€‘point fallback. ACV/LUT/LAB overlays take precedence over Smart key points.","ACV â†’ Smart editing: When first editing key points with a global ACV loaded, editable Smart points are seeded from the ACV anchors (not a simplified set) to avoid unexpected point shifts.","Overlay preference: When Smart key points exist for a channel, the overlay shows those Smart points; ACV/LUT/LAB overlays appear only when no Smart points are present.","No double processing: Global linearization is not applied to channels that have Smart Curves, preventing unintended changes when editing Smart points.","Exact Smart plotting: â€œShow key pointsâ€ draws Smart points directly from stored values (preâ€‘scale) for precise alignment."],REMOVED:["Gaussian LAB documentation references","Manual L* Target L* inputs and link toggle"]},aboutDialog:[{label:"Wedgie Parity",desc:"LAB .txt and Manual L* use the same inversion to a linear target"},{label:"Simplified Manual L*",desc:"Measured-only entry; target is implicit (linear 100â†’0)"},{label:"Docs Updated",desc:"Removed Gaussian references; clarified wedgie mapping"}]},"v1.8.5":{date:"2025-09-04",title:"Smart Keyâ€‘Point Deletion",sections:{ADDED:["Smart keyâ€‘point deletion: delete by index or nearest to input % (endpoints blocked by default)"]},aboutDialog:[{label:"Point Deletion",desc:"Delete key points by index or nearest input % (safe by default: endpoints blocked)"}]},"v1.8.4":{date:"2025-09-04",title:"Smart Keyâ€‘Point Labels and UI Polish",sections:{ADDED:["Numbered labels above Smart key points with inkâ€‘colored backgrounds and auto black/white text for readability","Lab Tech sample: added â€œapply a midtone liftâ€ example","Smart keyâ€‘point deletion: delete by index or nearest to input % (endpoints blocked by default)"],CHANGED:["Graph axis titles now use %: â€œInput Level %â€ (X), â€œOutput Ink Level %â€ (Y)","Keyâ€‘point label positioning refined: shifts slightly right near 0% and left near 100% to reduce overlap","Lab Tech sample updated to â€œgenerate a curve with points 0,0 25,20 75,85 100,100â€"],DOCS:["Updated CLAUDE.md and AGENTS.md to reflect numeric keyâ€‘point workflow and insert/adjust commands"]},aboutDialog:[{label:"Keyâ€‘Point Labels",desc:"Smart key points now show numbered labels with inkâ€‘colored backgrounds and readable text"},{label:"Axis Titles",desc:"Graph uses â€œInput Level %â€ (X) and â€œOutput Ink Level %â€ (Y)"},{label:"Lab Tech Samples",desc:"Focused natural language controls on curve generation"}]},"v1.8.3":{date:"2025-09-03",title:"Expanded Printer Support, OR/GR Inks, Ordered by Release",sections:{ADDED:["New printers: P400 (K,C,M,Y,LC,LM), x800-x890 (K,C,M,Y,LC,LM,LK,LLK), x900 (K,C,M,Y,LC,LM,LK,LLK,OR,GR), P4-6-8000 (K,C,M,Y,LC,LM,LK,LLK), P5-7-9000 (K,C,M,Y,LC,LM,LK,LLK,OR,GR)","Ink colors: OR (#FF7F00, Orange) and GR (#00A651, Green) supported in charts and swatches","Smart keyâ€‘point overlays: squares + ordinal labels for Smart Curves (<21 points)","Smart keyâ€‘point insert commands: insert point at X or between ordinals","Undo/redo now restores Smart key points and interpolation meta along with curves"],CHANGED:["Printer dropdown, Lab Tech enums, and validation lists reordered newestâ†’oldest based on Epson release eras","Supported printers list in .quad import error updated to include new models","Smart workflow: naturalâ€‘language preset curves deprecated; tool now computes numeric key points and applies them directly","Graph axis titles: display shows â€œInput Level %â€ (X) and â€œOutput Ink Level %â€ (Y)"],FIXED:["AI-generated curves now respect ink limit percentage; plots update on relative adjustments (e.g., â€œreduce by 20%â€)."],REMOVED:["Legacy 860-1160-VM model removed from UI and internal registry"]},aboutDialog:[{label:"More Printers",desc:"Added P400, x800-x890, x900, P4-6-8000, P5-7-9000"},{label:"OR/GR Inks",desc:"Added support for Orange and Green ink channels"},{label:"Smart Curve Scaling",desc:"Smart Curves now scale with ink limit changes (e.g., reduce by 20%)."},{label:"Defaults",desc:"Channels now default to 100%"}]},"v1.8.2":{date:"2025-09-03",title:"Unified Workflow Summary & Positive-only Cleanup",sections:{CHANGED:["About: Consolidated Recommended + Quick Workflow into a single beginner-friendly Workflow Summary","About: Removed the â€œ(Positiveâ€‘Only)â€ label and the PCHIP requirement bullet to simplify guidance"],DOCS:["Clarified Positive-only operation in UI text and helper messages; EDN LUT/.acv use Positive mapping (reverse + invert) by default","Removed user-facing references to toggling intent or mismatch warnings; older release notes retained for history"]},aboutDialog:[{label:"Workflow Summary",desc:"Step-by-step beginner overview replaces separate Recommended/Quick sections"},{label:"Simplified Wording",desc:"Cleaned up language and removed extra qualifiers for clarity"},{label:"Positive-only Operation",desc:"Tool operates in printer-space with Positive mapping; invert images in your editor for digital negatives"}]},"v1.8.1":{date:"2025-09-03",title:"MIT License + Chart Orientation Aids",sections:{ADDED:["MIT License for quadgen.html only: header comment added; About dialog blurb notes scope and holder","Chart orientation aids: Whiteâ†’black gradient bars added under X-axis (leftâ†’right) and beside Y-axis (bottomâ†’top)"],CHANGED:["Axis titles: X now â€œInput Level Percentâ€, Y now â€œOutput Ink Level Percentâ€","Axis label contrast: Force solid black text and adjust spacing to avoid overlap with gradients","EDN mapping fixed to Positive semantics (reverse + invert) with no intent toggle"],REMOVED:["Negative Print Intent UI and intent mismatch warning banner; tool now operates in Positive intent only"]},aboutDialog:[{label:"MIT License (HTML only)",desc:"Added MIT header in quadgen.html and brief notice in About; scope limited to this HTML file"},{label:"Axis Gradients",desc:"Added whiteâ†’black bars under X and along Y for clear white/black orientation"},{label:"Readable Labels",desc:"Labels forced to black with spacing tweaks for clarity"},{label:"Axis Titles",desc:"Renamed to â€œInput Level Percentâ€ (X) and â€œOutput Ink Level Percentâ€ (Y)"},{label:"Positive-only Intent",desc:"Removed Negative intent; EDN mapping uses Positive semantics by default"}]},"v1.8":{date:"2025-09-02",title:"Print Intent Mapping, ACV/LUT Parity, LAB Traceability",sections:{ADDED:["Print Intent selector (Positive/Negative) applied to EDN-style corrections; live recompute on toggle","LAB measurement intent traceability: UI shows â€œmeasured: Positive/Negativeâ€ and .quad comments include it","LAB intent mismatch warning banner when current intent differs from recorded LAB measurement intent"],FIXED:["ACV/LUT parity: ACV path now uses same orientation as LUT (horizontal flip + vertical inversion for positive-domain EDN)","Immediate graph update when toggling Print Intent with EDN corrections loaded","LAB endpoints anchored to 0 and 1 to preserve full dynamic range",'Natural-language curve parser: Tonal regions flipped to match 0% = white, 100% = black ("shadows" now 75â€“100%)'],REMOVED:["Built-in process presets (cyanotype, palladium, etc.) and process triggers from AI routing","Bookmarks/auto-citation experiment; the assistant no longer auto-injects sources"]},aboutDialog:[{label:"Print Intent Mapping",desc:"EDN (.cube/.acv) mapped by intent (Positive: flip+invert; Negative: flip only) with live recompute"},{label:"ACV/LUT Parity",desc:"ACV orientation normalized to match LUT; midtones now align closely"},{label:"LAB Traceability",desc:"Recorded â€œmeasured: Positive/Negativeâ€ and added mismatch warning banner"},{label:"LAB Endpoints Anchored",desc:"Measurement curves now start at 0% and end at 100% to preserve range"},{label:"Tonal Region Mapping",desc:'Parser regions flipped; 0% is white and 100% is black. "Lift shadows" now affects 75â€“100% correctly.'},{label:"Simplified AI Scope",desc:"Removed process presets; assistant provides guidance to load EDN/LAB instead"}]},"v1.7":{date:"2025-09-02",title:"Wedgie Inversion & LAB Data Artifacts Fix",sections:{FIXED:["LAB data curve artifacts: Replaced complex coordinate transformation with wedgie-style inversion to a linear target","Dense-on-dense data processing: Eliminated curve spikes when applying LAB corrections to loaded .quad files and AI-generated curves","Undo system gaps: Added proper state capture for all LAB data loading methods (sample data, file upload, pasted data)","Algorithm mismatch: Sparse measurement data (21 points) now properly applied to dense curve data (256 points)"],ENHANCED:["LAB processing algorithm: Wedgie-style inversion to linear target; optional smoothing available separately","Processing reliability: Eliminated need for ad-hoc smoothing by fixing the mapping at the source","Mathematical accuracy: Replaced experimental coordinate transformation with direct inversion to target"],REMOVED:["RBF experimental method: Removed Radial Basis Functions option after confirming no advantage over the simplified inversion","UI switching controls: Cleaned up method selection dropdown and event listeners for simplified interface"]},aboutDialog:[{label:"LAB Data Artifact Fix",desc:"Eliminated curve spikes when applying measurement data to loaded .quad files using wedgie-style inversion"},{label:"Unified Inversion",desc:"Manual L* and LAB .txt now use the same inversion to a linear target"},{label:"Dense Data Processing",desc:"Proper handling of sparse corrections (21 points) applied to dense curves (256 points)"},{label:"Undo System Completion",desc:"Added state capture for all LAB data loading methods ensuring proper undo functionality"},{label:"Algorithm Simplification",desc:"Removed RBF experimental option after simplification to wedgie-style inversion"}]},"v1.6":{date:"2025-08-31",title:"Lab Tech Assistant & Processing Visibility",sections:{ADDED:["Lab Tech AI assistant with 25 specialized functions for natural language control","Processing detail panels showing Base Curves â†’ Per-Channel â†’ Global pipeline per channel","Professional communication style with markdown formatting support","Quick reference documentation with function locations"],ENHANCED:['Smart Curve generation with natural language descriptions ("palladium curve", "S-curve")',"Undo system integration for AI-generated curves","Visual state restoration for disabled channels"],FIXED:["Disabled channel transparency when Lab Tech adds curves","Processing panel updates now immediate (no manual refresh needed)","Channel iteration bug causing incorrect references","Smart Curve undo functionality integration"]},aboutDialog:[{label:"Lab Tech Assistant",desc:"AI assistant with 25 specialized functions for natural language control of QuadGEN"},{label:"Processing Visibility",desc:"Expandable panels show Base Curves â†’ Per-Channel â†’ Global pipeline for each channel"},{label:"Professional Communication",desc:"Concise responses with markdown formatting and structured information"},{label:"AI Curve Integration",desc:"Natural language curve generation with full undo system integration"},{label:"Visual Improvements",desc:"Enhanced state restoration and immediate processing panel updates"}]},"v1.5":{date:"2025-08-29",title:"Adobe Photoshop .acv Curve File Support",sections:{ADDED:["Adobe Photoshop .acv file format support: Complete binary format parser for curve presets","Cubic spline interpolation: Smooth curve generation matching Photoshop's behavior between control points","ACV format detection: Automatic binary vs text file handling in parseLinearizationFile()","RGB composite curve extraction: Uses first curve from multi-curve .acv files for linearization","Binary data parsing: DataView-based parser supporting Adobe's int16 big-endian format specification","File input support: .acv files accepted in both global and per-channel linearization inputs","UI integration: Updated tooltips and file format descriptions to include .acv curve file support"],IMPROVED:["File format documentation: Comprehensive .acv technical specifications in internal documentation","Linearization workflow: Seamless integration with existing .cube and .txt file processing pipeline"]},aboutDialog:[{label:"ACV File Format",desc:"Complete binary format parser for Adobe Photoshop curve presets"},{label:"Cubic Spline Interpolation",desc:"Smooth curve generation matching Photoshop's behavior between control points"},{label:"RGB Composite Curves",desc:"Automatic extraction of first curve from multi-curve .acv files"},{label:"Binary Data Handling",desc:"DataView-based parser supporting Adobe's int16 big-endian format specification"},{label:"Seamless Integration",desc:".acv files work in both global and per-channel linearization workflows"},{label:"UI Updates",desc:"Updated tooltips and file format descriptions for .acv curve file support"}]},"v1.4.1":{date:"2025-08-29",title:"Smoothing Algorithm Refinements & .quad File Improvements",sections:{ADDED:["Smoothing Splines algorithm: Mathematical curve smoothing with automatic lambda parameter selection","Visual curve comparison: Original curve overlay (gray dashed line) shows smoothing effects on all channels","Simplified curve algorithms: Focused on Uniform Sampling and Smoothing Splines","Accurate .quad file maximum detection: Uses actual curve maximum instead of endpoint value"],REFINED:["Streamlined algorithm selection: Focused on reliable smoothing methods","Simplified interpolation options: Hidden Cubic Spline and Catmull-Rom from UI to reduce complexity","Default algorithm changed: Uniform Sampling now default with Smoothing Splines as advanced option","UI cleanup: Removed monotonicity preservation option (PCHIP handles this appropriately)"],IMPROVED:["Curve visualization: Original vs smoothed comparison works with multiple channels simultaneously","Algorithm focus: Concentrated on reliable, predictable smoothing methods for production use",".quad file scaling: Proper scaling based on actual maximum value for non-monotonic curves"]},aboutDialog:[{label:"Smoothing Splines",desc:"Added mathematical smoothing algorithm with automatic parameter selection"},{label:"Visual Curve Comparison",desc:"Original curve overlay shows before/after smoothing effects on all channels"},{label:"Accurate .quad File Handling",desc:"Proper detection and scaling of ink limits based on actual curve maximum"},{label:"Non-Monotonic Curve Support",desc:"Correctly handles curves where peak ink density occurs before 100% input"},{label:"Streamlined Algorithm Selection",desc:"Focused on Uniform Sampling and Smoothing Splines for reliable results"},{label:"Improved Interpolation Defaults",desc:"PCHIP monotonic interpolation as primary method with Linear fallback"}]}};function p1(e,t){let n="";for(const[r,i]of Object.entries(e)){if(r==="Unreleased")continue;const a=t?`${t} ${r}`:r;n+=`
      <div class="mb-3">
        <p class="font-bold">${a}</p>
        <ul class="list-none ml-2 mt-1 text-sm leading-tight">`;for(const o of i.aboutDialog)n+=`
          <li>- ${o.desc}</li>`;n+=`
        </ul>
      </div>`}return n}function f1(){return`
    <section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">
      <div style="display: flex; justify-content: center;">
        <div style="font-size: 10px; font-family: ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace; white-space: normal; line-height: 1.2; text-align: left; width: 100%;">MIT License

Copyright (c) 2025 David Marsh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Scope: This license applies to this HTML file (quadgen.html) only.</div>
      </div>

      <hr />

      <h2 id="overview">Overview</h2>
      <p>
        <strong>quadGEN</strong> is a free, browser-based tool for generating and refining <code>.quad</code> files used with QuadToneRIP.  
        It supports LAB/LUT/ACV inputs, and an Edit Mode for precise, point-based curve edits.  
        Core features work fully offline; the optional AI assistant requires network access.
      </p>
      <p>
        quadGEN is designed for photographers, printmakers, and alt-process practitioners who create digital negatives or monochrome prints and need reliable tonal calibration.
      </p>

      <h3>Project Resources</h3>
      <ul>
        <li><strong>Source code:</strong> <a href="https://github.com/David-Marsh-Photo/quadGEN" target="_blank" rel="noopener">github.com/David-Marsh-Photo/quadGEN</a></li>
        <li><strong>Issues & contributions:</strong> Open a GitHub issue or pull request on the repository linked above.</li>
        <li><strong>Support:</strong> Email <a href="mailto:marshmonkey@gmail.com">marshmonkey@gmail.com</a></li>
      </ul>

      <h3>What is QuadToneRIP?</h3>
      <p>
        QuadToneRIP (QTR) is a specialized RIP/driver for Epson printers focused on high-quality monochrome printing using multi-shade ink sets.  
        QTR uses <code>.quad</code> files to determine how much ink each printer channel lays down at every input level.  
        A <code>.quad</code> file contains 256-sample curves (0â€“100% input) for each channel supported by the printer (e.g., K, C, M, Y, LC, LM, LK, LLK, OR, GR, etc.).  
        When you select a <code>.quad</code> in your QTR workflow (often via Print-Tool on macOS), QTR reads these curves and applies the specified per-channel ink outputs to render your print.  
        quadGENâ€™s role is to help you build and refine those <code>.quad</code> curves so QTR can produce linear, predictable output.  
        See the <a href="https://www.quadtonerip.com/html/QTRoverview.html" target="_blank" rel="noopener">QuadToneRIP Overview</a> for more background.
      </p>

      <hr />

      <h2 id="install">Installation and Access</h2>
      <ul>
        <li><strong>Online:</strong> visit <a href="https://quadgen.ink/" target="_blank" rel="noopener">https://quadgen.ink/</a>.</li>
        <li><strong>Offline:</strong> rightâ€‘click and download this file: <a href="https://quadgen.ink/index.html" target="_blank" rel="noopener">https://quadgen.ink/index.html</a>, then open it locally (no install required).</li>
        <li><strong>Platforms:</strong> macOS, Windows, Linux (desktop recommended).</li>
        <li><strong>Network note:</strong> AI assistant features require internet; manual editing and exports do not.</li>
      </ul>

      <hr />

      <h2 id="quickstart">Quick Start (Beta 3.1.5)</h2>
      <ol>
        <li><strong>Pick a printer layout</strong> and set conservative End limits (and any known density constants) before exporting anything.</li>
        <li><strong>Export a baseline linear ramp</strong> and stash it as your â€œv0â€ reference in QuadToneRIPâ€™s <code>quad</code> folder.</li>
        <li><strong>Print a step wedge</strong> through QTR/Print-Tool with that baseline curveâ€”disable color management entirely.</li>
        <li><strong>Measure the wedge</strong>, save the LAB <code>.txt</code> (0â€“100% GRAY, L* in range), and archive it under <code>data/</code>.</li>
        <li><strong>Load the measurement in quadGEN</strong>, confirm the normalization mode (perceptual L* by default; enable log-density for through-light workflows).</li>
        <li><strong>Review the global correction</strong> (chart, smoothing slider, auto-raise toasts, correction gain). Apply contrast intents only when required.</li>
        <li><strong>Optional Edit Mode touch-up</strong>: Recompute Smart key points from the plotted curve and adjust as needed; quadGEN auto-raises Ends when allowed.</li>
        <li><strong>Export the corrected <code>.quad</code></strong>, install it in QTR, reprint, remeasure, and iterate until tone stays linear.</li>
      </ol>

      <hr />

      <h2 id="features">Features (highlights)</h2>
      <ul>
        <li>Supports most Epson printers.</li>
        <li>Quickly export linear ramps with any single ink channel or combination.</li>
        <li>Channel table includes a <strong>Density</strong> column with studio presets (K/MK = 1.00, C = 0.21, LK = 0.054). Enter a value to lock a channel; leave it blank or set to <code>0</code> and quadGEN will regenerate that density automatically on the next LAB solve.</li>
        <li>Per-channel ink locks prevent accidental ink limit changes and clamp Smart curve edits to the stored limit until unlocked.</li>
        <li>Inputs: <code>.quad</code>, LAB <code>.txt</code>, LUT <code>.cube</code>, <code>.acv</code>, Manual L*.</li>
        <li>Apply intent remaps directly to a loaded <code>.quad</code> via â€œApply to Loaded Curveâ€.</li>
        <li>âš™ï¸ Options panel centralizes app-wide preferences (e.g., log-density normalization) without cluttering workflow panels.</li>
        <li>Correction overlay toggle draws a dashed red global target plus the purple linear baseline for identity checks. The light-blocking overlay shows a solid purple curve (with dashed reference when a comparison <code>.quad</code> is loaded), and the cumulative ink-load overlay sums every enabled channel with dashed/solid segments that flip to red once totals clear your warning threshold.</li>
        <li>Measurement spot markers (âš™ï¸ Options) line badges along a 70â€¯% rail anchored to the unzoomed chart, showing green checks for LAB readings within Â±1â€¯% and colored arrows (red up for darken, blue down for lighten) with faint dots at the measured Y positionâ€”even after zooming. Hover any badge to see the exact delta.</li>
        <li>Bell-classified channels display a <strong>Bell Apex Shift</strong> card inside the Edit Curve panel (only when Edit Mode is on) with Â± buttons (Shift-click for larger hops) and a numeric field so you can re-center highlight-heavy curvesâ€”Smart point ordinals stay put while their X positions drift.</li>
        <li>A companion <strong>Bell Width Scale</strong> card sits right beneath Bell Apex with left/right percent inputs, Â±2â€¯% nudges (Shift=Â±5â€¯%), a Reset button, and a â›“ link toggle so you can widen/tighten either slope without moving the apex or reseeding Smart points; metadata lives in <code>getChannelShapeMeta().bellWidthScale</code>.</li>
                <li>Correction gain slider (ðŸŒ Global Correction) blends the identity curve with the measured correction (0â€“100â€¯%); scrubbing pauses for ~150â€¯ms to stay smooth, then the chart, spot markers, previews, and exported curves all refresh with the selected mix.</li>
        <li>Evenly spaced or irregular targets supported.</li>
        <li>Edit Mode: point-based edits at any time.</li>
        <li>Undo/Redo: full history of edits, LAB/LUT loads, global scaling, and per-channel slider changes.</li>
        <li>Recompute key points: simplify Smart Curves with tolerance/max-point controls.</li>
        <li>Graph zoom: use the +/âˆ’ control in the chart corner to rescale the Y-axis in 10% steps when working with low ink limits; when a channel peaks at 100% the chart keeps one highlight-inspection step and flattens anything above the displayed max while noting the clamp.</li>
        <li>Lab Tech: AI assistant for Q&amp;A and automation.</li>
        <li>Contrast intent: presets or custom targets; shows Î” vs target; endpoints fixed (use ink limits to change).</li>
        <li>Auto endpoint rolloff: optional white/black soft knees that detect early plateau and ease into the ink limit with a smooth shoulder/toe (3% proximity threshold).</li>
        <li>Import ACV/LUT as target: in the Custom Intent modal, load <code>.acv</code>/<code>.cube</code> as a target intent (not a correction); includes endpoint anchoring, monotonic enforcement, and blend.</li>
      </ul>

      <hr />

      <h2 id="examples">Usage Examples</h2>
      <ul>
        <li>Digital negatives: cyanotype, Pt/Pd, kallitype, polymer photogravure.</li>
        <li>Inkjet linearization: refine monochrome response for QTR printing.</li>
        <li>Curve editing: enter Edit Mode, nudge an ordinal, export.</li>
        <li>Conversion: load LAB/LUT/ACV and export <code>.quad</code>.</li>
        <li>Intent remap: load your reference linearized <code>.quad</code>, audition Gamma/Filmic presets, and bake a contrast variant directly.</li>
      </ul>

      <hr />

      <h2 id="best">Best Practices</h2>
      <p class="text-sm text-gray-600 mb-3">Linearize your process once, keep that <code>.quad</code> as a reference, and branch from there. You can either bake an intent into the loaded reference with â€œApply Intentâ€, or leave the reference untouched and make the contrast move upstream in Photoshopâ€”printing through the linear reference yields the same result.</p>
      <ul>
        <li>If your process requires a negative, invert it before printing with your <code>.quad</code>.</li>
        <li>Measure the final positive print (not the negative).</li>
        <li>Anchor endpoints and keep curves monotonic.</li>
        <li>Use ink limits to define deepest black (or cleanest white).</li>
        <li>Make incremental edits; use Undo/Redo liberally.</li>
        <li>Keep a â€œreferenceâ€ Linear intent <code>.quad</code>. You can bake contrast variants with â€œApply Intentâ€, or do the contrast move in Photoshop and print through the same linear referenceâ€”both paths land on the same tone curve.</li>
        <li>Zoom the chart so low-limit runs fill the plotâ€”tap +/âˆ’ in the lower-left to move in 10% steps, and the chart auto-expands again if you enable a higher ink limit later.</li>
      </ul>

      <hr />

      <h2 id="faq">Troubleshooting &amp; FAQ</h2>
      <ul>
        <li><strong>Offline use:</strong> Lab Tech is unavailable offline; manual functions work fully.</li>
        <li><strong>Curve orientation:</strong> quadGEN plots input % (X) vs ink output % (Y), origin = white. Other tools may use tone curves with origin = black.</li>
        <li><strong>ACV parsing:</strong> Photoshop <code>.acv</code> files now load directly from the file picker. The old <code>TypeError: t.includes is not a function</code> error is resolvedâ€”no manual text conversion is required.</li>
        <li><strong>Corrections:</strong> Upward curve = more ink (darker); downward = less ink (lighter). Example: raise mids if midtones are too light.</li>
        <li><strong>Full reset:</strong> Use your browserâ€™s refresh/reload button to return quadGEN to a clean state.</li>
      </ul>

      <hr />

      <h2 id="feedback">Feedback / Contact</h2>
        <p>Source code & issue tracker: <a href="https://github.com/David-Marsh-Photo/quadGEN" target="_blank" rel="noopener">github.com/David-Marsh-Photo/quadGEN</a></p>
        <p>Email: <a href="mailto:marshmonkey@gmail.com">marshmonkey@gmail.com</a></p>

      <hr />

      <h2 id="credits">Credits / Attribution</h2>
      <ul>
        <li>Tailwind CSS â€” used via CDN (<code>cdn.tailwindcss.com</code>), MIT License.</li>
        <li>Cloudflare Workers â€” used as an API proxy (rate-limited edge function).</li>
        <li>Anthropic Claude</li>
        <li>OpenAI ChatGPT / Codex</li>
        <li>Prints on Paper Studio â€” contrast intent definitions and feature references used with permission under <a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank" rel="noopener">GNU Public License</a>.</li>
        <li>Easy Digital Negatives (EDN) â€” Copyright Peter Mrhar. EDN is a separate project for building correction LUTs for digital negatives.</li>
        <li>Trademarks: Epson and SureColor are trademarks of Seiko Epson Corporation. QuadToneRIP and Printâ€‘Tool are property of Roy Harrington. Color Muse is a trademark of Variable, Inc. Nix Spectro L is a trademark of Nix Sensor Ltd. All product names, logos, and brands are property of their respective owners.</li>
      </ul>

      <h3>Special Thanks</h3>
      <ul>
        <li>Walker Blackwell</li>
        <li>Marek WesoÅ‚owski</li>
        <li>Clay Harmon</li>
      </ul>


      <hr />        

      <h2 id="refs">External References</h2>
      <ul>
        <li><a href="http://www.easydigitalnegatives.com/" target="_blank" rel="noopener">Easy Digital Negatives</a> â€“ Export correction LUTs (<code>.cube</code>) and load into quadGEN.</li>
        <li><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">QuadToneRIP</a> â€“ RIP software using <code>.quad</code> files. Install/export from quadGEN to QTRâ€™s quad folder.</li>
        <li><a href="https://www.quadtonerip.com/html/QTRprinttool.html" target="_blank" rel="noopener">Print-Tool</a> â€“ Utility for printing through QTR on macOS with color-management off.</li>
        <li><a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a> â€“ Handheld colorimeter for LAB measurement. Exports <code>.txt</code> for import into quadGEN.</li>
        <li><a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Nix Spectro L</a> â€“ Portable spectrophotometer with deeper shadow sensitivity; exports LAB data compatible with quadGEN.</li>
        <li><a href="https://clayharmonblog.com/downloads/25-step-ColorMuse-target.zip" target="_blank" rel="noopener">Clay Harmonâ€™s 21-step target</a> â€“ Printable target for iterative calibration.</li>
      </ul>
    </section>
  `}function m1(){return`
    <section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">
      <h2>quadGEN Glossary</h2>
      <p>A concise, alphabetized reference to key terms used in quadGEN, QuadToneRIP, and related workflows.</p>
      <dl>
        <dt>Auto black limit</dt>
        <dd>Temporarily disabled while the rolloff detector is re-tuned. Previously applied a localized soft toe at the black end to preserve shadow separation.</dd>

        <dt>Auto white limit</dt>
        <dd>Temporarily disabled while the rolloff detector is re-tuned. Previously applied a localized soft shoulder at the white end to preserve highlight separation.</dd>

        <dt>Baked</dt>
        <dd>Indicates that a correction (global LUT, LAB table, or Smart curve) has been permanently folded into the current baseline curve. Baked data no longer re-applies on redraw; it updates ink-limit fields, exports, and history so further edits start from the corrected curve.</dd>

        <dt>Bell apex</dt>
        <dd>The peak-input percentage of a bell-shaped channel (start low â†’ mid-curve rise â†’ low). quadGEN detects it per channel, displays it in the Edit Curve Bell Apex card, and exposes it via <code>getChannelShapeMeta()</code>.</dd>

        <dt>Bell Apex Shift</dt>
        <dd>An Edit Curve panel control that appears only when Edit Mode is on and the selected channel classifies as bell. It shows the apex input % plus Â± buttons / numeric entry so you can nudge the bell left or right without rebuilding Smart points. Shift-click the buttons for larger hops; undo/redo captures every move, and existing Smart point ordinals stay in place while their X positions slide.</dd>

        <dt>Bell curve (ink channel)</dt>
        <dd>A channel profile that starts near 0â€¯%, rises to a mid-curve apex, then tapers back toward 0â€¯%. quadGEN highlights these highlight-heavy channels with a ðŸ”” badge in the channel table and exposes the detection via <code>window.getChannelShapeMeta()</code>.</dd>

        <dt>Bell Width Scale</dt>
        <dd>The Edit Curve panel card that widens or tightens the left and/or right slopes of a bell-classified channel without moving its apex. It exposes left/right percent inputs, Â± nudges (Shift for Â±5â€¯%), a Reset button, and a link toggle so you can keep both sides tied together or adjust them independently; metadata lives under <code>getChannelShapeMeta().bellWidthScale</code>.</dd>

        <dt>ACV (Photoshop Curves)</dt>
        <dd>Binary curve format used by Adobe Photoshop (<code>.acv</code>). In quadGEN: can be loaded as a global correction or per-channel adapter; anchors can seed editable Smart curve.</dd>

        <dt>Alternative process (Alt-process)</dt>
        <dd>Historic or non-traditional photographic printing methods such as platinum/palladium, cyanotype, kallitype, polymer photogravure, and gum bichromate. These processes often use digital negatives created through QuadToneRIP workflows, requiring precise tonal calibration that quadGEN provides.</dd>

        <dt>CGATS.17</dt>
        <dd>Industry-standard color measurement data format developed by Committee for Graphic Arts Technology Standards. Used by professional spectrophotometers and colorimeters (X-Rite i1Pro, DataColor SpyderPrint, etc.) to exchange measurement data. quadGEN extracts monochrome progressions (K-only or composite grayscale) from CGATS files for LAB linearization workflows.</dd>

        <dt>Channel</dt>
        <dd>A printer ink channel (e.g., K, C, M, Y, LC, LM, LK, LLK, OR, GR, MK, V). Channels can be enabled/disabled and have independent End (ink limits).</dd>

                    <dt>Colorimeter</dt>
        <dd>Handheld device that measures color using filtered RGB sensors to approximate human vision. Fast and affordable for step wedges and general calibration. Example: <a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a>.</dd>

<dt>Color Muse 2</dt>
        <dd><a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Handheld colorimeter</a> for measuring LAB values from printed wedges/targets. Exports <code>.txt</code> files compatible with quadGEN.</dd>

        <dt>Correction (curve)</dt>
        <dd>Mapping that adjusts output ink levels versus input to achieve a target response. In quadGEN, plotted as Y (output ink %) vs X (input %).</dd>

        <dt>Correction overlay</dt>
        <dd>Dashed global reference plotted on the chart, sampled from the active correction dataset, with a purple dashed linear baseline for identity comparison. Loading a secondary reference <code>.quad</code> remains on the roadmap; until that lands, the light-blocking overlay is the only one missing its reference trace. Enable the overlay from the Options panel toggleâ€”no debug helpers required.</dd>

        <dt>Ink load overlay</dt>
        <dd>Summed ink-percentage trace across every enabled channel. Enable it from âš™ï¸ Options â†’ â€œShow cumulative ink load overlayâ€ to plot totals over the full chart height; dashed gray segments sit below the warning threshold, solid red segments flag overshoot, and tooltips report the live total with a âš ï¸ marker whenever the threshold is exceeded.</dd>

        <dt>Measurement spot markers</dt>
        <dd>Optional overlay that plots each LAB measurement on the chart. Patches within Â±1â€¯% tolerance show a green check badge; out-of-tolerance points show an arrow (up = darken, down = lighten) labelled with the percent delta. Hover a badge to see the input %, measured L*, and recommended action.</dd>

        <dt>Light-blocking overlay</dt>
        <dd>Solid purple curve that estimates cumulative optical density across the active channels. Load a reference <code>.quad</code> file to display a dashed comparison curve alongside the current light-blocking overlay. Toggle it from âš™ï¸ Options â†’ "Show light blocking overlay."</dd>

        <dt>Ink load overlay</dt>
        <dd>Plots the summed output percentage across all enabled channels so you can spot inputs where total coverage breaches your warning threshold. Toggle it via âš™ï¸ Options â†’ "Show cumulative ink load overlay" and adjust the threshold field beneath the toggle; dashed gray segments sit under the limit while solid red segments highlight overshoots.</dd>

        <dt>Density</dt>
        <dd>Measure of how much light a material absorbs or blocks. In quadGEN we treat each density value as the normalized L* coverage ceiling an ink can provide; once a channelâ€™s cumulative darkening reaches that ceiling (with a 0.5% buffer for measurement noise), the solver hands the remaining correction to higher-density inks. Enable the log-density toggle when you want corrections based on optical density (digital negatives, contact printing); leave it off to stay in L* for perceptual printer linearization. The channel tableâ€™s Density column lets you lock these ceilings (e.g., K/MK = 1.00, C = 0.21, LK = 0.054); leaving a field blank or zero prompts the solver to regenerate the value automatically. A coverage badge now sits beneath the Density input to show â€œused / limitâ€ and lights amber with a tooltip listing any clamped samples when the ceiling is hit.</dd>

        <dt>Density ladder</dt>
        <dd>Composite redistribution order (light inks â†’ dark inks) used by Normalized weighting. LK carries the highlight correction until it hits its buffered ceiling (â‰ˆ1% headroom tolerance), then the solver hands the remaining delta to C, and only after C tops out does K contribute.</dd>

        <dt>Digital Negative</dt>
        <dd>A digitally created film negative used for alternative photographic processes like platinum/palladium printing, cyanotype, and silver gelatin contact printing. Created by inverting a positive digital image and printing it on transparent film with precise density control.</dd>

        <dt>EDN (Easy Digital Negatives)</dt>
        <dd><a href="http://www.easydigitalnegatives.com/" target="_blank" rel="noopener">Workflow</a> created by Peter Mrhar to build correction LUTs for digital negatives. Export <code>.cube</code> LUTs from EDN for use as global/per-channel corrections in quadGEN.</dd>

        <dt>Edit Mode</dt>
        <dd>Gated state that enables key-point editing and shows overlays. Selected channel draws on top; unselected enabled channels dim.</dd>

        <dt>End (ink limit)</dt>
        <dd>Per-channel maximum ink level. Edits that require more ink can raise End when feasible; when End is effectively locked, edits that exceed it are blocked with status.</dd>

        <dt>Epson Media Installer</dt>
        <dd>Epson utility that downloads and installs ICC profiles and media settings for specific paper types on Epson printers. Provides paper thickness settings and media handling parameters needed for optimal print quality with third-party papers.</dd>

        <dt>Gaussian Weighted Correction</dt>
        <dd>LAB processing method that spreads each measurement's influence smoothly across inputs; reduces artifacts versus naive inversion techniques.</dd>

        <dt>Gamma value</dt>
        <dd>Numerical parameter that controls the shape of a power-law tone curve. In quadGEN's contrast intent presets: gamma < 1.0 (e.g., 0.85) lowers contrast by brightening shadows; gamma > 1.0 (e.g., 1.2, 1.6, 2.2) increases contrast by darkening shadows. Gamma = 1.0 produces a linear curve with no tonal adjustment.</dd>

        <dt>Global correction</dt>
        <dd>A correction that applies uniformly to all channels (e.g., LAB/LUT/ACV loaded as global data or computed from measurements).</dd>

        <dt>Global scale</dt>
        <dd>The batch control that multiplies every channelâ€™s End value by the requested percent. quadGEN records a single undo action for global scaling, so one Undo reverts all affected channels together.</dd>

        <dt>Graph orientation</dt>
        <dd>quadGEN plots printer-space ink mapping with 0% = white (no ink) at the origin. Photoshop/other "tone" tools often use 0,0 = black.</dd>

        <dt>Image space</dt>
        <dd>Coordinate system where 0 represents black (shadow) and 100 represents white (highlight), matching how images are typically viewed and edited. Point (0,0) = black input produces black pixel output; point (100,100) = white input produces white pixel output. ACV files, LUTs, and most user input use image space conventions. quadGEN automatically converts image space data to printer space for internal processing and display.</dd>

        <dt>Ink set</dt>
        <dd>Collection of inks available in a printer, such as the standard CMYK inks or expanded sets like K, C, M, Y, LC, LM, LK, LLK for monochrome work. QuadToneRIP supports multi-shade ink sets that use multiple densities of the same color (e.g., Light Black, Light Light Black) for smoother tonal gradations.</dd>

        <dt>Input Level %</dt>
        <dd>X-axis value representing the input level (0â€“100%) in printer space; corresponds to the source tone step being mapped.</dd>

        <dt>Intent (Contrast Intent)</dt>
        <dd>A target tonal mapping the correction aims to match. Choose a preset (Linear, Soft/Hard gamma, Filmic, etc...) or define a custom target via sliders or pasted CSV/JSON. Intents affect Î” vs target and exported filename/comments (compact tag), but do not change measurement ingestion; endpoints (0% and 100%) remain fixed. To alter black/white points, adjust ink limits/end values.</dd>

        <dt>Interpolation</dt>
        <dd>Method to form a smooth curve between key points. quadGEN favors monotonic PCHIP for predictable, non-overshooting results.</dd>

        <dt>Endpoint rolloff (shoulder/toe)</dt>
        <dd>A smooth, monotone easing near the ends of the curve (white shoulder, black toe) that prevents a hard plateau and maintains step separation at the last few percent.</dd>

        <dt>Key point</dt>
        <dd>An editable control point of a Smart Curve. Identified by ordinal (1-based). Insert/adjust/delete supported; endpoints often guarded. Coordinates are defined in printer space with the origin at (0,0), where X = input % (0â€“100) and Y = output ink % (0â€“100).</dd>

        <dt>L* (L-star)</dt>
        <dd>Lightness component of the LAB color space, ranging from 0 (pure black) to 100 (pure white). quadGEN can linearize directly in L* (default) for perceptual prints, or convert to optical density when the log-density toggle is enabled.</dd>

        <dt>LAB data (<code>.txt</code>)</dt>
        <dd>Text file with measured L*, A*, B* (quadGEN expects GRAY and LAB columns). Used to compute or validate corrections.</dd>

        <dt>LUT (Look-Up Table)</dt>
        <dd>Data structure that maps input values to output values, used for color and tone transformations. quadGEN supports 1D and 3D <code>.cube</code> LUT files from tools like Easy Digital Negatives (EDN) and can extract neutral-axis corrections for linearization.</dd>

        <dt>Lab Tech</dt>
        <dd>The built-in assistant in quadGEN that can answer questions and perform actions (when networked). Optional; core editing/export features work offline.</dd>

        <dt>Log-density linearization</dt>
        <dd>Optional normalization mode that converts measured L* to optical density (âˆ’log<sub>10</sub>(Y)) before building the correction curve. Recommended for digital negatives and other through-light workflows where equal density steps translate to equal exposure. Enable it from the Options panelâ€™s â€œUse log-density for LAB / Manual measurementsâ€ toggle (also available inside the Manual L* modal).</dd>

        <dt>Linearization</dt>
        <dd>Process of adjusting printer output so that equal input steps (e.g., 0â€“100%) produce consistent tonal changes. quadGEN supports two normalizations: perceptual L* (default for direct prints) and log-density (optical) for through-light workflows. Both ingest measured L*, compare to the target curve, and generate a correction LUT that enforces a near-linear relationship between input values and visual tone.</dd>

        <dt>Linear ramp</dt>
        <dd>Identity mapping (input % = output %) used as a neutral baseline for tests/export and certain workflows.</dd>

        <dt>Max error %</dt>
        <dd>Used for Smart curve Key point calculation. The largest deviation allowed from data file before a new Key point will be generated. Lower this number to create a tight fitting curve with more Key points. Raise this number to create a smoother curve with fewer Key points.</dd>

        <dt>Max Points</dt>
        <dd>The upper limit on the number of Smart key points that quadGEN will generate when creating a Smart curve. Above this threshold, imported data (e.g., ACV/LUT/LAB) is simplified or interpolated to maintain performance and stability. Maximum is 25 points.</dd>

        <dt>Monotonic</dt>
        <dd>Property of a curve where values either never decrease (monotonic increasing) or never increase (monotonic decreasing) as you move along the X-axis. quadGEN enforces monotonic curves to ensure predictable printer behaviorâ€”no ink output reversals that could cause banding or unstable prints.</dd>

        <dt>Options panel</dt>
        <dd>The âš™ï¸ Options modal opened from the toolbar beside Help. Centralizes quadGEN-wide preferencesâ€”including the log-density normalization toggleâ€”so feature panels stay focused on their workflows.</dd>

        <dt>Reference curve</dt>
        <dd>A fully linearized <code>.quad</code> kept as the authoritative baseline for a printer/process. Branch contrast variants from this reference (Apply Intent or upstream edits) while preserving the trusted linear response.</dd>

        <dt>Open bite</dt>
        <dd>Unwanted etching or surface marking in intaglio printmaking, such as polymer photogravure, caused by insufficient plate hardening. It occurs when too much exposure light is blocked, preventing the formation of proper ink-holding recesses. Often linked to ink limits set too high, requiring careful calibration to avoid.</dd>

        <dt>Output Ink Level %</dt>
        <dd>Y-axis value representing the ink output (0â€“100%) after applying the curve and current End; higher values mean more ink (darker).</dd>

        <dt>Paper white</dt>
        <dd>The lightest tone that a specific paper can produceâ€”essentially the color and brightness of the unprinted paper surface. In quadGEN workflows, paper white serves as the reference point for determining minimum ink limits and calibrating highlight reproduction.</dd>

        <dt>Patch</dt>
        <dd>Individual tonal step within a step wedge or calibration target. Each patch represents a specific input percentage (e.g., 0%, 10%, 20%) and is measured separately to build the correction curve. A typical 21-step target contains 21 patches at 5% intervals.</dd>

        <dt>Printer space</dt>
        <dd>Coordinate system where 0 represents white (no ink) and 100 represents maximum ink (black), matching how printers actually operate. Point (0,0) = white input produces no ink output (white); point (100,100) = black input produces maximum ink output (black). This is quadGEN's native coordinate system for all internal processing, curve display, and .quad file generation. Input data from image space sources (ACV, LUT, custom intents) is automatically transformed to printer space.</dd>

        <dt>Snapshot pair</dt>
        <dd>Undo entry created from a â€œBefore:â€/â€œAfter:â€ capture. quadGEN automatically rewinds to the matching â€œBefore:â€ snapshot, then stores both states together so redo replays the pair in the correct order.</dd>

        <dt>Simple Scaling correction</dt>
        <dd>Primary correction path that scales channel curves from the measured vs target ratios, redistributing overflow based on density reserves. Each pass clamps auto-lifts to +15â€¯% per channel, keeps K/MK from auto-raising, and backfills any excess into darker reserves so highlights donâ€™t double in one shot. The density solver is automatically integrated when multi-ink redistribution is required.</dd>

        <dt>Smart curve</dt>
        <dd>Adaptive curve model in quadGEN defined by editable key points and monotonic interpolation. Smart curves allow precise local edits while preserving smoothness and avoiding overshoot, enabling efficient linearization and correction workflows.</dd>

        <dt>Step wedge</dt>
        <dd>Test pattern with evenly spaced tonal steps from white to black, printed to measure printer response. Typically contains 10-25 patches at regular intervals (e.g., 0%, 10%, 20%...100%). After printing through QuadToneRIP, the wedge is measured with a colorimeter or spectrophotometer to generate LAB data for linearization in quadGEN. Often used interchangeably with "target."</dd>

        <dt>Target (21/25-step etc)</dt>
        <dd>Printable step-wedge target used for iterative calibration. Measure the print (e.g., with Color Muse 2 or Nix Spectro L), import LAB <code>.txt</code>, refine, and reprint. Often used interchangeably with "step wedge."</dd>

        <dt>Tone curve</dt>
        <dd>Graph showing the relationship between input tonal values and output tonal values, controlling how light and dark areas are reproduced. In quadGEN, tone curves are displayed in printer space (X = input %, Y = output ink %) and can be linear (no change) or shaped for specific contrast intents.</dd>
                    <dt>Spectrophotometer</dt>
        <dd>Measures full spectral reflectance for precise LAB calculations and deep-shadow accuracy. Ideal for alternative processes and professional calibration. Example: <a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Nix Spectro L</a>.</dd>

<dt>Nix Spectro L</dt>
        <dd>Compact spectrophotometer capable of low-L* readings. Capture LAB data with the Nix app and import the <code>.txt</code> file into quadGEN. Ideal for alternative and darkroom processes. <a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Product link</a>.</dd>

                    <dt>P900</dt>
        <dd>Epson SureColor P900 17-inch photo printer (K,C,M,Y,LC,LM,LK,LLK,V,MK) often used for monochrome workflows with QuadToneRIP. <a href="https://amzn.to/42yGCQD" target="_blank" rel="noopener">Product link</a>.</dd>

        <dt>PCHIP</dt>
        <dd>Piecewise Cubic Hermite Interpolating Polynomialâ€”a mathematical method for creating smooth curves between data points. Unlike other interpolation methods, PCHIP prevents overshooting and maintains monotonic behavior, making it ideal for photographic tone curves where predictable, artifact-free results are essential.</dd>

<dt>PoPS (Prints on Paper Studio)</dt>
        <dd><a href="https://printsonpaper.studio/" target="_blank" rel="noopener">Collaborative printmaking studio</a> specializing in photogravure and digital pigment printing, offering artists a welcoming environment to create and edition fine art prints using innovative techniques. PoPS has developed contrast intent presets included in quadGEN for alternative photographic processes. Note: quadGEN is not affiliated with or part of Prints on Paper Studio.</dd>

        <dt>Print Tool</dt>
        <dd><a href="https://www.quadtonerip.com/html/QTRprinttool.html" target="_blank" rel="noopener">Utility application</a> for macOS that enables color-managed printing from TIFF files while bypassing standard print driver limitations. Commonly used with QuadToneRIP workflows for printing digital negatives and monochrome images.</dd>

        <dt>QuadToneRIP (QTR)</dt>
        <dd><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">Specialized RIP/driver</a> for Epson printers designed for high-quality monochrome printing with multi-shade ink sets. QTR uses <code>.quad</code> files to control how much ink each channel lays down across the 0â€“100% input range, enabling precise tonal calibration and alternative process workflows such as digital negatives.</dd>

        <dt>RIP</dt>
        <dd>Raster Image Processorâ€”software that converts digital images into printer-specific instructions, controlling how ink is laid down on paper. RIPs like QuadToneRIP provide precise control over individual ink channels and support specialized workflows beyond standard printer drivers.</dd>

        <dt>Revert (to measurement)</dt>
        <dd>Buttons that return curves to the loaded measurement source for iteration. <strong>Perâ€‘channel Revert</strong> clears Smart curves/points and reâ€‘enables that channelâ€™s measurement (enabled only when measurement data is loaded for that channel). <strong>Global Revert</strong> clears Smart curves/points across all channels and reâ€‘enables the global measurement (enabled only when a global file is loaded and the global toggle is ON). Both actions are undoable.</dd>

        <dt>Recompute</dt>
        <dd>Button in Edit Mode that regenerates Smart curve key points for the selected channel from the currently plotted curve using the configured <em>Max error %</em> and <em>Max Points</em> settingsâ€”useful for simplifying or refreshing an editable set from a loaded <code>.quad</code>.</dd>
      </dl>
    </section>
  `}function h1(e=d1,t=wb){const n=new Date().getFullYear(),r=p1(e,t);return`<section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">${`
    <div class="space-y-4">
      <div class="text-xs text-gray-500">MIT License â€” quadgen.html Â© ${n} David Marsh. HTML file only. Full text is in the page source.</div>
      <div>
        <h3 class="text-base font-semibold mb-2">Version History</h3>
        ${r}
      </div>
      <div>
        <h3 class="text-base font-semibold mb-2">Source & Contributions</h3>
        <p>
          The latest source, issue tracker, and contribution guidelines live at
          <a href="https://github.com/David-Marsh-Photo/quadGEN" target="_blank" rel="noopener">github.com/David-Marsh-Photo/quadGEN</a>.
        </p>
      </div>
    </div>
  `}</section>`}function g1(){return`
    <section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">
      <h2>quadGEN Workflow</h2>
      <h3>Purpose</h3>
      <ul>
        <li>Provide a concise, repeatable workflow to build and refine <code>.quad</code> curves for QuadToneRIP (QTR).</li>
      </ul>
      <h3>Prerequisites</h3>
      <ul>
        <li><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">QuadToneRIP</a> installed; know where your printerâ€™s â€œquadâ€ folder is.</li>
        <li>Ability to print a step wedge/target via QTR (Print-Tool on macOS recommended).</li>
        <li>Optional (but recommended): <a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a> or <a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Nix Spectro L</a> to capture LAB L*.</li>
      </ul>
      <h3>1) Choose Printer</h3>
      <ul>
        <li>At the top of the page, select your Epson printer model.</li>
      </ul>
      <h3>2) Export a starting <code>.quad</code></h3>
      <ul>
        <li>You can skip this step if you already have an existing <code>.quad</code> to refine. Otherwise, start with a single linear ramp of Black (K) â€” or Matte Black (MK) if available â€” using the default 100% ink limit.</li>
        <li>Install the <code>.quad</code> into QTRâ€™s quad folder for your printer.</li>
      </ul>
      <h3>3) Verify Ink Choice & Limits</h3>
      <ul>
        <li><strong>Digital negative processes</strong>: Find the lowest ink limit that still achieves paper white by printing a step target and determine the ink limit used at the first patch that matches your paper white.  Invert the target image in your editor before printing with your <code>.quad</code>. For example, if the first patch that matches your paper white occured on the 8th darkest patch of an evenly spaced 10 step negative (referring to the <i>positive</i> target image), you can use an ink limit of 80%</li>
        <li><strong>Positive processes (e.g., polymer photogravure)</strong>: Find the maximum ink limit that <em>does not</em> cause open bite by printing an openâ€‘bite target and increasing the ink limit until the first signs of open bite, then back off.</li>
        <li>Once youâ€™ve identified an ink limit, create a new .quad file with that limit and proceed to calibration.</li>
      </ul>
      <h3>4) Print a Calibration Target</h3>
      <ul>
        <li>
          <p><strong>Option A â€” LAB workflow</strong></p>
          <ul>
            <li>Use QTR/Printâ€‘Tool and the <code>.quad</code> from step 2/3 to print a 0â€“100% step wedge (or <a href="https://clayharmonblog.com/downloads" target="_blank" rel="noopener">Clay Harmonâ€™s 21/25â€‘step target</a>).</li>
            <li>Ensure color management is OFF in Printâ€‘Tool.</li>
          </ul>
        </li>
        <li>
          <p><strong>Option B â€” EDN workflow</strong></p>
          <ul>
            <li>Visit <a href="http://www.easydigitalnegatives.com/" target="_blank" rel="noopener">Easy Digital Negatives</a> and download the appropriate target file.</li>
            <li>Print the EDN target via QTR/Printâ€‘Tool with color management OFF, using the <code>.quad</code> from step 2/3.</li>
          </ul>
        </li>
      </ul>
      <h3>5) Calibration: Measure the Print</h3>
      <ul>
        <li>
          <p><strong>Option A â€” LAB workflow</strong></p>
          <ol>
            <li><strong>Set patch count</strong>: choose the number of patches/steps to match your printed target.</li>
            <li><strong>Enter Patch % (X)</strong>: if your target is not evenly spaced, type the input position for each row (0â€“100). If evenly spaced, keep the defaults.</li>
            <li><strong>Measure and enter L*</strong>: measure each printed patch with your device (e.g., <a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a> or <a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Nix Spectro L</a>) and enter L* (0â€“100) in the matching row.</li>
            <li><strong>Apply or save</strong>: click â€œGenerate Correctionâ€ to apply immediately, or â€œSave as .txtâ€ to export the entries for later reuse.</li>
          </ol>
        </li>
        <li>
          <p><strong>Option B â€” EDN workflow</strong></p>
          <ol>
            <li>Follow the EDN instructions to scan and analyze your print result.</li>
            <li>Download the EDN-generated <code>.acv</code> or <code>.cube</code> file.</li>
          </ol>
        </li>
      </ul>
      <h3>6) Load Data into quadGEN</h3>
      <ul>
        <li>
          <p><strong>Option A â€” LAB workflow</strong></p>
          <ol>
            <li><strong>Load LAB (.txt)</strong>: If not already applied from the Manual L* Entry window, use the Load Data File in the Global Corrections panel to load your saved measurements.</li>
            <li><strong>Interpretation</strong>: Y = output ink % vs X = input %; Y = X is â€œno correctionâ€. Too dark at X â†’ dip below diagonal; too light at X â†’ rise above.</li>
            <li><strong>Edit Mode tip</strong>: If Edit Mode is already ON, quadGEN now reseeds Smart key points from the measurement as soon as the file loads so the plotted curve updates immediately.</li>
          </ol>
        </li>
        <li>
          <p><strong>Option B â€” EDN workflow</strong></p>
          <ol>
            <li><strong>Load ACV/LUT</strong>: use the Load Data File in the Global Corrections panel to load the downloaded EDN <code>.acv</code> or <code>.cube</code>.</li>
            <li><strong>Interpretation</strong>: same graph semantics â€” Y = output ink %, X = input %; dips lighten, humps darken.</li>
          </ol>
        </li>
      </ul>
      <h3>7) Export Corrected <code>.quad</code></h3>
      <ul>
        <li>Export the corrected <code>.quad</code> for general use and archive it as your â€œreferenceâ€ Linear profile.</li>
        <li>Keep this reference untouched; branch contrast variants by either baking presets with <strong>Apply Intent</strong> (when no LAB data is loaded) or doing the contrast move upstream in Photoshop before printing through the reference. Both paths land on the same tonal response.</li>
      </ul>
      <h3 id="helpEditModeSection">8) Enter Edit Mode for Fine Tuning (optional)</h3>
      <ul>
        <li><strong>Overview:</strong> Edit Mode converts the selected channel into Smart key points so you can make precise, point-by-point adjustments while every other enabled channel dims for context. Toggle it off when you want to lock the curve.</li>
        <li><strong>Toggle & visibility:</strong> Enable Edit Mode in the Edit Curves panel to expose the Smart controls; the selected channel renders on top and only it shows numbered key-point markers.</li>
        <li><strong>Calculate points:</strong>
          <ul>
            <li><strong>Max error %</strong>: Sets how closely the generated Smart points follow the underlying curve (lower = more points, tighter fit).</li>
            <li><strong>Max Points</strong>: Caps how many Smart points quadGEN will generate (2-21).</li>
            <li><strong>Recompute</strong>: Regenerates Smart key points from the currently plotted curve using the settings aboveâ€”ideal for simplifying dense data from LAB or <code>.quad</code> loads.</li>
          </ul>
        </li>
        <li><strong>Editing tools:</strong>
          <ul>
            <li><strong>XY input</strong>: Type <code>X,Y</code> (Y is absolute after the channel End). The Up/Down nudges adjust absolute Y, and Left/Right nudges adjust X.</li>
            <li><strong>Point selection</strong>: Use the point selector arrows to step through Smart points in order; the label updates as you move.</li>
            <li><strong>Insert/Delete</strong>: Click the chart to insert at the current curve location. Deleting endpoints is blocked; use Undo if a change goes too far.</li>
            <li><strong>Undo / Redo</strong>: Every edit is logged in history, so you can step backwards or forwards as needed.</li>
          </ul>
        </li>
      </ul>
      <h3>9) Iterate Until Linear (optional)</h3>
      <ul>
        <li>Repeat from step 5 until corrections become negligible.</li>
        <li>There will be some noise in the measurements for both workflows. Expect diminishing returns on linearization.</li>
      </ul>
      <h3>10) Choose a Contrast Intent (optional)</h3>
      <ul>
        <li>Use the <strong>Intent</strong> dropdown in Global Correction to pick a preset (Linear, Soft, Hard, Filmic) or choose <strong>Enter Customâ€¦</strong> to open the modal.</li>
        <li><strong>Custom</strong>: apply sliders (Gamma or Filmicâ€‘like) or <strong>Paste CSV/JSON</strong> data; the parser auto-validates pasted text.</li>
        <li>Intents shape the target curve only; ingestion and reconstruction are unchanged. Endpoints (0% and 100%) remain fixed â€” adjust ink limits/end values to move black/white points.</li>
        <li>When no LAB data is active, the <strong>Apply Intent</strong> button bakes the selected preset into the loaded <code>.quad</code>; use it to spin off contrast-specific variants directly from your reference.</li>
      </ul>
      <h3>Notes & Tips</h3>
      <ul>
        <li>Keep curves smooth, avoid kinks near endpoints.</li>
        <li>Use the +/âˆ’ zoom control in the lower-left of the graph to blow up low ink-limit curves; the Y-axis labels reflect the displayed max and the chart auto-expands if a newly enabled channel exceeds it.</li>
        <li>For digital negatives, invert the image in your editor before printing with your <code>.quad</code>.</li>
      </ul>
      <h3>References</h3>
      <ul>
        <li><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">QuadToneRIP</a></li>
        <li><a href="https://www.quadtonerip.com/html/QTRoverview.html" target="_blank" rel="noopener">QTR Overview</a></li>
        <li><a href="https://www.quadtonerip.com/html/QTRprinttool.html" target="_blank" rel="noopener">Printâ€‘Tool (macOS)</a></li>
        <li><a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a></li>
        <li><a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Nix Spectro L</a></li>
      </ul>
    </section>
  `}function XS(){try{document.body.style.overflow="hidden"}catch(e){console&&console.warn&&console.warn("Unable to lock body scroll",e)}}function QS(){try{[m.helpPopup,m.globalCorrectionHelpPopup,m.editModeHelpPopup,m.intentHelpPopup,m.optionsModal].some(n=>n&&!n.classList.contains("hidden"))||(document.body.style.overflow="")}catch(e){console&&console.warn&&console.warn("Unable to unlock body scroll",e)}}function Ml(e,t){e&&(e.classList.toggle("text-gray-800",t),e.classList.toggle("border-slate-700",t),e.classList.toggle("text-gray-500",!t),e.classList.toggle("border-transparent",!t),e.setAttribute("aria-selected",t?"true":"false"))}function b1(){const e=document.getElementById("helpLoadSampleLab");e&&!e.dataset.wired&&(e.addEventListener("click",()=>{const i=window?.quadGenActions;if(i&&typeof i.loadLabData=="function"){const a=i.loadLabData(fu.colorMuse,!0);if(a?.success)window?.showStatus?.("Loaded sample LAB correction");else{const o=a?.message||"Unable to load sample LAB data";window?.showStatus?.(o)}}else window?.showStatus?.("Sample LAB loading is not yet available in this build")}),e.dataset.wired="true");const t=document.getElementById("helpLoadSampleCube");t&&!t.dataset.wired&&(t.addEventListener("click",()=>{window?.showStatus?.("Sample LUT loading is not yet available in the modular build.")}),t.dataset.wired="true");const n=document.getElementById("helpDownloadSampleLab");n&&!n.dataset.wired&&(n.addEventListener("click",i=>{i.preventDefault(),GS()}),n.dataset.wired="true");const r=document.getElementById("helpDownloadSampleCube");r&&!r.dataset.wired&&(r.addEventListener("click",i=>{i.preventDefault(),RS()}),r.dataset.wired="true")}function Wo(e){Ml(m.helpTabReadme,e==="readme"),Ml(m.helpTabGlossary,e==="glossary"),Ml(m.helpTabWorkflow,e==="workflow"),Ml(m.helpTabHistory,e==="history");let t="";switch(e){case"glossary":t=m1();break;case"history":t=h1();break;case"workflow":t=g1();break;case"readme":default:t=f1();break}m.helpContent&&(m.helpContent.innerHTML=t,b1())}function mc(e="readme"){ZS(e),m.helpPopup&&(m.helpPopup.classList.remove("hidden"),XS())}function Sd(){m.helpPopup&&(m.helpPopup.classList.add("hidden"),QS())}function ZS(e="readme"){m.helpAppVersion&&(m.helpAppVersion.textContent=Sa),Wo(e)}function Tg(){mc("workflow"),setTimeout(()=>{document.getElementById("helpEditModeSection")?.scrollIntoView({behavior:"smooth",block:"start"})},0)}function y1(){return`
    <div class="grid gap-4">
      <div class="border border-gray-200 rounded-lg p-4">
        <h3 class="font-semibold text-base mb-3">Making Corrections Overview</h3>
        <p class="text-sm mb-3">
          The correction process involves: 1) Load a .quad file, 2) Test print and measure results, 3) Load measurement data to create corrections, 4) Export corrected .quad and repeat until the printer tracks your target.
        </p>
        <p class="text-xs">
          For complete step-by-step guidance, see
          <button type="button" class="underline hover:text-gray-800" data-open-workflow-help>Detailed Workflow in the main Help</button>.
        </p>
      </div>

      <div class="border border-gray-200 rounded-lg p-4">
        <h3 class="font-semibold text-base mb-3">When Intent Takes Effect</h3>
        <p class="text-sm mb-3">
          <strong>Intent only affects linearization data</strong> (LAB measurements or manual L* entries - not existing .quad curves). If changing Intent does nothing, load measurement data first so quadGEN has something to remap.
        </p>
        <ul class="text-sm space-y-2">
          <li><strong>Intent works with:</strong> LAB .txt files, Manual L* entries</li>
          <li><strong>Intent does not affect:</strong> Loaded .quad files or pre-shaped curves</li>
          <li><strong>To modify existing curves:</strong> Load them as corrections with "Load Data File"</li>
        </ul>
      </div>

      <div class="border border-gray-200 rounded-lg p-4">
        <h3 class="font-semibold text-base mb-3">Understanding the Difference</h3>
        <p class="mb-4">
          Choose a target tonal intent (Linear, Filmic, etc.) to shape how linearization data is applied. Intent guides the correction but does not directly modify an imported curve. To apply an ACV/LUT as a correction, use <span class="font-semibold">Global Corrections -> Load Data File</span>.
        </p>

        <div class="space-y-4">
          <div>
            <h4 class="font-semibold mb-2">Correction = the tuning process.</h4>
            <p class="text-sm">
              Before the performance, every instrument is tuned to an even scale so pitches are objectively accurate. That neutral, linear foundation mirrors how we linearize a printer in L*.
            </p>
          </div>

          <div>
            <h4 class="font-semibold mb-2">Intent = the interpretation.</h4>
            <p class="text-sm mb-3">
              Once tuned, the orchestra can interpret the score in different styles - similar to choosing a Linear, Filmic, or custom intent after the printer is calibrated.
            </p>
            <ul class="list-disc list-inside text-sm space-y-1 ml-4">
              <li><span class="italic font-medium">Literalist</span> - plays the score exactly, no liberties.</li>
              <li><span class="italic font-medium">Rubato</span> - stretches/compresses tempo for expression.</li>
              <li><span class="italic font-medium">Marcato</span> - marked, accented phrasing.</li>
            </ul>
          </div>

          <div class="bg-gray-50 rounded p-3">
            <p class="text-sm italic">
              Changing the intent adjusts the rendered image, but it still rests on a calibration that was tuned to a linear target first.
            </p>
          </div>

          <div class="bg-gray-50 rounded p-3">
            <p class="text-sm">
              Another way to think about intent is as an image filter layered on top of a calibrated baseline: you need the neutral baseline before you can apply a stylized interpretation confidently.
            </p>
          </div>
        </div>
      </div>
    </div>
  `}function S1(){const e=m.intentHelpContent?.querySelector("[data-open-workflow-help]");e&&!e.dataset.wired&&(e.addEventListener("click",()=>{ql({skipUnlock:!0}),mc("workflow")}),e.dataset.wired="true")}function v1(){m.intentHelpPopup&&(m.intentHelpContent&&(m.intentHelpContent.innerHTML=y1(),S1()),m.intentHelpPopup.classList.remove("hidden"),XS())}function ql(e={}){m.intentHelpPopup&&(m.intentHelpPopup.classList.add("hidden"),e.skipUnlock||QS())}function E1(){if(!m.helpContent)return;m.helpBtn&&m.helpPopup&&m.helpBtn.addEventListener("click",()=>mc("readme")),m.closeHelpBtn&&m.closeHelpBtn.addEventListener("click",()=>Sd()),m.helpPopup&&m.helpPopup.addEventListener("click",t=>{t.target===m.helpPopup&&Sd()}),m.helpTabReadme&&m.helpTabReadme.addEventListener("click",()=>Wo("readme")),m.helpTabGlossary&&m.helpTabGlossary.addEventListener("click",()=>Wo("glossary")),m.helpTabWorkflow&&m.helpTabWorkflow.addEventListener("click",()=>Wo("workflow")),m.helpTabHistory&&m.helpTabHistory.addEventListener("click",()=>Wo("history"));const e=document.getElementById("editModeHelpLink");e&&e.addEventListener("click",()=>{Tg()}),m.editModeHelpBtn&&m.editModeHelpBtn.addEventListener("click",()=>{Tg()}),m.globalCorrectionHelpBtn&&m.globalCorrectionHelpBtn.addEventListener("click",()=>{mc("workflow")}),m.intentHelpBtn&&m.intentHelpPopup&&m.intentHelpContent&&m.intentHelpBtn.addEventListener("click",()=>v1()),m.closeIntentHelpBtn&&m.closeIntentHelpBtn.addEventListener("click",()=>ql()),m.intentHelpPopup&&m.intentHelpPopup.addEventListener("click",t=>{t.target===m.intentHelpPopup&&ql()}),document.addEventListener("keydown",t=>{t.key==="Escape"&&(m.helpPopup&&!m.helpPopup.classList.contains("hidden")&&Sd(),m.intentHelpPopup&&!m.intentHelpPopup.classList.contains("hidden")&&ql())}),ZS("readme")}let Kp=null;function w1(e){e&&Z(e)}const C1=`
    <svg class="w-3.5 h-3.5 pointer-events-none" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <rect x="5.5" y="11" width="13" height="9.5" rx="2"></rect>
        <path d="M16 11V8.5a4 4 0 00-7.5-2"></path>
    </svg>`;function A1(e){if(!Number.isFinite(e))return"0";const t=Math.round(e);return Math.abs(e-t)<.05?String(t):Number(e.toFixed(1)).toString()}function M1(e,t){const n=t&&typeof t=="object"?t:kr(e),r=Number.isFinite(n?.value)?n.value:null,i=n?.source||(r!==null?"default":"unset"),a=r!==null?Xy(r):"";return{value:r,source:i,display:a}}function L1(e,t,n,r){const i=document.createElement("tr");i.className="border-t border-gray-200 channel-row",i.setAttribute("data-channel",e);const a=M1(e,r),o=a.display||"",s=a.source||"unset";return i.innerHTML=`
        <td class="p-0 text-center" style="width:0;"></td>
        <td class="px-1 pt-2 pb-1 font-medium align-middle text-left" style="width: 100px;">
            <span class="flex items-center gap-1.5 w-full">
                <button type="button" class="channel-lock-btn px-1.5 py-1 text-xs rounded border border-gray-300 text-gray-600 bg-white hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 flex-shrink-0" data-channel="${e}" data-tooltip="Lock to prevent edits" aria-pressed="false" aria-label="Toggle ink limit lock for ${e}">${C1.trim()}</button>
                <span class="inline-block w-3.5 h-3.5 rounded-sm border border-black/10 flex-shrink-0" style="background-color: ${ni[e]||"#000"}"></span>
                <span class="w-8 channel-name">${e}</span>
                <span class="text-xs text-gray-500 invisible" data-disabled>(disabled)</span>
                <span class="channel-shape-badge hidden text-base leading-none" aria-hidden="true" data-channel-shape></span>
            </span>
        </td>
        <td class="px-1 pt-2 pb-1 text-center" style="width: 250px;">
            <div class="inline-flex items-center gap-2">
                <input type="file" class="per-channel-file hidden" accept=".cube,.txt,.cgats,.cgats17,.ti3,.acv">
                <button class="per-channel-btn px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded transition-colors font-bold" data-tooltip="Load LUT.cube, LABdata.txt, or .acv curve files">Load file</button>
                <button class="per-channel-revert px-2 py-1 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed invisible" title="Revert / Clear Smart" disabled>Revert</button>
                <label class="slider-toggle" title="Enable/disable per-channel linearization">
                    <input type="checkbox" class="per-channel-toggle" disabled>
                    <span class="slider"></span>
                </label>
            </div>
        </td>
        <td class="px-1 pt-2 pb-1 align-middle text-left">
            <div class="flex flex-col gap-1">
                <span class="processing-label italic font-normal text-xs text-gray-600" data-channel="${e}">â†’ Linear ramp</span>
            </div>
        </td>
        <td class="pr-0 pt-2 pb-1 text-right" style="width:120px;">
            <div class="flex items-center justify-end gap-1">
                <input type="number" step="1" min="0" max="100" value="${t}" data-base-percent="${t}" class="percent-input w-16 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right">
            </div>
        </td>
        <td class="pl-0 pt-2 pb-1 text-right" style="width:120px;">
            <input type="number" step="1" min="0" max="65535" value="${n}" data-base-end="${n}" class="end-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right">
        </td>
        <td class="pl-0 pr-2 pt-2 pb-1 text-right" style="width:150px;">
            <div class="flex flex-col items-end gap-1">
                <input type="number" step="0.001" min="0" max="2" value="${o}" class="density-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-xs text-right" data-channel="${e}" data-density-source="${s}" placeholder="â€”">
                <span class="density-coverage-indicator text-xs text-gray-500 text-right hidden" data-coverage-indicator></span>
            </div>
        </td>
    `,i}function I1(){const e=document.createElement("tr");return e.id="noChannelsRow",e.className="hidden border-t border-gray-200",e.innerHTML=`
        <td class="p-0 text-center" style="width:0;"></td>
        <td class="px-1 pt-2 pb-1 font-medium" style="width: 100px;">
            <span class="inline-flex items-center gap-2 invisible">
                <span class="inline-block w-3.5 h-3.5 rounded-sm border border-black/10"></span>
                <span class="w-8 channel-name">XX</span>
                <span class="text-xs text-gray-500 invisible">(disabled)</span>
            </span>
            <div class="text-center text-gray-500 italic" style="margin-top: -24px;">No channels enabled</div>
        </td>
        <td class="px-1 pt-2 pb-1 text-center" style="width: 250px;">
            <div class="inline-flex items-center gap-2 invisible">
                <input type="file" class="hidden per-channel-file">
                <button class="px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded transition-colors font-bold">ðŸ“ Load</button>
                <span class="text-xs text-gray-500">No file</span>
            </div>
        </td>
        <td class="px-1 pt-2 pb-1 text-left">
            <span class="text-xs text-gray-500 invisible">â€”</span>
        </td>
        <td class="pr-0 pt-2 pb-1 text-right" style="width:120px;">
            <input type="number" step="1" min="0" max="100" value="100" data-base-percent="100" class="percent-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right invisible" disabled>
        </td>
        <td class="pl-0 pt-2 pb-1 text-right" style="width:120px;">
            <input type="number" step="1" min="0" max="65535" value="65535" data-base-end="65535" class="end-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right invisible" disabled>
        </td>
        <td class="pl-0 pr-2 pt-2 pb-1 text-right" style="width:150px;">
            <div class="flex flex-col items-end gap-1">
                <input type="number" step="0.001" min="0" max="2" value="" class="density-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-xs text-right invisible" disabled>
                <span class="density-coverage-indicator text-xs text-gray-500 text-right hidden" data-coverage-indicator></span>
            </div>
        </td>
    `,e}function k1(e){if(!m.channelInfo)return;const t=e.channels.map(n=>`<span class="inline-flex items-center mr-1"><span style="color:${ni[n]||"#000000"}; margin-right:0px;">â– </span><strong>${n}</strong></span>`).join("");m.channelInfo.innerHTML=t?`Channels: ${t}`:"",m.printerDescription&&(m.printerDescription.textContent="")}function D1(e,t,n){const r=t?.[e]||{};let i;typeof r.percent=="number"&&Number.isFinite(r.percent)&&(i=q.clampPercent(r.percent));let a;return typeof r.endValue=="number"&&Number.isFinite(r.endValue)&&(a=q.clampEnd(r.endValue)),i===void 0&&a!==void 0&&(i=q.clampPercent(q.computePercentFromEnd(a))),a===void 0&&i!==void 0&&(a=q.computeEndFromPercent(i)),i===void 0&&(i=e===n?100:0),a===void 0&&(a=q.computeEndFromPercent(i)),{percent:q.clampPercent(i),endValue:q.clampEnd(a)}}function P1(e){Kp=typeof e=="function"?e:null}function x1(e){if(!Kp||!e)return;e.querySelectorAll("tr.channel-row[data-channel]").forEach(n=>Kp(n))}function Su(e,t={}){if(typeof document>"u")return;const n=dn[e]?e:"P700P900",r=dn[n],i=t.channelOverrides||{};t.updateSelect!==!1&&m.printerSelect&&(m.printerSelect.value=n);try{const l=at();l&&l.setPrinter(n,i)}catch(l){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[printer-manager] Unable to update state manager:",l)}if(!m.rows){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[printer-manager] rows element not found");return}Ww(),m.rows.innerHTML="";const a=document.createDocumentFragment(),o=r.channels.includes("MK")?"MK":r.channels.includes("K")?"K":r.channels[0],s={};FC(r.channels),r.channels.forEach(l=>{const{percent:c,endValue:u}=D1(l,i,o);s[l]={percentLimit:c,endValue:u};const d=kr(l),p=L1(l,c,u,d);a.appendChild(p),wy(l,p)}),a.appendChild(I1()),m.rows.appendChild(a),lw(s),Yp(i),x1(m.rows),k1(r),Cs(),fi(),r.channels.forEach(l=>{try{un(l)}catch{}});try{yt()}catch{}try{Be()}catch{}try{nn()}catch{}try{wo()}catch{}try{Ao()}catch{}if(!t.silent){const l=t.reason==="quadLoad"?`Loaded ${t.filename||"quad file"} - switched to ${r.name}`:`Switched to ${r.name}`;w1(l)}}function B1(){const e=m.printerSelect?.value||"P700P900";m.printerSelect&&(m.printerSelect.value=e),Su(e,{updateSelect:!1,silent:!0})}function Yp(e={}){!m.rows||!e||typeof e!="object"||Object.entries(e).forEach(([t,n])=>{const r=m.rows.querySelector(`tr.channel-row[data-channel="${t}"]`);if(!r)return;const i=r.querySelector(".percent-input"),a=r.querySelector(".end-input");if(!i||!a)return;const o=q.clampEnd(Number.isFinite(n?.endValue)?n.endValue:a.value),s=q.computePercentFromEnd(o);i.value=A1(s),i.setAttribute("data-base-percent",String(s)),a.value=String(o),a.setAttribute("data-base-end",String(o))})}function T1(e,t={}){if(!e||!Array.isArray(e.channels))return;const n={};e.channels.forEach((o,s)=>{const l=q.clampEnd(e.values?.[s]??0);n[o]={endValue:l,percent:q.computePercentFromEnd(l)}});const r=Ck(e.channels,dn)||m.printerSelect?.value||"P700P900",i=t.silent??!1;Su(r,{channelOverrides:n,updateSelect:!0,reason:"quadLoad",filename:e.filename,silent:i}),Yp(n);const a=()=>Yp(n);typeof requestAnimationFrame=="function"?requestAnimationFrame(()=>{a(),requestAnimationFrame(a)}):(setTimeout(a,0),setTimeout(a,50))}const O1=.85,_1=1.9,N1=256;function F1(e={}){return{clampMin:Number.isFinite(e.clampMin)?e.clampMin:O1,clampMax:Number.isFinite(e.clampMax)?e.clampMax:_1,resolution:Number.isFinite(e.resolution)?Math.max(16,Math.floor(e.resolution)):N1}}const sa=1e-6;function G1(e){return Array.isArray(e)?e.map(t=>({input:Number.isFinite(t?.input)?t.input:Number(t?.inputPercent??t?.gray??t?.GRAY),lab:Number.isFinite(t?.lab)?t.lab:Number(t?.labL??t?.LAB_L??t?.l??t?.L)})).filter(t=>Number.isFinite(t.input)&&Number.isFinite(t.lab)).map(t=>({input:Math.max(0,Math.min(100,t.input)),lab:Math.max(0,Math.min(100,t.lab))})).sort((t,n)=>t.input-n.input):[]}function Og(e){if(!e.length)return{minDensity:0,maxDensity:0,normalized:[],raw:[]};const t=e.map(o=>Fs(o.lab)),n=Math.min(...t),r=Math.max(...t),i=Math.max(sa,r-n),a=t.map(o=>ce((o-n)/i));return{minDensity:n,maxDensity:r,normalized:a,raw:t}}function R1(e,t,n={}){const r=Number.isFinite(n.minSigma)?Math.max(.005,n.minSigma):.02,i=Number.isFinite(n.maxSigma)?Math.max(r,n.maxSigma):.08,a=ce(t);return r+a*(i-r)}function z1(e,t,n,r={}){if(e.length!==t.length||e.length!==n.length)return t.slice();const i=new Array(t.length);for(let a=0;a<e.length;a+=1){const o=e[a],s=R1(o,n[a],r),l=s*3;let c=0,u=0;for(let d=0;d<e.length;d+=1){const p=Math.abs(e[d]-o);if(p>l)continue;const f=Math.exp(-(p*p)/(2*s*s));u+=t[d]*f,c+=f}c>sa?i[a]=u/c:i[a]=t[a]}return i}function Ll(e,t,n){const r=Number(e);return Number.isFinite(r)?r<t?t:r>n?n:r:Math.min(Math.max(1,t),n)}function U1(e,t,n){if(!e.length)return{normalizedValues:[],targetValues:[],metadata:{}};if(n===Kt.DENSITY){const c=Og(e),u=c.normalized.map((p,f)=>f===0?0:f===c.normalized.length-1?1:ce(p)),d=t.map((p,f)=>f===0?0:f===t.length-1?1:ce(p));return{normalizedValues:u,targetValues:d,metadata:{minDensity:c.minDensity,maxDensity:c.maxDensity}}}const r=e[0]?.lab??100,i=e[e.length-1]?.lab??0,a=Math.max(sa,r-i),o=e.map((c,u)=>{if(u===0)return 0;if(u===e.length-1)return 1;const d=(r-c.lab)/a;return ce(d)}),s=t.map((c,u)=>u===0?0:u===t.length-1?1:ce(c)),l=Og(e);return{normalizedValues:o,targetValues:s,metadata:{minDensity:l.minDensity,maxDensity:l.maxDensity,highlightLab:r,shadowLab:i}}}function $1(e,t={}){const{clampMin:n=.85,clampMax:r=1.9,resolution:i=256,smoothing:a={},normalizationMode:o=null}=t,s=G1(e);if(!s.length){const y=Array.from({length:i},()=>1);return{clampMin:n,clampMax:r,positions:[],rawGain:[],smoothedGain:[],samples:y,rawSamples:y.slice(),normalizedDensity:[],metadata:{minDensity:0,maxDensity:0}}}const l=s.map(y=>ce(y.input/100)),c=o||rr?.()||Kt.LSTAR,{normalizedValues:u,targetValues:d,metadata:p}=U1(s,l,c),f=l.map((y,v)=>{if(v===0||v===l.length-1)return 1;const A=ce(d[v]??l[v]),w=ce(u[v]);if(A<=sa&&w<=sa)return 1;if(w<=sa)return r;const M=A/Math.max(sa,w);return Ll(M,n,r)});f[0]=1,f[f.length-1]=1;const h=z1(l,f,u,a).map((y,v)=>v===0||v===l.length-1?1:Ll(y,n,r));h[0]=1,h[h.length-1]=1;const g=zr(l,h),b=zr(l,f),S=[],E=[];for(let y=0;y<i;y+=1){const v=l.length===1?l[0]:y/(i-1),A=Ll(g(v),n,r),w=Ll(b(v),n,r);S.push(A),E.push(w)}return{clampMin:n,clampMax:r,positions:l,rawGain:f,smoothedGain:h,samples:S,rawSamples:E,normalizedDensity:u,metadata:{normalizationMode:c,targetNormalized:d.slice(),normalizedResponse:u.slice(),...p}}}const Tr=1e-6,vd=.15,V1=new Set(["K","MK","PK"]);function _g(e,t){if(!Array.isArray(e))return new Array(t).fill(0);if(e.length===t)return e.slice();const n=new Array(t).fill(0),r=e.length-1;if(r<0)return n;for(let i=0;i<t;i+=1){const a=i/Math.max(1,t-1),o=Math.min(r,Math.round(a*r));n[i]=Number(e[o])||0}return n}function Oa(e,t=0,n=ve){return!Number.isFinite(e)||e<t?t:e>n?n:e}function Ng({channels:e,gainCurve:t,allowCeilingLift:n=!1,maxLiftPercent:r=vd,densityWeights:i={}}){if(!e||typeof e!="object")throw new Error("applyGainToChannels requires channels map");if(!Array.isArray(t)||!t.length)throw new Error("applyGainToChannels requires gainCurve samples");const a=t.length,s=Object.keys(e).filter(p=>{const f=e[p];return!f||f.enabled===!1?!1:_g(f.samples,a).some(g=>Math.abs(g)>Tr)}).map(p=>{const f=e[p]||{},h=Oa(Number(f.endValue)||0,0,ve),g=_g(f.samples,a),b=V1.has((p||"").toUpperCase());let S=0;for(let A=0;A<a;A+=1){const w=Number.isFinite(t[A])?t[A]:1,M=Oa(g[A]*w,0,ve);M>S&&(S=M)}const E=h>0?Math.max(0,(S-h)/h):0,y=b?0:Math.min(Math.max(0,Number(r)||0),E,vd),v=n?Math.min(ve,Math.round(h*(1+y))):h;return{name:p,baseEnd:h,maxLift:v,currentLimit:h,samples:g,adjustedSamples:new Array(a).fill(0),sampleCaps:new Array(a).fill(v),liftApplied:0,requestedPeak:S,requestedLiftRatio:E,isKeyChannel:b}}),l={};let c=0;s.forEach(p=>{const f=Math.max(0,Number(i[p.name])||0);l[p.name]=f,c+=f}),c<=Tr&&(s.forEach(p=>{l[p.name]=1}),c=s.length||1);const u=new Array(a).fill(0);for(let p=0;p<a;p+=1){const f=Number.isFinite(t[p])?t[p]:1,h=s.reduce((E,y)=>E+(y.samples[p]||0),0),g=s.map(E=>{const y=E.samples[p]||0,v=Oa(y*f,0,ve),A=Math.max(0,f-1),w=Math.min(A,vd);let M;y>Tr?M=Oa(y*(1+w),0,E.maxLift):v>0?M=Oa(E.baseEnd*w,0,E.maxLift):M=0,E.isKeyChannel?M=Math.min(M,y):M=Math.min(M,E.maxLift),E.sampleCaps[p]=M;const I=Math.min(M,v),_=Math.max(0,v-I);return E.adjustedSamples[p]=I,E.currentLimit=Math.max(E.currentLimit,I),I>E.baseEnd&&(E.liftApplied=Math.max(E.liftApplied,I-E.baseEnd)),{state:E,baseValue:y,applied:I,overflow:_,share:h>Tr?y/h:0}});let b=g.reduce((E,y)=>E+y.overflow,0),S=0;for(;b>Tr&&S<6;){S+=1;const E=g.map(A=>{const w=A.state.sampleCaps?.[p]??A.state.maxLift,M=Math.max(0,w-A.state.adjustedSamples[p]);if(M<=Tr)return null;const I=l[A.state.name]/c,C=.55*A.share+.35*I+.1;return{entry:A,capacity:M,weight:C*M}}).filter(Boolean);if(!E.length)break;const y=E.reduce((A,w)=>A+w.weight,0);if(y<=Tr)break;let v=0;E.forEach(A=>{if(b<=Tr)return;const w=A.weight/y*b,M=Math.min(A.capacity,w);if(M>Tr){const I=A.entry.state,_=I.sampleCaps?.[p]??I.maxLift,C=Math.min(_,I.adjustedSamples[p]+M),x=Math.max(0,C-I.adjustedSamples[p]);x>Tr&&(I.adjustedSamples[p]=C,I.currentLimit=Math.max(I.currentLimit,C),C>I.baseEnd&&(I.liftApplied=Math.max(I.liftApplied,C-I.baseEnd)),v+=x)}}),b=Math.max(0,b-v)}b>Tr&&(u[p]=b)}const d={};return s.forEach(p=>{const f=Math.round(Math.min(p.currentLimit,p.maxLift));d[p.name]={samples:p.adjustedSamples.map(h=>Math.round(Oa(h,0,ve))),endValue:f,liftApplied:Math.max(0,Math.round(f-p.baseEnd)),baseEnd:p.baseEnd}}),{channels:d,metadata:{residualOverflow:u,perChannelLift:s.reduce((p,f)=>(p[f.name]=Math.max(0,Math.round(Math.min(f.currentLimit,f.maxLift)-f.baseEnd)),p),{}),requestedLiftRatio:s.reduce((p,f)=>(p[f.name]=Number.isFinite(f.requestedLiftRatio)?f.requestedLiftRatio:0,p),{})}}}const jl=1e-6;function H1(e,t,n){return Number.isFinite(e)?e<t?t:e>n?n:e:1}function Xp(e,t){if(!Array.isArray(e))return new Array(t).fill(0);if(e.length===t)return e.slice();const n=new Array(t),r=e.length-1;for(let i=0;i<t;i+=1){if(r<0){n[i]=0;continue}const a=i/Math.max(1,t-1),o=Math.min(r,Math.round(a*r));n[i]=Number(e[o])||0}return n}function Ed(e,t){const n=new Array(t).fill(0);return!e||typeof e!="object"||Object.keys(e).forEach(r=>{const i=e[r];if(!i)return;const a=Xp(i.samples,t);for(let o=0;o<t;o+=1)n[o]+=Number(a[o])||0}),n}function Fg(e,t){let n=0,r=0,i=0;const a=new Array(e.length);for(let o=0;o<e.length;o+=1){const s=Number(e[o])||1,l=Number(t[o])||1,c=l>jl?s/l:1,u=Math.abs(c-1);a[o]=u,u>n&&(n=u),r+=u,i+=1}return{max:n,mean:i>0?r/i:0,profile:a}}function q1(e,t,n,r){const i=Xp(e?.samples,n),a=Xp(t?.samples,n),o=new Array(n);for(let u=0;u<n;u+=1){const d=Number(i[u])||0,p=Number(a[u])||0;o[u]=Math.round(d+(p-d)*r)}const s=Number(e?.endValue)||0,l=Number(t?.endValue)||s,c=Math.round(s+(l-s)*r);return{samples:o,endValue:c,baseEnd:Number(t?.baseEnd??s),liftApplied:Math.max(0,c-Number(t?.baseEnd??s))}}function j1({measurements:e=[],channels:t={},densityWeights:n={},options:r={}}={}){const{clampMin:i,clampMax:a,resolution:o}=F1(r),s=$1(e,{clampMin:i,clampMax:a,resolution:o}),l=Ng({channels:t,gainCurve:s.samples,allowCeilingLift:r.allowCeilingLift===!0,maxLiftPercent:Number.isFinite(r.maxLiftPercent)?r.maxLiftPercent:.02,densityWeights:n}),c=Ed(t,o),u=Ed(l.channels,o),d=c.map((I,_)=>{const C=Math.max(jl,I);return u[_]/C}),p=Fg(s.samples,d),f=[{gainCurve:s.samples,residual:p}];let h=l.channels,g=u,b=d;const S=Number.isFinite(r.maxIterations)?Math.max(1,Math.floor(r.maxIterations)):2,E=Number.isFinite(r.residualThreshold)?Math.max(0,r.residualThreshold):.05,y=Number.isFinite(r.residualIntensity)?Math.max(0,Math.min(1,r.residualIntensity)):.3;if(S>1&&p.max>E){const I=s.samples.map((P,k)=>{const N=b[k],j=1+((N>jl?P/N:1)-1)*y;return H1(j,i,a)}),_={};Object.keys(h).forEach(P=>{_[P]={samples:h[P].samples,endValue:h[P].endValue}}),h=Ng({channels:_,gainCurve:I,allowCeilingLift:r.allowCeilingLift===!0,maxLiftPercent:Number.isFinite(r.maxLiftPercent)?r.maxLiftPercent:.02,densityWeights:n}).channels,g=Ed(h,o),b=c.map((P,k)=>{const N=Math.max(jl,P);return g[k]/N});const x=Fg(s.samples,b);f.push({gainCurve:I,residual:x})}const v=Number.isFinite(r.blendPercent)?Math.max(0,Math.min(100,r.blendPercent)):100,A=v/100;let w=h;A<1&&(w={},Object.keys(t).forEach(I=>{w[I]=q1(t[I],h[I],o,A)}));const M={};return Object.keys(w).forEach(I=>{const _=Number(t[I]?.endValue)||0,C=Number(w[I]?.endValue)||_;M[I]=Math.max(0,C-_)}),{gain:s,channels:w,passes:f,metadata:{blendPercent:v,perChannelLift:M,residual:f[f.length-1]?.residual||p}}}const ze=typeof window<"u"?window:globalThis,mn=typeof document<"u";function W1(){const e=ze&&typeof ze=="object"?ze.__COMPOSITE_AUDIT__:null;if(!e||e.enabled===!1)return null;const t=Number.isFinite(e.sampleIndex)?Math.max(0,Math.floor(e.sampleIndex)):242;Array.isArray(e.events)||(e.events=[]);const n=typeof e.log=="function"?e.log:(r,i)=>{try{console.log("[COMPOSITE_AUDIT]",r,i)}catch{}};return{index:t,log:n,events:e.events}}function K1(e,t){try{const n=W1();if(!n)return;const r=typeof t=="function"?t(n.index):t;if(r==null)return;n.log(e,r),Array.isArray(n.events)&&n.events.push({stage:e,payload:r,ts:Date.now()})}catch(n){console.warn("[COMPOSITE_AUDIT] ui emit failed:",n)}}function Ms(e){if(!e||typeof e!="object")return null;const t=n=>{if(!n||typeof n!="object")return null;const r={};let i=!1;return Object.entries(n).forEach(([a,o])=>{Array.isArray(o)&&(r[a]=o.slice(),i=!0)}),i?r:null};return t(e.plotBaseCurvesBaseline)||t(e._plotSmoothingOriginalCurves)||t(e.plotBaseCurves)||null}function Qp(e,t,n,r={}){if(!e||!t||!Array.isArray(n))return;(!e.plotBaseCurvesBaseline||typeof e.plotBaseCurvesBaseline!="object")&&(e.plotBaseCurvesBaseline={});const{force:i=!1}=r;(!Array.isArray(e.plotBaseCurvesBaseline[t])||i)&&(e.plotBaseCurvesBaseline[t]=n.slice())}function Y1(e){return!e||typeof e!="object"?!1:!!(e.meta&&(e.meta.baked===!0||e.meta.bakedGlobal===!0)||(typeof e.filename=="string"?e.filename:"").includes("*BAKED*")||(typeof e.source=="string"?e.source.toLowerCase():"").includes("baked")||typeof D?.isGlobalBaked=="function"&&D.isGlobalBaked())}let Il=null,kl=null,Dl=null,Pl=null,xl=null,Xa=null,wd=null,Gg=!1,Wl=null,Bl=0;const X1=5;let In=null;const Q1=.003,Z1=1e-6,J1=.995,Cd=.5;function eD(){if(!mn){In=null;return}try{const e=typeof Eo=="function"?Eo():null;e&&typeof e=="object"?In=e:In=null}catch(e){In=null,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[coverage] unable to read composite coverage summary:",e)}}function tD(e){if(!In||!e)return null;const t=i=>typeof i=="string"?i:"";if(In instanceof Map){const i=In.get(e);if(i)return i;const a=In.get(t(e).toUpperCase());if(a)return a;const o=In.get(t(e).toLowerCase());return o||null}if(In[e])return In[e];const n=t(e).toUpperCase();if(In[n])return In[n];const r=t(e).toLowerCase();return In[r]?In[r]:null}function Rg(e,t=1){return Number.isFinite(e)?`${(ce(e)*100).toFixed(t).replace(/\.0+$/,"").replace(/(\.\d*[1-9])0+$/,"$1")}%`:"â€”"}function JS(e,t){if(!e||!mn)return;const n=e.querySelector("[data-coverage-indicator]");if(!n)return;const r=tD(t);if(!r){n.textContent="",n.classList.add("hidden"),n.classList.remove("text-amber-600"),n.classList.add("text-gray-500"),n.removeAttribute("title");return}const i=Number.isFinite(r.maxNormalized)?ce(r.maxNormalized):null,a=Number.isFinite(r.bufferedLimit)?ce(r.bufferedLimit):Number.isFinite(r.limit)?ce(r.limit):null;if(i===null||a===null){n.textContent="",n.classList.add("hidden"),n.classList.remove("text-amber-600"),n.classList.add("text-gray-500"),n.removeAttribute("title");return}n.textContent=`Coverage ${Rg(i)} / ${Rg(a)}`,n.classList.remove("hidden");const o=a-i,s=Number(r.overflow)||0,l=s>0||o<=Q1+Z1;if(n.classList.toggle("text-amber-600",l),n.classList.toggle("text-gray-500",!l),s>0&&Array.isArray(r.clampedSamples)&&r.clampedSamples.length){const c=r.clampedSamples.slice(0,3).map(d=>Number.isFinite(d.inputPercent)?`${d.inputPercent.toFixed(1)}%`:Number.isInteger(d.index)?`sample ${d.index}`:"sample"),u=r.clampedSamples.length>3?"â€¦":"";n.title=`Clamped at ${c.join(", ")}${u}`}else l?n.title="Coverage ceiling reached for this channel.":n.removeAttribute("title")}function hc(){if(!mn||!m.rows){In=null;return}eD(),m.rows.querySelectorAll("tr.channel-row[data-channel]").forEach(t=>{const n=t.getAttribute("data-channel");JS(t,n)})}function Ko(e,t){if(!e)return;const n=e.querySelector(".density-input"),r=t?.source||"unset",i=Number.isFinite(t?.value)?t.value:null,a=i!==null?Xy(i):"";n&&(!(n.dataset.userEditing==="true")&&document.activeElement!==n&&(n.value=a),n.setAttribute("data-density-source",r),n.dataset.densitySource=r,n.placeholder=a?"":"â€”");const o=e.getAttribute("data-channel");JS(e,o)}function zg(e){return`${(e/255*100).toFixed(1).replace(/\\.0$/,"")}%`}function nD(e){const t=new Map,n=new Map;e.forEach(i=>{const a=i?.curve,o=Math.max(0,Number(i?.currentEnd)||0);if(!(!Array.isArray(a)||a.length===0||o<=0))for(let s=0;s<a.length;s+=1){const l=a[s],c=s/255*100;if(l>=o*J1&&c<95){t.has(i.channelName)||t.set(i.channelName,zg(s));const u=n.get(s)||[];u.push(i.channelName),n.set(s,u)}}});const r=[];return t.forEach((i,a)=>{r.push(`${a} channel reaches â‰¥99% ink near ${i}`)}),n.forEach((i,a)=>{i.length>=2&&r.push(`Multiple channels (${i.join(", ")}) saturate near ${zg(a)}`)}),r}function Ad(e){if(!m.scaleAllInput)return;const t=Number(e),n=Ut(),r=Number.isFinite(t)&&t>0?t:n,i=Jn(r);m.scaleAllInput.value!==i&&(m.scaleAllInput.value=i),Wl=r}function Ug(){if(!m.scaleAllInput)return;if(Il){try{Il()}catch(n){console.warn("Failed to remove scaling state subscription",n)}Il=null,mn&&(ze.__scalingStateSubscribed=!1)}if(!!!(mn&&ze.__USE_SCALING_STATE)){Wl=null,Ad(Ut());return}let t;try{t=at()}catch(n){console.warn("Scaling state manager unavailable:",n);return}if(!(!t||typeof t.subscribe!="function")){try{Ad(t.get("scaling.globalPercent"))}catch(n){console.warn("Unable to read scaling.globalPercent from state",n)}Il=t.subscribe(["scaling.globalPercent"],(n,r)=>{if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("ðŸ” [SCALE STATE] scaling.globalPercent changed",r),!!m.scaleAllInput){if(Wl!=null){const i=Number(r);if(Number.isFinite(i)&&Math.abs(i-Wl)<1e-6)return}Ad(r)}}),mn&&(ze.__scalingStateSubscribed=!0);try{cr({reason:"subscription:resync",throwOnMismatch:!1})}catch(n){console.warn("Scaling state validation failed after subscription resync",n)}}}function $g(e){if(!mn)return;ze.__quadRevertInProgress=!!e;const t=document.body;t&&t.classList.toggle("revert-in-progress",!!e)}function rD(){const e=gt();return{linearization:{...e.perChannelLinearization||{}},enabled:{...e.perChannelEnabled||{}},filenames:{...e.perChannelFilenames||{}}}}function Yi(e,t){try{const n={...gt().perChannelLinearization||{}};t?n[e]=t:delete n[e],nt({perChannelLinearization:n})}catch(n){console.warn("Unable to sync per-channel state",n)}}const Fn=Ns(()=>{nn()},300);function Vg(e=rr()){const t=e===Kt.DENSITY;m.labDensityToggle&&(m.labDensityToggle.checked=t,m.labDensityToggle.setAttribute("aria-checked",String(t))),m.manualLstarDensityToggle&&(m.manualLstarDensityToggle.checked=t,m.manualLstarDensityToggle.setAttribute("aria-checked",String(t)))}function Md(e=Gn()){const t=Number(e),n=Number.isFinite(t)?Math.max(0,Math.min(600,Math.round(t))):Gn();if(m.labSmoothingSlider&&Number(m.labSmoothingSlider.value)!==n&&(m.labSmoothingSlider.value=String(n)),m.labSmoothingValue){const r=Ir(n);m.labSmoothingValue.textContent=`${n}% (Ã—${r.toFixed(2)})`}}function Ii(e,t=null,n={}){if(!e)return;const{source:r="curves",force:i=!1,preserveExistingSnapshot:a=!1}=typeof n=="object"&&n!==null?n:{},o=r==="rebasedCurves"?e.rebasedCurves:r==="rebasedSources"?e.rebasedSources:r&&typeof r=="object"?r:e.curves;if(!o||typeof o!="object")return;const s=Array.isArray(t)&&t.length?t:Object.keys(o);!Array.isArray(s)||!s.length||((!e.plotBaseCurves||typeof e.plotBaseCurves!="object")&&(e.plotBaseCurves={}),(!e._plotSmoothingOriginalCurves||typeof e._plotSmoothingOriginalCurves!="object")&&(e._plotSmoothingOriginalCurves={}),(!e._plotSmoothingBaselineCurves||typeof e._plotSmoothingBaselineCurves!="object")&&(e._plotSmoothingBaselineCurves={}),(!e._plotSmoothingOriginalEnds||typeof e._plotSmoothingOriginalEnds!="object")&&(e._plotSmoothingOriginalEnds={}),(!e.baselineEnd||typeof e.baselineEnd!="object")&&(e.baselineEnd={}),s.forEach(l=>{if(!l)return;const c=Array.isArray(o[l])?o[l]:null;if(!c||!c.length)return;const u=c.slice(),d=u.reduce((E,y)=>y>E?y:E,0),p=Array.isArray(e._plotSmoothingOriginalCurves[l])?e._plotSmoothingOriginalCurves[l]:null,f=Number(e._plotSmoothingOriginalEnds&&e._plotSmoothingOriginalEnds[l]),h=Number.isFinite(f)?f:Array.isArray(p)?p.reduce((E,y)=>y>E?y:E,0):Number.NaN,g=Array.isArray(p)&&p.length>0;if(!g||!Number.isFinite(h)||d>h+Cd?!0:a&&d<h-Cd?!1:i&&!a){e.plotBaseCurves[l]=u.slice(),e._plotSmoothingOriginalCurves[l]=u.slice(),e._plotSmoothingBaselineCurves[l]=u.slice(),e._plotSmoothingOriginalEnds[l]=d,e.baselineEnd[l]=d;return}const S=Number.isFinite(h)?h:d;Array.isArray(e.plotBaseCurves[l])||(e.plotBaseCurves[l]=p?p.slice():u.slice()),Array.isArray(e._plotSmoothingBaselineCurves[l])||(e._plotSmoothingBaselineCurves[l]=p?p.slice():u.slice()),(!Number.isFinite(f)||S>f+Cd)&&(e._plotSmoothingOriginalEnds[l]=S),(!Number.isFinite(e.baselineEnd[l])||a)&&(e.baselineEnd[l]=S)}))}function ev(e,t){if(!Array.isArray(e)||e.length===0)return Array.isArray(e)?e.slice():[];const n=Number(t);if(!Number.isFinite(n)||n<=0)return e.slice();const r=Math.max(1,Math.round(n/100*12)),i=e.length,a=new Array(i);for(let o=0;o<i;o+=1){let s=0,l=0;for(let c=-r;c<=r;c+=1){const u=Math.min(i-1,Math.max(0,o+c)),d=r-Math.abs(c)+1;s+=e[u]*d,l+=d}a[o]=l>0?Math.round(s/l):e[o]}return i>0&&(a[0]=e[0]),a}function gc(e,t){if(!Array.isArray(e))return Array.isArray(t)?new Array(t.length).fill(0):[];if(!Array.isArray(t)||t.length===0)return e.slice();const n=Math.min(e.length,t.length),r=e.slice();for(let i=0;i<n;i+=1){const a=Number(t[i])||0;a<=0?r[i]=0:r[i]>a&&(r[i]=a)}return r}function bc(e){return Array.isArray(e)?e.slice():[]}const tv=6,nv=6,iD=.98;function aD(e,t,n=iD){if(!Array.isArray(e))return[];if(!Number.isFinite(t)||t<=0)return e.slice();const r=e.slice(),i=r.reduce((s,l)=>l>s?l:s,0);if(!Number.isFinite(i)||i<=0)return r;const a=Math.max(0,Math.min(t*n,t-1));if(a<=0||i>=a)return r;const o=a/i;for(let s=0;s<r.length;s+=1){const l=Math.max(0,Number(r[s])*o);r[s]=Math.round(l)}return r}function oD(e,t,n,r={}){if(!Array.isArray(e))return[];const i=e.slice(),a=i.length;if(a===0)return i;const o=Math.max(2,Math.min(r.windowSize??tv,a)),s=Math.max(0,a-o);for(let u=s;u<a;u+=1){const d=o>1?(u-s)/(o-1):1,p=Number(i[u])||0,f=Array.isArray(t)&&t[u]!=null?Number(t[u])||0:p,h=1-d,g=h*p+(1-h)*f;i[u]=Math.round(Math.max(0,g))}const l=Array.isArray(t)&&t[a-1]!=null?Number(t[a-1])||0:Number(n)||0,c=a>=2&&Array.isArray(t)&&t[a-2]!=null?Number(t[a-2])||0:null;if(c!=null){const u=l-(l-c);i[a-2]<u&&(i[a-2]=u)}for(let u=s;u<a-1;u+=1)if(Array.isArray(t)&&t[u]!=null){const d=Number(t[u])||0;i[u]<d&&(i[u]=d)}i[a-1]=l;for(let u=s+1;u<a;u+=1)i[u]<i[u-1]&&(i[u]=i[u-1]);return i}function sD(e,t,n={}){if(!Array.isArray(e))return[];const r=e.slice(),i=r.length;if(i===0)return r;const a=Math.max(2,Math.min(n.windowSize??nv,i)),o=Math.min(a,i);for(let s=0;s<o;s+=1){const l=o>1?s/(o-1):1,c=Number(r[s])||0,u=Array.isArray(t)&&t[s]!=null?Number(t[s])||0:c,d=l,p=d*c+(1-d)*u;r[s]=Math.round(Math.max(0,p))}for(let s=0;s<o;s+=1){const l=Array.isArray(t)&&t[s]!=null&&Number(t[s])||0;r[s]<l&&(r[s]=l),s>0&&r[s]<r[s-1]&&(r[s]=r[s-1])}return r}function vu(e,t){if(!Array.isArray(e))return[];if(!Number.isFinite(t)||t<=0)return e.slice();const n=Math.max(...e);if(!Number.isFinite(n)||n<=0)return new Array(e.length).fill(0);const r=t/n,i=e.map(o=>Math.round(Math.max(0,o*r))),a=i.length-1;if(a>=0){const o=e[a]??0,s=Math.round(Math.max(0,o*r));i[a]=Math.min(t,s)}return i}function lD(e,t,n){if(!Array.isArray(e)||e.length===0||!n)return;const r=Math.max(0,Number(t)||0);(!n.plotBaseCurves||typeof n.plotBaseCurves!="object")&&(n.plotBaseCurves={}),!n._plotSmoothingOriginalCurves||typeof n._plotSmoothingOriginalCurves!="object"?n._plotSmoothingOriginalCurves={}:Object.keys(n._plotSmoothingOriginalCurves).forEach(a=>{n.plotBaseCurves[a]||delete n._plotSmoothingOriginalCurves[a]}),(!n._plotSmoothingOriginalEnds||typeof n._plotSmoothingOriginalEnds!="object")&&(n._plotSmoothingOriginalEnds={});const i=n._plotSmoothingOriginalEnds;e.forEach(a=>{const{channelName:o}=a;if(!o||!Array.isArray(a.curve))return;const s=a.curve.slice();if(n.plotBaseCurves[o]=s.slice(),i[o]==null){const c=Math.max(...s);i[o]=Number.isFinite(c)?c:0}const l=Number.isFinite(n.channelPeaks?.[o])?n.channelPeaks[o]:null;if(r>0){const c=Math.max(...s),u=gc(ev(s,r),s),d=vu(u,c);a.curve=bc(gc(d,s))}else l!=null&&(a.curve=bc(s))}),Object.entries(n.plotBaseCurves).forEach(([a,o])=>{n._plotSmoothingOriginalCurves[a]=Array.isArray(o)?o.slice():[]})}function is(e){const t=Ee?.();if(!t||!t.curves)return;typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[PlotSmoothing] apply start",{percent:e});const n=Math.max(0,Number(e)||0);if(n<=0&&t._zeroSmoothingCurves&&typeof t._zeroSmoothingCurves=="object"&&(Object.entries(t._zeroSmoothingCurves).forEach(([o,s])=>{if(!Array.isArray(s))return;const l=s.slice();(!t.rebasedSources||typeof t.rebasedSources!="object")&&(t.rebasedSources={}),(!t.rebasedCurves||typeof t.rebasedCurves!="object")&&(t.rebasedCurves={}),t.rebasedSources[o]=l.slice(),t.rebasedCurves[o]=l.slice(),t.curves[o]=l.slice()}),Ii(t,null,{source:t._zeroSmoothingCurves,force:!0})),n<=0)try{const o=lt(),s=Array.isArray(o?.channels)?o.channels.slice():null;Ii(t,s,{source:"rebasedSources",force:!0,preserveExistingSnapshot:!0})}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[PlotSmoothing] Failed to prime baseline caches before zero smoothing apply:",o)}(!t._plotSmoothingOriginalCurves||typeof t._plotSmoothingOriginalCurves!="object")&&(t._plotSmoothingOriginalCurves={}),(!t._plotSmoothingOriginalEnds||typeof t._plotSmoothingOriginalEnds!="object")&&(t._plotSmoothingOriginalEnds={});const r=t._plotSmoothingOriginalCurves,i=t._plotSmoothingOriginalEnds;t.baselineEnd&&typeof t.baselineEnd=="object"&&Object.keys(t.baselineEnd).forEach(o=>{typeof i[o]!="number"&&(i[o]=t.baselineEnd[o])});const a=Object.keys(t.curves);if(a.forEach(o=>{const s=Array.isArray(r[o])&&r[o].length>0;!s&&Array.isArray(t.plotBaseCurves?.[o])?r[o]=t.plotBaseCurves[o].slice():!s&&Array.isArray(t.curves?.[o])&&(r[o]=t.curves[o].slice());const l=Array.isArray(t._plotSmoothingBaselineCurves?.[o])?t._plotSmoothingBaselineCurves[o].slice():null,c=Array.isArray(t.rebasedSources?.[o])?t.rebasedSources[o].slice():null;let u=Array.isArray(r[o])&&r[o].length?r[o].slice():null;const d=Array.isArray(t.curves?.[o])?t.curves[o].slice():null;if(n<=0&&(!Array.isArray(u)||u.length===0)){const y=Array.isArray(t._zeroSmoothingCurves?.[o])?t._zeroSmoothingCurves[o]:null;y&&y.length&&(u=y.slice(),r[o]=u.slice())}if(n<=0&&Array.isArray(t._zeroSmoothingCurves?.[o])&&(u=t._zeroSmoothingCurves[o].slice(),r[o]=u.slice()),!u&&Array.isArray(c)&&(u=c.slice(),r[o]=u.slice()),n<=0&&Array.isArray(d)){const y=Array.isArray(u)&&u.length?u.reduce((A,w)=>w>A?w:A,0):0,v=d.reduce((A,w)=>w>A?w:A,0);(!Array.isArray(u)||v>y+.5)&&(u=d.slice(),r[o]=u.slice())}if(!u&&Array.isArray(l)&&(u=l.slice(),r[o]=u.slice()),!u&&Array.isArray(d)&&(u=d.slice(),r[o]=u.slice()),!u)return;let p=typeof i[o]=="number"?i[o]:typeof t.baselineEnd?.[o]=="number"?t.baselineEnd[o]:Math.max(...u);if(!Number.isFinite(p)||p<=0){const y=Math.max(...u);p=Number.isFinite(y)&&y>0?y:0,i[o]=p}if(Number.isFinite(t.channelPeaks?.[o])&&t.channelPeaks[o],n<=0||p<=0){let y=u.slice();const v=y.reduce((w,M)=>M>w?M:w,0);n<=0&&p>0&&Math.abs(v-p)>.5&&(y=vu(y,p));const A=bc(y);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[PlotSmoothing] curve restore",o,{storedMax:Math.max(...u),targetEnd:p,currentMax:Array.isArray(d)?Math.max(...d):null}),t.curves[o]=A.slice(),t.rebasedCurves||(t.rebasedCurves={}),t.rebasedSources||(t.rebasedSources={}),t.rebasedCurves[o]=A.slice(),t.rebasedSources[o]=A.slice(),t.baselineEnd&&Number.isFinite(p)&&(t.baselineEnd[o]=p),(!t.plotBaseCurves||typeof t.plotBaseCurves!="object")&&(t.plotBaseCurves={}),t.plotBaseCurves[o]=A.slice(),(!t._plotSmoothingBaselineCurves||typeof t._plotSmoothingBaselineCurves!="object")&&(t._plotSmoothingBaselineCurves={}),t._plotSmoothingBaselineCurves[o]=A.slice(),r[o]=A.slice(),i[o]=p;return}const f=gc(ev(u,n),u),h=aD(f,p),g=sD(h,u,{windowSize:nv}),b=oD(g,u,p,{windowSize:tv}),S=gc(b,u),E=bc(S);t.curves[o]=E.slice(),t.rebasedCurves||(t.rebasedCurves={}),t.rebasedSources||(t.rebasedSources={}),t.rebasedCurves[o]=E.slice(),n<=0?t.rebasedSources[o]=E.slice():Array.isArray(t.rebasedSources[o])||(t.rebasedSources[o]=u.slice()),t.baselineEnd&&Number.isFinite(p)&&(t.baselineEnd[o]=p),(!t.plotBaseCurves||typeof t.plotBaseCurves!="object")&&(t.plotBaseCurves={}),(!t._plotSmoothingOriginalCurves||typeof t._plotSmoothingOriginalCurves!="object")&&(t._plotSmoothingOriginalCurves={}),n<=0&&(t.plotBaseCurves[o]=E.slice(),t._plotSmoothingOriginalCurves[o]=E.slice())}),n<=0){try{Ii(t,a,{source:"curves",force:!0})}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[PlotSmoothing] Failed to synchronize baselines after zero smoothing apply:",o)}try{const o=t._zeroSmoothingCurves,s=t._zeroSmoothingSignature||null,l=typeof D?.getGlobalData=="function"&&D.getGlobalData()?.filename||null,c=!s||!l||s===l,u=d=>Array.isArray(d)?d.reduce((p,f)=>f>p?f:p,0):0;if(o&&typeof o=="object"&&c){let d=!1;if(Object.entries(o).forEach(([p,f])=>{if(!Array.isArray(f)||!f.length)return;const h=u(f),g=u(t.curves?.[p]);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[PlotSmoothing] zero-check",p,{snapshotMax:h,currentMax:g}),h>0&&Math.abs(g-h)>.5&&(d=!0)}),d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[PlotSmoothing] Reapplying zero-smoothing snapshot to restore baseline amplitude."),Object.entries(o).forEach(([f,h])=>{if(!Array.isArray(h))return;const g=h.slice();t.curves[f]=g.slice(),(!t.rebasedCurves||typeof t.rebasedCurves!="object")&&(t.rebasedCurves={}),t.rebasedCurves[f]=g.slice(),(!t.rebasedSources||typeof t.rebasedSources!="object")&&(t.rebasedSources={}),t.rebasedSources[f]=g.slice()}),Ii(t,null,{source:o,force:!0}),t._zeroSmoothingReapplied=!0;const p=Ms(t);if(p&&typeof D?.setGlobalBaselineCurves=="function")try{D.setGlobalBaselineCurves(p)}catch(f){console.warn("[PlotSmoothing] Failed to push zero-snapshot baseline curves:",f)}}else t._zeroSmoothingReapplied&&(t._zeroSmoothingReapplied=!1)}}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[PlotSmoothing] Failed to validate zero-smoothing snapshot during reset:",o)}}try{Be()}catch(o){console.warn(o)}try{Fn()}catch(o){console.warn(o)}try{(lt()?.channels||a).forEach(l=>{try{un(l)}catch(c){console.warn(c)}})}catch(o){console.warn(o)}try{yt()}catch(o){console.warn(o)}try{Co()}catch(o){console.warn(o)}hc()}const yc=Ns(()=>{is(lo())},250),Hg=Ns(()=>{try{if(!D?.isGlobalEnabled?.())return;const e=D.getGlobalData?.();if(!e||!pr(e))return;const t=lt(),n=Array.isArray(t?.channels)?t.channels.slice():[];if(!n.length)return;Is(n,{source:"compositeWeightingChange",useOriginalBaseline:!0})}catch(e){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[CompositeWeighting] Failed to refresh after weighting change:",e)}},200);function qg(){const e=Ee?.();e&&(e._plotSmoothingOriginalCurves={},e._plotSmoothingOriginalEnds={})}function km(e){const t=Ee?.();if(!t||!t.curves)return;const n={};Object.entries(t.curves).forEach(([r,i])=>{Array.isArray(i)&&(n[r]=i.slice())}),t._zeroSmoothingCurves=n,t._zeroSmoothingSignature=typeof e=="string"&&e.trim()?e.trim():null,t._zeroSmoothingRestored=!1}function la(e){const t=Ee?.();if(!t||!t._zeroSmoothingCurves)return!1;const n=typeof e=="string"&&e.trim()?e.trim():null;if(n&&t._zeroSmoothingSignature&&t._zeroSmoothingSignature!==n)return!1;const r=Jp(t._zeroSmoothingCurves,{skipRefresh:!1,skipScaleBaselineUpdate:!0});if(r&&t){if(t._zeroSmoothingRestored=!0,(!t.plotBaseCurves||typeof t.plotBaseCurves!="object")&&(t.plotBaseCurves={}),(!t._plotSmoothingOriginalCurves||typeof t._plotSmoothingOriginalCurves!="object")&&(t._plotSmoothingOriginalCurves={}),(!t._plotSmoothingOriginalEnds||typeof t._plotSmoothingOriginalEnds!="object")&&(t._plotSmoothingOriginalEnds={}),(!t._plotSmoothingBaselineCurves||typeof t._plotSmoothingBaselineCurves!="object")&&(t._plotSmoothingBaselineCurves={}),Object.entries(t.curves||{}).forEach(([a,o])=>{if(!Array.isArray(o))return;const s=o.slice(),l=s.reduce((c,u)=>u>c?u:c,0);t.plotBaseCurves[a]=s.slice(),Qp(t,a,s),t._plotSmoothingOriginalCurves[a]=s.slice(),t._plotSmoothingBaselineCurves[a]=s.slice(),Number.isFinite(l)&&(t._plotSmoothingOriginalEnds[a]=l,t.baselineEnd&&typeof t.baselineEnd=="object"&&(t.baselineEnd[a]=l))}),Ii(t,null,{source:"curves",force:!0}),D&&typeof D.setGlobalCorrectedCurves=="function"&&t.correctionMethod!==_n.SIMPLE_SCALING)try{if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const a=t.curves?.K?.slice(0,10);console.log("[ZeroRestore] Setting corrected curves at line 1290 - K first 10:",a)}D.setGlobalCorrectedCurves(t.curves)}catch(a){console.warn("[ZeroSmoothing] Failed to sync corrected curves after restore:",a)}const i=Ms(t);if(i&&D&&typeof D.setGlobalBaselineCurves=="function")try{D.setGlobalBaselineCurves(i)}catch(a){console.warn("[ZeroSmoothing] Failed to sync baseline curves after restore:",a)}}return r}function jg(e=lo()){const t=Number(e),n=Number.isFinite(t)?Math.max(0,Math.min(600,Math.round(t))):lo();if(m.plotSmoothingSlider&&Number(m.plotSmoothingSlider.value)!==n&&(m.plotSmoothingSlider.value=String(n)),m.plotSmoothingValue){const r=Ir(n);m.plotSmoothingValue.textContent=`${n}% (Ã—${r.toFixed(2)})`}}function Tl(e=On()){const t=Number(e),n=Number.isFinite(t)?Math.max(0,Math.min(1,t)):On(),r=Math.round(n*100);m.correctionGainSlider&&Number(m.correctionGainSlider.value)!==r&&(m.correctionGainSlider.value=String(r),m.correctionGainSlider.setAttribute("aria-valuenow",String(r)),m.correctionGainSlider.setAttribute("aria-valuetext",`${r}%`)),m.correctionGainInput&&Number(m.correctionGainInput.value)!==r&&(m.correctionGainInput.value=String(r)),m.correctionGainValue&&(m.correctionGainValue.textContent=`${r}%`)}function cD(){jg(),m.plotSmoothingSlider&&(m.plotSmoothingSlider.addEventListener("input",e=>{const t=Number(e.target.value),n=QE(t);jg(n),yc();const r=Ir(n);Z(`Plot smoothing set to ${n}% (Ã—${r.toFixed(2)})`)}),yc())}function uD(){Tl();const e=m.correctionGainSlider,t=m.correctionGainInput,n=(r,i={})=>{const{showToast:a=!1,forceImmediate:o=!1}=i||{},s=Number(r);if(!Number.isFinite(s))return Tl(),On();const l=om(s,{announce:a,forceImmediate:o});return Tl(l),l};if(e&&(e.addEventListener("input",r=>{n(r.target.value,{showToast:!1})}),e.addEventListener("change",r=>{n(r.target.value,{showToast:!0,forceImmediate:!0})})),t){t.addEventListener("input",i=>{const a=Number(i.target.value);Number.isFinite(a)&&Tl(a/100)});const r=i=>{n(i.target.value,{showToast:!0,forceImmediate:!0})};t.addEventListener("blur",r),t.addEventListener("keydown",i=>{i.key==="Enter"&&(i.preventDefault(),r(i))})}}function Wg(e){if(!e||!Array.isArray(e.originalData)||e.originalData.length<2)return e;const t=rr(),n=Number(Gn()),r=Number.isFinite(n)&&n>0,i=r?Ir(n):1,a=er(e.originalData,{normalizationMode:t,skipDefaultSmoothing:!0,useBaselineWidenFactor:r})||e.baseSamples||e.samples,o=er(e.originalData,{normalizationMode:t,useBaselineWidenFactor:r})||a,s=r&&er(e.originalData,{normalizationMode:t,widenFactor:i})||o.slice(),l={...e,samples:r?s.slice():o.slice(),baseSamples:o.slice(),rawSamples:a.slice(),previewSamples:s.slice(),previewSmoothingPercent:n};return Array.isArray(l.originalSamples)||(l.originalSamples=s.slice()),l}function Dm(){const e=rr(),n=lt()?.channels||[],r=[],i=Number(Gn?.()||0);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[LabNormalization] refreshLinearizationDataForNormalization start",{smoothingPercent:i});const a=D.getGlobalData();if(a&&pr(a)){const d=typeof D.getGlobalBakedMeta=="function"?D.getGlobalBakedMeta():null,p=Wg(a),f=typeof D.getGlobalDataSource=="function"?D.getGlobalDataSource():null;if(D.setGlobalData(p,D.globalApplied,{source:f}),d&&typeof D.setGlobalBakedMeta=="function"&&D.setGlobalBakedMeta(d),nt({linearizationData:p,linearizationApplied:D.globalApplied}),i<=0)try{const h=Ee?.();h&&h._originalBaselineEnd&&(h.baselineEnd={...h._originalBaselineEnd})}catch(h){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to restore original baseline ends before rebase:",h)}if(i>0&&Ri(p,{scope:"global",label:"LAB normalization update",source:"lab-normalization"}),m.globalLinearizationBtn){const h=Pt(p);m.globalLinearizationBtn.setAttribute("data-tooltip",`Loaded: ${p.filename||"LAB Data"} (${h})`)}if(m.globalLinearizationDetails){const h=Pt(p),g=String(p.format||"").split(" ").filter(Boolean).shift()||"",b=g?g.toUpperCase():"",S=[];h&&S.push(h),b&&S.push(`(${b})`),m.globalLinearizationDetails.textContent=S.length?` - ${S.join(" ")}`:""}if(i>0)try{const h=Ee?.(),g=typeof p.filename=="string"&&p.filename.trim()?p.filename.trim():null;h&&(!h._zeroSmoothingCurves||h._zeroSmoothingSignature!==g)&&km(p.filename)}catch(h){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to capture zero-smoothing snapshot before widening:",h)}r.push(...n)}n.forEach(d=>{const p=D.getPerChannelData(d);if(p&&pr(p)){const f=Wg(p),h=D.isPerChannelEnabled(d);if(D.setPerChannelData(d,f,h),Yi(d,f),i>0&&Ri(f,{scope:"channel",channelName:d,label:`${d} LAB normalization`,source:"lab-normalization"}),i<=0)try{const g=Ee?.();if(g&&g._originalBaselineEnd&&typeof g._originalBaselineEnd=="object"){const b=g._originalBaselineEnd[d];Number.isFinite(b)&&(g.baselineEnd[d]=b)}}catch(g){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to restore per-channel baseline end:",g)}r.includes(d)||r.push(d)}});const o=typeof Ee=="function"?Ee():null,s=i<=0&&o&&o._zeroSmoothingCurves&&Object.keys(o._zeroSmoothingCurves).length>0&&a&&typeof a.filename=="string"&&a.filename.trim().length>0;if(console.log("[LabNormalization] zeroDirectCandidate",{smoothingPercent:i,hasLoadedData:!!o,hasZero:!!(o&&o._zeroSmoothingCurves),zeroCount:o&&o._zeroSmoothingCurves?Object.keys(o._zeroSmoothingCurves).length:0,hasGlobalFilename:!!(a&&a.filename),canRestoreZeroDirectly:s}),s){const d=a.filename.trim();if(la(d)||(is(0),la(d)),Ii(o,null,{source:o._zeroSmoothingCurves,force:!0}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS)try{const f=Object.entries(o._zeroSmoothingCurves||{}).reduce((h,[g,b])=>(Array.isArray(b)&&(h[g]=b.reduce((S,E)=>E>S?E:S,0)),h),{});console.log("[LabNormalization] zero snapshot restore applied",f)}catch(f){console.warn("[LabNormalization] zero snapshot restore log failed:",f)}Be(),yt();try{Co()}catch(f){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to post summary after direct zero restore:",f)}if(hc(),a){const f=typeof Ee=="function"?Ee():null,h=f?.curves?Object.keys(f.curves).filter(g=>{const b=f.curves[g];return Array.isArray(b)&&b.some(S=>S>0)}):[];if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[LabNormalization] After zero restore - activeChannelNames:",h),h.length>0){if(typeof D.setGlobalBakedMeta=="function")try{D.setGlobalBakedMeta(null)}catch(g){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to clear global baked meta after zero restore:",g)}if(Is(h,{source:"labNormalizationChange",useOriginalBaseline:!1,resetEndsToBaseline:!1}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){console.log("[LabNormalization] Applied LAB corrections after zero-smoothing restore");const g=D?.getGlobalCorrectedCurves?.();console.log("[LabNormalization] Corrected curves at end of zero-restore path - K first 10:",g?.K?.slice(0,10))}}}return}if(r.length>0){if(typeof D.setGlobalBakedMeta=="function")try{D.setGlobalBakedMeta(null)}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to clear global baked meta:",d)}try{const d=Ee?.();d&&d.keyPointsMeta&&r.forEach(p=>{const f=d.keyPointsMeta[p];f&&f.bakedGlobal&&delete f.bakedGlobal})}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to scrub baked metadata:",d)}if(Is(r,{source:"labNormalizationChange",useOriginalBaseline:!0,resetEndsToBaseline:!0}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS)try{const d=Ee?.();if(d&&Array.isArray(r)&&r.length){const p=r.reduce((f,h)=>{const g=Array.isArray(d.curves?.[h])?d.curves[h]:null;return g&&(f[h]=g.reduce((b,S)=>S>b?S:b,0)),f},{});console.log("[LabNormalization] post-rebase maxima",p)}}catch(d){console.warn("[LabNormalization] post-rebase maxima log failed:",d)}Be(),yt();try{Co()}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to post summary:",d)}hc()}if(i<=0){try{const d=D.getGlobalData?.();la(d?.filename)||is(0)}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to restore zero-smoothing curves after normalization:",d)}try{const d=Ee?.();if(d&&d._originalBaselineEnd&&typeof d._originalBaselineEnd=="object"){Object.entries(d._originalBaselineEnd).forEach(([f,h])=>{const g=Array.isArray(d.curves?.[f])?d.curves[f]:null,b=Number(h);if(!g||!Number.isFinite(b)||b<=0)return;const S=g.reduce((y,v)=>v>y?v:y,0);if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[LabNormalization] baseline restore check",{channelName:f,currentMax:S,targetEnd:b}),Math.abs(S-b)<=.5){d.baselineEnd&&typeof d.baselineEnd=="object"&&(d.baselineEnd[f]=b),d._plotSmoothingOriginalEnds&&typeof d._plotSmoothingOriginalEnds=="object"&&(d._plotSmoothingOriginalEnds[f]=b);return}const E=vu(g,b);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[LabNormalization] Rescaling baseline",f,{currentMax:S,targetEnd:b,scaledMax:Math.max(...E)}),d.curves[f]=E.slice(),d.rebasedCurves&&typeof d.rebasedCurves=="object"&&(d.rebasedCurves[f]=E.slice()),d.rebasedSources&&typeof d.rebasedSources=="object"&&(d.rebasedSources[f]=E.slice()),d.plotBaseCurves&&typeof d.plotBaseCurves=="object"&&(d.plotBaseCurves[f]=E.slice(),Qp(d,f,E)),d._plotSmoothingOriginalCurves&&typeof d._plotSmoothingOriginalCurves=="object"&&(d._plotSmoothingOriginalCurves[f]=E.slice()),d._plotSmoothingBaselineCurves&&typeof d._plotSmoothingBaselineCurves=="object"&&(d._plotSmoothingBaselineCurves[f]=E.slice()),d._plotSmoothingOriginalEnds&&typeof d._plotSmoothingOriginalEnds=="object"&&(d._plotSmoothingOriginalEnds[f]=b),d.baselineEnd&&typeof d.baselineEnd=="object"&&(d.baselineEnd[f]=b)}),D&&typeof D.setGlobalCorrectedCurves=="function"&&d.correctionMethod!==_n.SIMPLE_SCALING&&D.setGlobalCorrectedCurves(d.curves);const p=Ms(d);p&&D&&typeof D.setGlobalBaselineCurves=="function"&&D.setGlobalBaselineCurves(p)}}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to rescale curves to original baseline:",d)}try{const d=Ee?.();d&&Ii(d,null,{source:"curves",force:!0})}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to synchronize plot smoothing baselines:",d)}try{is(0)}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to reapply zero plot smoothing after normalization:",d)}if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS)try{const d=Ee?.();if(d&&d.curves){const p=Object.entries(d.curves).reduce((f,[h,g])=>(Array.isArray(g)&&(f[h]=g.reduce((b,S)=>S>b?S:b,0)),f),{});console.log("[LabNormalization] after zero plot smoothing apply",p)}}catch(d){console.warn("[LabNormalization] Log after zero smoothing apply failed:",d)}try{const d=D.getGlobalData?.();la(d?.filename)}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Subsequent zero-snapshot restore failed:",d)}try{const d=Ee?.(),p=d&&d._zeroSmoothingCurves&&typeof d._zeroSmoothingCurves=="object"?d._zeroSmoothingCurves:null;if(p){if((!d._plotSmoothingOriginalCurves||typeof d._plotSmoothingOriginalCurves!="object")&&(d._plotSmoothingOriginalCurves={}),(!d.plotBaseCurves||typeof d.plotBaseCurves!="object")&&(d.plotBaseCurves={}),(!d._plotSmoothingOriginalEnds||typeof d._plotSmoothingOriginalEnds!="object")&&(d._plotSmoothingOriginalEnds={}),(!d.curves||typeof d.curves!="object")&&(d.curves={}),(!d.rebasedCurves||typeof d.rebasedCurves!="object")&&(d.rebasedCurves={}),(!d.rebasedSources||typeof d.rebasedSources!="object")&&(d.rebasedSources={}),(!d.baselineEnd||typeof d.baselineEnd!="object")&&(d.baselineEnd={}),Object.entries(p).forEach(([h,g])=>{if(!Array.isArray(g))return;const b=g.slice(),S=b.reduce((E,y)=>y>E?y:E,0);d._plotSmoothingOriginalCurves[h]=b.slice(),d.plotBaseCurves[h]=b.slice(),Qp(d,h,b),d.curves[h]=b.slice(),d.rebasedCurves[h]=b.slice(),d.rebasedSources[h]=b.slice(),Number.isFinite(S)&&S>0&&((!Number.isFinite(d._plotSmoothingOriginalEnds[h])||S>d._plotSmoothingOriginalEnds[h])&&(d._plotSmoothingOriginalEnds[h]=S),d.baselineEnd[h]=S)}),D&&typeof D.setGlobalCorrectedCurves=="function"&&d.correctionMethod!==_n.SIMPLE_SCALING)try{D.setGlobalCorrectedCurves(d.curves)}catch(h){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to push corrected curves after zero snapshot sync:",h)}const f=Ms(d);if(f&&D&&typeof D.setGlobalBaselineCurves=="function")try{D.setGlobalBaselineCurves(f)}catch(h){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to push baseline curves after zero snapshot sync:",h)}}}catch(d){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to synchronize zero snapshot into original curves:",d)}}const l=e===Kt.DENSITY;Z(`Linearization normalization set to ${l?"log-density (optical)":"perceptual L*"}${l?" â€” .quad exports note optical-density mode.":""}`)}const Sc=Ns(()=>{Dm()},250);function Kg(){Oc(m.smartPointDragToggle,Fc)}function dD(){Kg(),m.smartPointDragToggle&&m.smartPointDragToggle.addEventListener("change",e=>{const t=!!e.target.checked;Gf(t),Kg(),Z(t?"Curve point dragging enabled.":"Curve point dragging disabled.")})}function Yg(){Oc(m.correctionOverlayToggle,S0)}function pD(){Yg(),m.correctionOverlayToggle&&m.correctionOverlayToggle.addEventListener("change",e=>{const t=!!e.target.checked;y0(t),Yg(),Z(t?"Correction overlay enabled.":"Correction overlay disabled.")})}function Zp(){if(!m.labSpotMarkersToggle)return;rm();const e=am();m.labSpotMarkersToggle.checked=e,m.labSpotMarkersToggle.setAttribute("aria-checked",String(e))}function fD(){Zp(),m.labSpotMarkersToggle&&m.labSpotMarkersToggle.addEventListener("change",e=>{const t=!!e.target.checked;im(t),Zp();const n=am();n&&t?Z("Measurement spot markers enabled."):!n&&!t&&Z("Measurement spot markers disabled.")})}function Xg(){Oc(m.lightBlockingOverlayToggle,v0)}function mD(){Xg(),m.lightBlockingOverlayToggle&&m.lightBlockingOverlayToggle.addEventListener("change",e=>{const t=!!e.target.checked;nm(t),Xg(),Z(t?"Light blocking overlay enabled.":"Light blocking overlay disabled.")})}function Qg(){Oc(m.inkLoadOverlayToggle,hA)}function hD(){Qg(),m.inkLoadOverlayToggle&&m.inkLoadOverlayToggle.addEventListener("change",e=>{const t=!!e.target.checked;mA(t),Qg(),Z(t?"Ink load overlay enabled.":"Ink load overlay disabled.")})}function gD(){const e=m.inkLoadThresholdInput;if(!e)return;const t=()=>{const r=js();e.value=String(r)},n=(r,{announce:i=!0}={})=>{const a=d0(r);e.value=String(a),i&&Z(`Ink load warning threshold set to ${a}%.`);try{Be()}catch(o){console.warn("Failed to refresh chart after ink load threshold update:",o)}};t(),e.addEventListener("focus",()=>{try{e.select()}catch(r){console.warn("Ink load threshold select failed:",r)}}),e.addEventListener("blur",r=>{n(r.target.value)}),e.addEventListener("keydown",r=>{r.key==="Enter"?(r.preventDefault(),e.blur()):r.key==="Escape"?(r.preventDefault(),t(),e.blur()):(r.key==="ArrowUp"||r.key==="ArrowDown"||r.key==="PageUp"||r.key==="PageDown")&&setTimeout(()=>n(e.value,{announce:!1}),0)}),e.addEventListener("input",r=>{const i=typeof InputEvent<"u"&&r instanceof InputEvent?r:null;i&&typeof i.inputType=="string"&&new Set(["insertText","deleteContentBackward","deleteContentForward","deleteByCut","deleteByDrag","insertFromDrop"]).has(i.inputType)||n(r.target.value,{announce:!1})})}function Ld(){if(!m.compositeDebugToggle)return;const e=ds();m.compositeDebugToggle.checked=e,m.compositeDebugToggle.setAttribute("aria-checked",String(e))}function bD(){Ld(),m.compositeDebugToggle&&(Pl&&(Pl(),Pl=null),Pl=em(()=>{Ld()}),m.compositeDebugToggle.addEventListener("change",e=>{const t=!!e.target.checked;if(Wy(t),Ld(),t)try{DS()}catch(n){console.warn("[CompositeDebug] Failed to replay cached session:",n)}Z(t?"Composite debug overlay enabled.":"Composite debug overlay disabled.")}))}function Zg(){if(!m.redistributionSmoothingToggle)return;const e=Gc();m.redistributionSmoothingToggle.checked=e,m.redistributionSmoothingToggle.setAttribute("aria-checked",String(e))}function yD(){Zg(),m.redistributionSmoothingToggle&&m.redistributionSmoothingToggle.addEventListener("change",e=>{const t=!!e.target.checked;$f(t),Zg(),Z(t?"Redistribution smoothing window enabled.":"Redistribution smoothing window disabled.")})}function Jg(){if(!m.autoRaiseInkToggle)return;const e=Rs();m.autoRaiseInkToggle.checked=e,m.autoRaiseInkToggle.setAttribute("aria-checked",String(e))}function SD(){Jg(),m.autoRaiseInkToggle&&m.autoRaiseInkToggle.addEventListener("change",e=>{const t=!!e.target.checked;Uf(t),Jg(),Z(t?"Auto-raise ink limits enabled.":"Auto-raise ink limits disabled.")})}function Id(){if(!m.compositeWeightingSelect)return;const e=uu();m.compositeWeightingSelect.value=e}function vD(){Id(),m.compositeWeightingSelect&&(xl&&(xl(),xl=null),xl=wS(()=>{Id(),qg(),yc(),Hg()}),m.compositeWeightingSelect.addEventListener("change",e=>{const t=typeof e.target?.value=="string"?e.target.value:"",n=ES(t);Id(),qg(),yc(),Hg();const i={[et.ISOLATED]:"Isolated",[et.NORMALIZED]:"Normalized",[et.MOMENTUM]:"Momentum",[et.EQUAL]:"Equal"}[n]||"Isolated";Z(`Composite weighting set to ${i}.`)}))}function ED(){Vg(),Md(),m.labDensityToggle&&m.labDensityToggle.addEventListener("change",e=>{const t=e.target.checked?Kt.DENSITY:Kt.LSTAR;us(t)}),m.manualLstarDensityToggle&&m.manualLstarDensityToggle.addEventListener("change",e=>{const t=e.target.checked?Kt.DENSITY:Kt.LSTAR;us(t)}),m.labSmoothingSlider&&m.labSmoothingSlider.addEventListener("input",e=>{const t=Number(e.target.value),n=py(t);Md(n),Sc()}),kl&&(kl(),kl=null),kl=Bw(e=>{Vg(e),Dm()}),Dl&&(Dl(),Dl=null),Dl=my(e=>{Md(e),Sc();const t=Ir(e);if(Z(`LAB smoothing set to ${e}% (widen â‰ˆ ${t.toFixed(2)}Ã—).`),(Number(e)||0)<=0)try{const r=D.getGlobalData?.();la(r?.filename),is(0)}catch(r){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabNormalization] Failed to restore zero snapshot on smoothing reset:",r)}})}function kd(e=Dc()){!Array.isArray(m.correctionMethodRadios)||!m.correctionMethodRadios.length||m.correctionMethodRadios.forEach(t=>{if(!t)return;const n=t.value===e;t.checked=n,t.setAttribute("aria-checked",String(n))})}function wD(){kd(),Array.isArray(m.correctionMethodRadios)&&m.correctionMethodRadios.forEach(e=>{e&&e.addEventListener("change",t=>{if(!t.target.checked)return;const n=kE(t.target.value);nt({correctionMethod:n}),kd(n);const r=n===_n.SIMPLE_SCALING?"Correction method set to Simple Scaling (legacy).":"Correction method set to Density Solver (advanced).";Z(r),Sc()})}),wd&&wd(),wd=DE(e=>{nt({correctionMethod:e}),kd(e),Sc()})}function eb(){console.log("ðŸŽ›ï¸ Initializing UI event handlers..."),typeof window<"u"&&tr.setEnabled(!!window.__USE_SCALING_COORDINATOR),CD(),AD(),MD(),LD(),ID(),rv(),kD(),DD(),xD(),BD(),OD(),E1(),ED(),wD(),cD(),uD(),dD(),pD(),fD(),mD(),hD(),gD(),vD(),yD(),SD(),bD(),console.log("âœ… UI event handlers initialized")}function CD(){const e=document.getElementById("undoBtn"),t=document.getElementById("redoBtn");e&&e.addEventListener("click",()=>{if(typeof CurveHistory<"u"){const n=CurveHistory.undo();n.success||Z(`Undo failed: ${n.message}`)}else console.warn("CurveHistory not available - undo functionality requires history module")}),t&&t.addEventListener("click",()=>{if(typeof CurveHistory<"u"){const n=CurveHistory.redo();n.success||Z(`Redo failed: ${n.message}`)}else console.warn("CurveHistory not available - redo functionality requires history module")})}function AD(){m.downloadBtn&&m.downloadBtn.addEventListener("click",()=>{try{if(typeof buildFile>"u"){console.warn("buildFile not available - download functionality requires file building module"),Z("Download functionality not yet available in modular build");return}const e=buildFile(),t=lt();let n;const r=m.filenameInput?.value?.trim()||"";if(r){const i=r.replace(/\.quad$/,""),a=Yo(i);a?(n=a+".quad",a!==i&&Z(`Filename sanitized: ${n}`)):(n=(Yo(t.name.replace(/\s+/g,""))||"quadGEN")+"_linear.quad",Z("Invalid filename, using default"))}else n=(Yo(t.name.replace(/\s+/g,""))||"quadGEN")+"_linear.quad";To(e,n,"text/plain;charset=utf-8"),Z(`Downloaded ${n}`)}catch(e){console.error("Download error:",e),Z("Error downloading file")}})}function MD(){document.addEventListener("keydown",e=>{if(e.ctrlKey||e.metaKey)switch(e.key){case"s":e.preventDefault(),m.downloadBtn&&m.downloadBtn.click();break;case"r":e.preventDefault(),typeof nn<"u"&&nn();break}})}function LD(){m.printerSelect&&m.printerSelect.addEventListener("change",e=>{Su(e.target.value)})}function ID(){m.filenameInput&&m.filenameInput.addEventListener("input",e=>{const t=e.target,n=t.value.trim();if(n!==ws()?t.dataset.userEdited="true":delete t.dataset.userEdited,n){const r=n.replace(/\.quad$/,""),i=Yo(r),a=i!==r;t.classList.toggle("border-yellow-300",a),t.classList.toggle("bg-yellow-50",a),t.classList.toggle("border-gray-300",!a),t.classList.toggle("bg-white",!a),a?t.title=`Will be saved as: ${i}.quad`:t.title=""}else t.classList.remove("border-yellow-300","bg-yellow-50"),t.classList.add("border-gray-300","bg-white"),t.title=""})}function rv(){if(!m.scaleAllInput&&mn&&(m.scaleAllInput=document.getElementById("scaleAllInput")),!m.scaleAllInput){mn&&Bl<X1?(Bl+=1,ze.setTimeout(()=>{rv()},50*Bl)):console.warn("Scale handlers unable to locate #scaleAllInput element. Dual-read subscription not initialized.");return}Bl=0,mn&&!Gg&&(ze.addEventListener(Jl,()=>{console.log("ðŸ” [SCALE STATE] flag event received",ze.__USE_SCALING_STATE),Ug()}),Gg=!0,ze.__scalingStateListenerReady=!0),Ug(),nf();const e=1,t=1e3;let n=null;const r=(o,s=!1)=>{if(console.log("ðŸ” [SCALE DEBUG] commitScaleAll called:",{raw:o,immediate:s,timestamp:Date.now(),callStack:new Error().stack.split(`
`).slice(1,4)}),!m.scaleAllInput){console.log("ðŸ” [SCALE DEBUG] No scaleAllInput element found");return}const l=Tc(lt()?.channels||[]);if(l.length>0){const h=Of(l);Z(h),m.scaleAllInput.value=Jn(Ut()),nf();return}let c=parseFloat(o);if(console.log("ðŸ” [SCALE DEBUG] Parsed value:",{raw:o,parsed:c}),!Number.isFinite(c)){console.warn("ðŸ” [SCALE DEBUG] Invalid scale value:",o),m.scaleAllInput.value="100";return}const u=c;c=Math.max(e,Math.min(t,c)),console.log("ðŸ” [SCALE DEBUG] After clamping:",{beforeClamp:u,afterClamp:c}),n&&(console.log("ðŸ” [SCALE DEBUG] Clearing existing debounce timeout:",n),clearTimeout(n),n=null);const d=Ut(),p=Math.abs(c-d)>1e-4;if(console.log("ðŸ” [SCALE DEBUG] Change detection:",{parsed:c,currentScale:d,difference:Math.abs(c-d),needsChange:p,threshold:1e-4}),!p){console.log("ðŸ” [SCALE DEBUG] No change needed - updating input only"),m.scaleAllInput.value=c.toString();return}m.scaleAllInput.value=c.toString(),console.log("ðŸ” [SCALE DEBUG] Input value updated to:",c.toString());const f=h=>{console.error("Scaling coordinator error:",h),m.scaleAllInput&&(m.scaleAllInput.value=Jn(Ut()))};s?(console.log(`ðŸ” [SCALE DEBUG] Executing immediate scaling via coordinator (${c})`),tr.scale(c,"ui",{priority:"high",metadata:{trigger:"commitScaleAllImmediate"}}).then(()=>Ls()).catch(f)):(console.log("ðŸ” [SCALE DEBUG] Setting up debounced coordinator scaling for:",c),n=setTimeout(()=>{console.log(`ðŸ” [SCALE DEBUG] Executing debounced coordinator scaling (${c})`),tr.scale(c,"ui",{metadata:{trigger:"commitScaleAllDebounce"}}).then(()=>Ls()).catch(f)},100),console.log("ðŸ” [SCALE DEBUG] Coordinator debounce timeout set:",n))};m.scaleAllInput.addEventListener("focus",o=>{console.log("ðŸ” [EVENT DEBUG] Scale input FOCUS event"),m.scaleAllInput&&m.scaleAllInput.select()});let i=!1;m.scaleAllInput.addEventListener("blur",o=>{if(console.log("ðŸ” [EVENT DEBUG] Scale input BLUR event:",{value:o.target.value,enterJustPressed:i,timestamp:Date.now()}),i){console.log("ðŸ” [EVENT DEBUG] Skipping blur processing - Enter was just pressed"),i=!1;return}console.log(`ðŸ” [EVENT DEBUG] Processing blur - calling commitScaleAll("${o.target.value}", false)`),r(o.target.value)}),m.scaleAllInput.addEventListener("keydown",o=>{if(console.log("ðŸ” [EVENT DEBUG] Scale input KEYDOWN event:",{key:o.key,value:o.target.value,timestamp:Date.now()}),o.key==="Enter")console.log("ðŸ” [EVENT DEBUG] Enter key pressed - preventing default and setting enterJustPressed flag"),o.preventDefault(),i=!0,console.log(`ðŸ” [EVENT DEBUG] Calling commitScaleAll("${o.target.value}", true) for Enter`),r(o.target.value,!0),console.log("ðŸ” [EVENT DEBUG] Calling blur() after Enter processing"),o.target.blur();else if(o.key==="Escape"){console.log("ðŸ” [EVENT DEBUG] Escape key pressed - resetting to current scale"),o.preventDefault();const s=Ut();console.log("ðŸ” [EVENT DEBUG] Resetting to current scale:",s),m.scaleAllInput.value=s.toString(),o.target.blur()}else(o.key==="ArrowUp"||o.key==="ArrowDown"||o.key==="PageUp"||o.key==="PageDown")&&(console.log("ðŸ” [EVENT DEBUG] Arrow/Page key pressed:",o.key),n&&(console.log("ðŸ” [EVENT DEBUG] Clearing existing debounce timeout for arrow key"),clearTimeout(n),n=null),console.log("ðŸ” [EVENT DEBUG] Setting up next-frame commit for arrow key"),setTimeout(()=>{console.log("ðŸ” [EVENT DEBUG] Executing next-frame commit for arrow key - value:",m.scaleAllInput.value),r(m.scaleAllInput.value)},0))});let a=null;m.scaleAllInput.addEventListener("input",o=>{console.log("ðŸ” [EVENT DEBUG] Scale input INPUT event:",{value:o.target.value,inputType:o.inputType,timestamp:Date.now()});const s=parseFloat(o.target.value),l=Number.isFinite(s)&&s>=e&&s<=t;console.log("ðŸ” [EVENT DEBUG] Input validation:",{value:s,isValid:l,minScale:e,maxScale:t}),o.target.classList.toggle("border-red-300",!l),o.target.classList.toggle("border-gray-300",l),l&&(a&&clearTimeout(a),a=setTimeout(()=>{console.log("ðŸ” [EVENT DEBUG] Debounced input scaling - value:",s),tr.scale(s,"ui-input",{metadata:{trigger:"inputDebounce"}}).catch(c=>{console.error("Scaling coordinator input error:",c),m.scaleAllInput&&(m.scaleAllInput.value=Jn(Ut()))})},150)),console.log(`ðŸ” [EVENT DEBUG] Input event - real-time scaling ${l?"enabled":"disabled"}`)})}function kD(){m.chartZoomInBtn&&m.chartZoomInBtn.addEventListener("click",()=>{pp(1)}),m.chartZoomOutBtn&&m.chartZoomOutBtn.addEventListener("click",()=>{pp(-1)}),m.aiLabelToggle&&m.aiLabelToggle.addEventListener("change",()=>{typeof updateChartLabels<"u"&&updateChartLabels()})}function DD(){m.rows&&(m.rows.addEventListener("input",e=>{const t=e.target;t.classList.contains("percent-input")?ef(t,{commit:!1}):t.classList.contains("end-input")&&tf(t,{commit:!1})}),m.rows.addEventListener("change",e=>{const t=e.target;t.classList.contains("percent-input")?ef(t,{commit:!0}):t.classList.contains("end-input")&&tf(t,{commit:!0})}),m.rows.addEventListener("channelsChanged",()=>{typeof nn<"u"&&nn()}))}function Eu(e){if(!e)return 0;const t=e.getAttribute("data-base-percent");return q.clampPercent(t!==null?t:e.value)}function wu(e){if(!e)return 0;const t=e.getAttribute("data-base-end");return q.clampEnd(t!==null?t:e.value)}function wr(e,t){if(!e)return;const n=q.clampPercent(t);e.setAttribute("data-base-percent",String(n))}function Cr(e,t){if(!e)return;const n=q.clampEnd(t);e.setAttribute("data-base-end",String(n))}function iv(e){if(!e)return{percent:0,end:0};const t=e.querySelector(".percent-input"),n=e.querySelector(".end-input");return{percent:Eu(t),end:wu(n)}}function av(e,t){if(!e||!t)return;const n=e.querySelector(".percent-input"),r=e.querySelector(".end-input"),i=n?q.clampPercent(n.value):0,a=r?q.clampEnd(r.value):0;if(e.dataset.originalPercent||(e.dataset.originalPercent=String(i)),e.dataset.originalEnd||(e.dataset.originalEnd=String(a)),typeof at=="function")try{const o=at();o?.get(`printer.channelOriginalValues.${t}`)||o.set(`printer.channelOriginalValues.${t}`,{percent:i,end:a},{skipHistory:!0,allowDuringRestore:!0})}catch(o){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[INK SNAPSHOT] Unable to persist original values for",t,o)}}function vc(e,t){e&&(e.dataset.pendingCommitValue=String(t),e.dataset.pendingCommitTimestamp=String(Date.now()))}function vr(e){e&&(delete e.dataset.pendingCommitValue,delete e.dataset.pendingCommitTimestamp)}function Mr(e){if(!Number.isFinite(e))return"0";const t=Math.round(e);return Math.abs(e-t)<.05?String(t):Number(e.toFixed(1)).toString()}function Ol(e,t,n=.5){if(!e)return{hold:!1,value:null};if(e.dataset.userEditing==="true"){const o=Number(e.value);return{hold:!0,value:Number.isFinite(o)?o:t}}const r=e.dataset.pendingCommitValue;if(r==null)return{hold:!1,value:null};const i=Number(r);return Number.isFinite(i)?Math.abs(i-Number(t))<=n?(vr(e),{hold:!1,value:null}):{hold:!0,value:i}:(vr(e),{hold:!1,value:null})}function Ls(){if(!m.rows||typeof bs=="function"&&bs())return;m.rows.querySelectorAll("tr.channel-row[data-channel]").forEach(t=>{const n=t.getAttribute("data-channel");if(!n)return;const r=t.querySelector(".percent-input"),i=t.querySelector(".end-input");if(!r||!i)return;const a=r?.dataset.userEditing==="true",o=i?.dataset.userEditing==="true";if(av(t,n),a||o)return;const s=Eu(r),l=wu(i);if(l<=0||s<=0){const c=q.clampPercent(s),u=q.clampEnd(l),d=Ol(r,c,.01),p=Ol(i,u,.25),f=Number.isFinite(d.value)?d.value:c,h=Number.isFinite(p.value)?p.value:u;!a&&!d.hold&&(r.value=Mr(f)),!o&&!p.hold&&(i.value=String(Math.round(h))),wr(r,f),Cr(i,h);return}try{const c=Yt(l,n,!0),u=Math.max(...c),d=q.clampEnd(Math.round(u)),p=q.computePercentFromEnd(d),f=Ol(r,p,.01),h=Ol(i,d,.25),g=Number.isFinite(f.value)?f.value:p,b=Number.isFinite(h.value)?h.value:d;!a&&!f.hold&&(r.value=Mr(g)),!o&&!h.hold&&(i.value=String(Math.round(b))),wr(r,g),Cr(i,b);try{const S=$t(()=>({curves:{},baselineEnd:{},sources:{},keyPoints:{},keyPointsMeta:{},rebasedCurves:{},rebasedSources:{}}));if(S){let y=(Array.isArray(c)?c.slice():[]).slice();if(h.hold&&Array.isArray(y)&&y.length){const v=Math.max(...y),A=Number.isFinite(b)?b:v;if(v>0&&Number.isFinite(A)&&A>=0&&Math.abs(v-A)>.25){const w=A/v;y=y.map(M=>{if(!Number.isFinite(M))return 0;const I=M*w;return Math.max(0,Math.min(ve,Math.round(I)))})}}S.curves=S.curves||{},S.curves[n]=y,S.baselineEnd=S.baselineEnd||{},S.baselineEnd[n]=b,S.rebasedCurves=S.rebasedCurves||{},S.rebasedCurves[n]=Array.isArray(y)?y.slice():[],S.rebasedSources=S.rebasedSources||{},(!Array.isArray(S.rebasedSources[n])||!S.rebasedSources[n].length)&&(S.rebasedSources[n]=Array.isArray(y)?y.slice():[])}}catch(S){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[INK DISPLAY] Unable to update loadedData baselines for",n,S)}if(typeof at=="function")try{const S=at(),E={skipHistory:!0,allowDuringRestore:!0};S.setChannelValue(n,"percentage",Number(g),E),S.setChannelValue(n,"endValue",Math.round(b),E),S.setChannelEnabled(n,b>0,E)}catch(S){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[INK DISPLAY] Failed to sync state for",n,S)}}catch(c){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[INK DISPLAY] Failed to compute effective ink for",n,c)}})}function Is(e=[],t={}){if(!Array.isArray(e)||e.length===0)return;const n=$t(()=>({curves:{},baselineEnd:{},sources:{},keyPoints:{},keyPointsMeta:{},rebasedCurves:{},rebasedSources:{}}));n.rebasedCurves||(n.rebasedCurves={}),n.rebasedSources||(n.rebasedSources={}),n.baselineEnd||(n.baselineEnd={});const r=typeof at=="function"?at():null,i=[],o=gt()?.correctionMethod||Dc(),s=D.getGlobalData?.(),u=!!(o===_n.SIMPLE_SCALING&&s&&pr(s)&&Array.isArray(s.originalData)&&s.originalData.length>=2),d=t.source==="globalLoad"||t.source==="globalToggle",p=typeof t.globalAppliedState=="boolean"?t.globalAppliedState:void 0,f=!!t.useOriginalBaseline,h=!!t.skipScaleBaselineUpdate,g=[];if(e.forEach(k=>{const N=$r(k);if(!N)return;const F=N.querySelector(".percent-input"),U=N.querySelector(".end-input");if(!F||!U)return;const j=t.source==="perChannelLoad"&&D.getPerChannelData?.(k)||null;if(d)try{if(n?.keyPointsMeta&&n.keyPointsMeta[k]&&delete n.keyPointsMeta[k].bakedGlobal,typeof Sr=="function"&&Sr(null,{skipHistory:!0}),typeof D?.setGlobalBakedMeta=="function"){const G=D.getGlobalBakedMeta?.();if(G&&Array.isArray(G.channels)){const V=G.channels.filter(K=>K!==k);V.length!==G.channels.length&&D.setGlobalBakedMeta({...G,channels:V})}}}catch(G){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[INK REBASE] Failed to clear bakedGlobal metadata during global load:",G)}if(t.source==="perChannelLoad")try{(!n.sources||typeof n.sources!="object")&&(n.sources={});const G=n.sources[k];lu(G)&&delete n.sources[k];const V=typeof j?.format=="string"?j.format.toLowerCase():"";let K="per-channel";j?.is3DLUT?K="per-lut":V.includes("lab")||V.includes("manual")?K="per-lab":V.includes("acv")&&(K="per-acv"),n.sources[k]=K,n.keyPointsMeta&&n.keyPointsMeta[k]&&delete n.keyPointsMeta[k].smartTouched}catch(G){console.warn("[INK REBASE] Failed to normalize source tag for",k,G)}let B=q.clampEnd(U.getAttribute("data-base-end")??U.value);if(t.resetEndsToBaseline){n._originalBaselineEnd||(n._originalBaselineEnd={});let G=n._originalBaselineEnd[k];if(typeof G!="number"&&(Array.isArray(n.originalCurves?.[k])?G=Math.max(...n.originalCurves[k]):typeof n.baselineEnd?.[k]=="number"&&(G=n.baselineEnd[k]),typeof G=="number"&&(n._originalBaselineEnd[k]=G)),typeof G=="number"){B=q.clampEnd(G),n.baselineEnd&&typeof B=="number"&&(n.baselineEnd[k]=B);const V=q.computePercentFromEnd(B);U&&(U.value=String(B),U.setAttribute("data-base-end",String(B)),q.clearValidationStyling(U)),F&&(F.value=Mr(V),F.setAttribute("data-base-percent",String(V)),q.clearValidationStyling(F))}}g.push({channelName:k,row:N,percentInput:F,endInput:U,currentEnd:B,perChannelEntry:j,perChannelToggle:N.querySelector(".per-channel-toggle")}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[LabNormalization] Channel context prepared",k,{currentEnd:B})}),!g.length)return;const b={};g.forEach(k=>{b[k.channelName]=k.currentEnd});const S=!!(D.isGlobalEnabled?.()&&s&&pr(s)),E=m.curveSmoothingMethod?.value||"cubic";let y=0;S&&(s&&typeof s.previewSmoothingPercent=="number"?y=s.previewSmoothingPercent:y=Gn());const v=g.map(k=>k.channelName),A=n0(v),w=t0();typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] preparing begin",{compositeEligible:S,channelCount:g.length,autoDensityCompute:w});const M=Y1(s);M&&(y=0);let I=!1;u||(I=S&&sk({channelNames:g.map(k=>k.channelName),endValues:b,labEntry:s,interpolationType:E,smoothingPercent:y,densityOverrides:A,autoComputeDensity:w,analysisOnly:M})),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[COMPOSITE] begin result",{compositeSessionActive:I,treatAsBakedMeasurement:M}),n.plotBaseCurves={};const _=[];if(g.forEach(k=>{const F=f&&Array.isArray(n?.originalCurves?.[k.channelName])?{preferOriginalBaseline:!0,forceSmartApplied:!1}:void 0,U=Yt(k.currentEnd,k.channelName,!u,F);if(_.push({...k,curve:Array.isArray(U)?U.slice():[]}),i.push(k.channelName),t.source==="perChannelLoad")try{k.perChannelEntry&&D.setPerChannelData(k.channelName,k.perChannelEntry,!1)}catch(j){console.warn("[INK REBASE] Failed to disable per-channel data after rebase:",k.channelName,j)}}),!_.length){D.setGlobalWarnings([]);return}let C=null;if(u&&S&&Array.isArray(s?.originalData))try{const k=Array.isArray(_[0]?.curve)?_[0].curve.length:256,N={};_.forEach(B=>{N[B.channelName]={samples:Array.isArray(B.curve)?B.curve.slice():[],endValue:Number(B.currentEnd)||0,enabled:!0}});const F={};_.forEach(B=>{const G=kr(B.channelName);F[B.channelName]=Number.isFinite(G?.value)?G.value:0});const U=Rs();C=j1({measurements:s.originalData,channels:N,densityWeights:F,options:{resolution:k,allowCeilingLift:U,maxLiftPercent:U?.15:0,residualThreshold:.01,maxIterations:2,residualIntensity:.35,blendPercent:100}});const j={};if(_.forEach(B=>{const G=C.channels?.[B.channelName];if(!G){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[SimpleScaling] No channelResult for",B.channelName);return}const V=Array.isArray(G.samples)?G.samples.slice():B.curve;B.curve=V,B.currentEnd=Number(G.endValue)||V.reduce((se,W)=>W>se?W:se,0);const K=Yt(B.currentEnd,B.channelName,!0,void 0);j[B.channelName]=Array.isArray(K)?K.slice():V.slice(),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&B.channelName==="K"&&(console.log("[SimpleScaling] baseline samples for K:",V?.slice(0,10)),console.log("[SimpleScaling] LAB-corrected for K:",K?.slice(0,10)))}),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const B=j.K?.slice(0,10);console.log("[SimpleScaling] About to set corrected curves - K first 10:",B)}if(D&&typeof D.setGlobalCorrectedCurves=="function"&&(D.setGlobalCorrectedCurves(j),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS)){const B=j.K?.slice(0,10);console.log("[SimpleScaling] Set corrected curves at line 3432 - K first 10:",B)}D&&(D.globalPeakIndices=null,D.setCompositeCoverageSummary?.(null),D.getCompositeDensityProfile=()=>null,D.getCompositeCoverageSummary=()=>null),n.simpleScalingSummary=C.metadata,n.correctionMethod=_n.SIMPLE_SCALING}catch(k){console.warn("[SimpleScaling] Failed to compute simple scaling correction:",k)}else u?n.correctionMethod=_n.SIMPLE_SCALING:(n.correctionMethod=_n.DENSITY_SOLVER,n.simpleScalingSummary&&delete n.simpleScalingSummary);if(!_.length){D.setGlobalWarnings([]);return}let x=[];if(C?.metadata?.residual?.max&&C.metadata.residual.max>.05&&x.push(`Simple scaling residual exceeds ${(C.metadata.residual.max*100).toFixed(1)}% in parts of the range.`),I){const k=pk();k?.curves&&_.forEach(F=>{const U=k.curves[F.channelName];Array.isArray(U)&&(F.curve=U.slice())}),k?.peakIndices&&typeof k.peakIndices=="object"?(n.channelPeaks={...k.peakIndices},D&&typeof D=="object"&&(D.globalPeakIndices={...k.peakIndices})):(delete n.channelPeaks,D&&typeof D=="object"&&delete D.globalPeakIndices);const N=k?.warnings||[];x=N.slice(),N.length&&Z(N[0])}else delete n.channelPeaks,D&&typeof D=="object"&&delete D.globalPeakIndices;const P=lo();if(lD(_,P,n),_.forEach(k=>{const{channelName:N,row:F,percentInput:U,endInput:j,perChannelToggle:B,perChannelEntry:G}=k;let V=k.curve,K=Array.isArray(V)&&V.length?Math.max(...V):0;if(P<=0){const W=(()=>{const fe=Number(n._plotSmoothingOriginalEnds?.[N]);if(Number.isFinite(fe)&&fe>0)return fe;const Se=Number(n._originalBaselineEnd?.[N]);if(Number.isFinite(Se)&&Se>0)return Se;const we=Array.isArray(n._zeroSmoothingCurves?.[N])?n._zeroSmoothingCurves[N]:null;return we&&we.length?we.reduce((Ne,ct)=>ct>Ne?ct:Ne,0):null})();if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[LabNormalization] baseline comparison",{channelName:N,effectiveEnd:K,originalTarget:W}),Number.isFinite(W)&&W>0&&Math.abs(K-W)>.5){const fe=K,Se=vu(V,W);Array.isArray(Se)&&Se.length&&(V=Se.slice(),k.curve=V.slice(),K=Math.max(...V),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[LabNormalization] rescaled curve to original baseline",{channelName:N,originalTarget:W,previousEnd:fe,rescaledEnd:K}))}}const se=q.computePercentFromEnd(K);if(K1("ui.pendingEntry",W=>!Array.isArray(V)||W>=V.length?null:{channel:N,sampleIndex:W,curveValue:V[W],effectiveEnd:K,normalized:K>0?V[W]/K:0}),k.currentEnd=K,n.curves[N]=V.slice(),n.rebasedCurves[N]=V.slice(),P<=0?n.rebasedSources[N]=V.slice():Array.isArray(n.rebasedSources[N])||(n.rebasedSources[N]=V.slice()),n.baselineEnd[N]=K,P<=0&&((!n.plotBaseCurves||typeof n.plotBaseCurves!="object")&&(n.plotBaseCurves={}),n.plotBaseCurves[N]=V.slice(),(!n._plotSmoothingOriginalCurves||typeof n._plotSmoothingOriginalCurves!="object")&&(n._plotSmoothingOriginalCurves={}),n._plotSmoothingOriginalCurves[N]=V.slice()),I){(!n.keyPointsMeta||typeof n.keyPointsMeta!="object")&&(n.keyPointsMeta={});const W=n.keyPointsMeta[N]||{};y>0?W.bakedGlobal=!0:W.bakedGlobal&&delete W.bakedGlobal,n.keyPointsMeta[N]=W}else n?.keyPointsMeta&&n.keyPointsMeta[N]?.bakedGlobal&&(delete n.keyPointsMeta[N].bakedGlobal,typeof Sr=="function"&&Sr(null,{skipHistory:!0}));if(U.value=Mr(se),U.setAttribute("data-base-percent",String(se)),q.clearValidationStyling(U),j.value=String(K),j.setAttribute("data-base-end",String(K)),q.clearValidationStyling(j),F.refreshDisplayFn&&typeof F.refreshDisplayFn=="function"&&F.refreshDisplayFn(),r)try{r.setChannelValue(N,"percentage",se),r.setChannelValue(N,"endValue",K),r.setChannelEnabled(N,K>0)}catch(W){console.warn("[INK REBASE] Failed to sync state manager for",N,W)}if(h||gi(N),t.source==="perChannelLoad"){if(G)try{G.edited=!1}catch{}B&&(B.checked=!1,B.disabled=!0,B.setAttribute("data-baked","true"),B.title="Per-channel correction baked into baseline. Undo or revert to modify.")}}),I||(x=nD(_),x.length&&Z(x[0])),P<=0){(!n._plotSmoothingOriginalCurves||typeof n._plotSmoothingOriginalCurves!="object")&&(n._plotSmoothingOriginalCurves={}),(!n.plotBaseCurves||typeof n.plotBaseCurves!="object")&&(n.plotBaseCurves={});const k=n._zeroSmoothingCurves&&typeof n._zeroSmoothingCurves=="object"?n._zeroSmoothingCurves:null;g.forEach(F=>{const U=Array.isArray(n.rebasedCurves?.[F.channelName])?n.rebasedCurves[F.channelName]:n.curves?.[F.channelName];if(!Array.isArray(U))return;const j=k&&Array.isArray(k[F.channelName])?k[F.channelName]:null,B=Array.isArray(n._plotSmoothingOriginalCurves[F.channelName])?n._plotSmoothingOriginalCurves[F.channelName]:null,G=j?j.slice():B?B.slice():U.slice();n.plotBaseCurves[F.channelName]=G.slice(),(!B||B.length===0||!j&&!k||j)&&(n._plotSmoothingOriginalCurves[F.channelName]=G.slice())});const N=_.map(F=>F.channelName).filter((F,U,j)=>typeof F=="string"&&j.indexOf(F)===U);Ii(n,N,{source:"rebasedCurves",force:!0,preserveExistingSnapshot:!0})}if(D.setGlobalWarnings(x),ht())try{Op()}catch(k){console.warn("[INK REBASE] Failed to refresh Smart curves after rebase:",k)}i.forEach(k=>{try{un(k)}catch(N){console.warn("Processing detail refresh failed for",k,N)}});try{Be()}catch(k){console.warn("[INK REBASE] Chart update failed:",k)}typeof Fn=="function"&&Fn();try{yt()}catch(k){console.warn("[INK REBASE] Session status update failed:",k)}if(d){try{const k=D.getGlobalData?.(),N=p!==void 0?p:!0;if(s&&(s.applied=N),D.globalApplied=N,r&&r.set("linearization.global.applied",N,{skipHistory:!0,allowDuringRestore:!0}),N&&typeof D.setGlobalCorrectedCurves=="function"&&n.correctionMethod!==_n.SIMPLE_SCALING)try{D.setGlobalCorrectedCurves(n.curves),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[INK REBASE] Captured corrected snapshot")}catch(F){console.warn("[INK REBASE] Failed to capture corrected snapshot:",F)}}catch(k){console.warn("[INK REBASE] Failed to ensure global applied state after rebase:",k)}if(I&&y<=0)try{Sr(null,{skipHistory:!0})}catch(k){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[INK REBASE] Failed to clear global baked state for zero smoothing:",k)}y<=0&&s?.filename&&km(s.filename)}P<=0&&((!n._plotSmoothingOriginalCurves||typeof n._plotSmoothingOriginalCurves!="object")&&(n._plotSmoothingOriginalCurves={}),(!n.plotBaseCurves||typeof n.plotBaseCurves!="object")&&(n.plotBaseCurves={}),Object.entries(n.rebasedCurves||{}).forEach(([k,N])=>{Array.isArray(N)&&(n.plotBaseCurves[k]=N.slice(),n._plotSmoothingOriginalCurves[k]=N.slice())})),(!n._plotSmoothingBaselineCurves||typeof n._plotSmoothingBaselineCurves!="object")&&(n._plotSmoothingBaselineCurves={}),Object.entries(n.rebasedCurves||{}).forEach(([k,N])=>{Array.isArray(N)&&(n._plotSmoothingBaselineCurves[k]=N.slice())})}function Ec(e=[],t={}){if(!Array.isArray(e)||e.length===0)return[];const{skipRefresh:n=!1,skipScaleBaselineUpdate:r=!1}=typeof t=="object"&&t!==null?t:{},i=$t(()=>({curves:{},baselineEnd:{},sources:{},keyPoints:{},keyPointsMeta:{},rebasedCurves:{},rebasedSources:{}}));if(!i.rebasedSources)return[];const a=typeof at=="function"?at():null,o=[];return e.forEach(s=>{const l=Array.isArray(i.rebasedSources?.[s])?i.rebasedSources[s]:null;if(!Array.isArray(l)||l.length===0)return;const c=l.slice(),u=c.length?Math.max(...c):0,d=q.computePercentFromEnd(u),p=$r(s);if(p){const f=p.querySelector(".percent-input"),h=p.querySelector(".end-input");if(f&&(f.value=Mr(d),f.setAttribute("data-base-percent",String(d)),q.clearValidationStyling(f)),h&&(h.value=String(u),h.setAttribute("data-base-end",String(u)),q.clearValidationStyling(h)),!n&&p.refreshDisplayFn&&typeof p.refreshDisplayFn=="function")try{p.refreshDisplayFn()}catch(g){console.warn("[INK RESTORE] Failed to refresh row display for",s,g)}}if(i.curves[s]=c.slice(),i.rebasedCurves[s]=c.slice(),i.baselineEnd[s]=u,a)try{a.setChannelValue(s,"percentage",d),a.setChannelValue(s,"endValue",u),a.setChannelEnabled(s,u>0)}catch(f){console.warn("[INK RESTORE] Failed to sync state manager for",s,f)}r||gi(s),o.push(s)}),o}function Jp(e={},t={}){if(!e||typeof e!="object")return!1;const n=Ee?.();if(!n)return!1;const r=Object.keys(e).filter(i=>Array.isArray(e[i]));return r.length?((!n.rebasedSources||typeof n.rebasedSources!="object")&&(n.rebasedSources={}),r.forEach(i=>{const a=e[i];n.rebasedSources[i]=a.slice()}),Ec(r,{skipRefresh:!!t.skipRefresh,skipScaleBaselineUpdate:!!t.skipScaleBaselineUpdate}),!0):!1}function PD(e){if(!Array.isArray(e)||e.length!==2)return!1;const[t,n]=e,r=a=>Math.abs(Number(a)||0)<=1e-4,i=a=>Math.abs((Number(a)||0)-100)<=1e-4;return r(t?.input)&&r(t?.output)&&i(n?.input)&&i(n?.output)}function ov(e,t){if(!e||!Number.isFinite(t))return;const n=Ee();if(!n)return;const r=Array.isArray(n.rebasedCurves?.[e])?n.rebasedCurves[e]:n.curves?.[e],i=n.originalCurves?.[e],a=Array.isArray(r)&&r.length?r:i;if(!Array.isArray(a)||a.length===0)return;const o=n.baselineEnd?.[e],s=Number.isFinite(o)&&o>0?o:Math.max(...a);if(!s||s<=0)return;const l=t<=0?0:t/s;typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[INK LIMIT preserve] scaling",{channelName:e,baselineEnd:s,newEndValue:t,maxBaseline:Math.max(...a)});const c=a.map(p=>{if(!Number.isFinite(p))return 0;const f=l*p;return Number.isFinite(f)?Math.max(0,Math.min(ve,Math.round(f))):0});n.curves||(n.curves={}),n.curves[e]=c,n.rebasedCurves||(n.rebasedCurves={}),n.rebasedCurves[e]=c.slice(),n.baselineEnd||(n.baselineEnd={}),n.baselineEnd[e]=t;const u=n.keyPoints?.[e];n.sources?.[e]==="smart"&&PD(u)&&(n.keyPoints&&delete n.keyPoints[e],n.keyPointsMeta&&delete n.keyPointsMeta[e],n.sources&&delete n.sources[e])}function ef(e,t={}){const n=typeof t=="object"&&t!==null?!!t.commit:!0;let r=e?e.value:"";if(n&&e){const y=e.dataset.initialNumericValue||"",v=y!==""?String(q.clampPercent(y)):"";if(v&&r&&r!==v&&r.startsWith(v)){const A=r.slice(v.length);A&&!Number.isNaN(Number(A))&&(r=A,e.value=A)}}let i=n?q.validatePercentInput(e):q.clampPercent(r);if(!n){const y=typeof Ut=="function"?Ut():100,v=Number(y);if(Number.isFinite(v)&&Math.abs(v-100)>1e-6){const w=Eu(e),M=e?.closest("tr");if(e&&(q.clearValidationStyling(e),e.value=Mr(w)),M){const I=M.querySelector(".end-input");if(I){const _=wu(I);q.clearValidationStyling(I),I.value=String(Math.round(_))}}return e&&wr(e,w),w}if(e&&(q.clearValidationStyling(e),e.dataset.userEditing==="true")){vc(e,i),wr(e,i);const M=e.closest("tr")?.querySelector(".end-input");if(M){const I=q.computeEndFromPercent(i);vc(M,I),Cr(M,I)}}return i}e&&delete e.dataset.userEditing;const a=e.closest("tr");a&&delete a.dataset.userEditing;const o=a?.getAttribute("data-channel");if(o&&Nt(o)){const y=ki(o),v=q.clampPercent(y.percentLimit);e&&(q.clearValidationStyling(e),e.value=Mr(v),wr(e,v),vr(e));const A=a?.querySelector(".end-input");if(A){const w=q.clampEnd(y.endValue);A.value=String(w),Cr(A,w),q.clearValidationStyling(A),vr(A)}return n&&Z(`${o} ink limit is locked. Unlock before editing.`),v}typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[INK LIMIT percentInput]",{channelName:o,validatedPercent:i,rawValue:e?.value}),ze&&(ze.__percentDebug=ze.__percentDebug||[],ze.__percentDebug.push({stage:"validated",channelName:o,value:i})),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[INPUT DEBUG] handlePercentInput called for ${o}, value: ${i}`);let s=null,l=null;if(a){const y=iv(a);s=y.percent,l=y.end}const c=i,u=typeof Ut=="function"?Ut():100,d=Number(u),p=Number.isFinite(d)&&Math.abs(d-100)>1e-6;let f=null;if(p){const y=Number.isFinite(s)&&s>0?s:Number.isFinite(d)&&d>0?d:null;if(y!==null&&Math.abs(c-y)>1e-6)if(i=y,Number.isFinite(l)&&l>0)f=l;else{const v=q.computeEndFromPercent(y);Number.isFinite(v)&&v>0&&(f=v)}}let h=null;if(o)try{h=at?.()??null,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[INPUT DEBUG] State manager exists: ${!!h}`),h&&h.setChannelValue(o,"percentage",i)}catch(y){console.warn("Failed to route percentage through state manager:",y)}let g=null;if(a){const y=a.querySelector(".end-input");if(y&&(f!==null?g=f:g=q.computeEndFromPercent(i),Cr(y,g),y.value=g,q.clearValidationStyling(y),vr(y),o&&h))try{h.setChannelValue(o,"endValue",g)}catch(A){console.warn("Failed to sync end value with state manager:",A)}wr(e,i),ze&&ze.__percentDebug.push({stage:"setBasePercent",channelName:o,value:i}),vr(e);const v=a.getAttribute("data-channel");v&&gi(v),a.refreshDisplayFn&&typeof a.refreshDisplayFn=="function"&&a.refreshDisplayFn()}if(e&&(e.value=Mr(i),typeof e.valueAsNumber=="number"&&(e.valueAsNumber=Number(e.value)),vr(e)),o&&h)try{h.setChannelEnabled(o,i>0)}catch(y){console.warn("Failed to sync channel enabled state with state manager:",y)}const b=Number.isFinite(s)?s:l!==null?q.computePercentFromEnd(l):null;if(o&&Number.isFinite(b)&&b>0&&i>0&&Math.abs(b-i)>1e-6&&tl(o,b,i,{mode:"preserveRelative",historyExtras:{triggeredBy:"percentInput"}}),o&&Number.isFinite(g))try{ov(o,g)}catch(y){console.warn("[INK LIMIT] preserveQuadCurveForInkLimit failed:",y)}const S=typeof Ut=="function"?Ut():100,E=Number(S);Number.isFinite(E)&&Math.abs(E-100)>1e-6&&tr.scale(E,"ui-resync",{metadata:{trigger:"percentInputResync",skipHistory:!0}}).catch(y=>{console.warn("[SCALE] Coordinator resync after percent edit failed:",y)}),Ls(),typeof Fn<"u"&&Fn(),Be(),setTimeout(()=>{try{oS()}catch(y){console.warn("[EDIT MODE] Channel dropdown update failed:",y)}},0)}function tf(e,t={}){const n=typeof t=="object"&&t!==null?!!t.commit:!0;let r=e?e.value:"";if(n&&e){const E=e.dataset.initialNumericValue||"",y=E!==""?String(q.clampEnd(E)):"";if(y&&r&&r!==y&&r.startsWith(y)){const v=r.slice(y.length);v&&!Number.isNaN(Number(v))&&(r=v,e.value=v)}}let i=n?q.validateEndInput(e):q.clampEnd(r);if(!n){const E=typeof Ut=="function"?Ut():100,y=Number(E);if(Number.isFinite(y)&&Math.abs(y-100)>1e-6){const A=wu(e),w=e?.closest("tr");if(e&&(q.clearValidationStyling(e),e.dataset.userEditing!=="true"&&(e.value=String(Math.round(A)))),w){const M=w.querySelector(".percent-input");if(M){const I=Eu(M);q.clearValidationStyling(M),M.dataset.userEditing!=="true"&&(M.value=Mr(I))}}return e&&Cr(e,A),A}if(e&&(q.clearValidationStyling(e),e.dataset.userEditing==="true")){vc(e,i),Cr(e,i);const w=e.closest("tr")?.querySelector(".percent-input");if(w){const M=q.computePercentFromEnd(i);vc(w,M),wr(w,M)}}return i}e&&delete e.dataset.userEditing;const a=e.closest("tr");a&&delete a.dataset.userEditing;const o=a?.getAttribute("data-channel");if(o&&Nt(o)){const E=ki(o),y=q.clampEnd(E.endValue),v=q.clampPercent(E.percentLimit);e&&(q.clearValidationStyling(e),e.value=String(y),Cr(e,y),vr(e));const A=a?.querySelector(".percent-input");return A&&(q.clearValidationStyling(A),A.value=Mr(v),wr(A,v),vr(A)),n&&Z(`${o} ink limit is locked. Unlock before editing.`),y}const s=a?iv(a):{percent:null,end:null};let l=s.percent,c=s.end;const u=i,d=typeof Ut=="function"?Ut():100;if(Number.isFinite(d)&&Math.abs(d-100)>1e-6){let E=Number.isFinite(c)&&c>0?c:null;if(E==null){const y=Number.isFinite(l)&&l>0?l:Number.isFinite(d)&&d>0?d:null;if(y!==null){const v=q.computeEndFromPercent(y);Number.isFinite(v)&&v>0&&(E=v)}}E!==null&&Math.abs(u-E)>.5&&(i=E)}let f=null;if(o)try{f=at?.()??null,f&&f.setChannelValue(o,"endValue",i)}catch(E){console.warn("Failed to route end value through state manager:",E)}let h=null;if(a){const E=a.querySelector(".percent-input");if(E&&(h=q.computePercentFromEnd(i),wr(E,h),ze&&ze.__percentDebug&&ze.__percentDebug.push({stage:"syncPercent",channelName:o,value:h}),E.value=Mr(h),q.clearValidationStyling(E),vr(E),o&&f))try{f.setChannelValue(o,"percentage",Number(h))}catch(v){console.warn("Failed to sync percentage with state manager:",v)}Cr(e,i),vr(e);const y=a.getAttribute("data-channel");y&&gi(y),a.refreshDisplayFn&&typeof a.refreshDisplayFn=="function"&&a.refreshDisplayFn()}if(o&&f)try{f.setChannelEnabled(o,i>0)}catch(E){console.warn("Failed to sync channel enabled state with state manager (end input):",E)}const g=Number.isFinite(l)?l:c!==null?q.computePercentFromEnd(c):null;if(o&&Number.isFinite(g)&&g>0&&Number.isFinite(h)&&h>0&&Math.abs(g-h)>1e-6&&tl(o,g,h,{mode:"preserveRelative",historyExtras:{triggeredBy:"endInput"}}),o&&Number.isFinite(i))try{ov(o,i)}catch(E){console.warn("[INK LIMIT] preserveQuadCurveForInkLimit failed:",E)}const b=typeof Ut=="function"?Ut():100,S=Number(b);Number.isFinite(S)&&Math.abs(S-100)>1e-6&&tr.scale(S,"ui-resync",{metadata:{trigger:"endInputResync",skipHistory:!0}}).catch(E=>{console.warn("[SCALE] Coordinator resync after end edit failed:",E)}),Ls(),typeof Fn<"u"&&Fn(),Be(),setTimeout(()=>{try{oS()}catch(E){console.warn("[EDIT MODE] Channel dropdown update failed:",E)}},0)}function tb(){m.autoWhiteLimitToggle&&m.autoWhiteLimitToggle.addEventListener("change",e=>{const t=!!e.target.checked;try{localStorage.setItem("autoWhiteLimitV1",t?"1":"0")}catch(n){console.warn("Could not save auto white limit preference:",n)}Z(t?"Auto white limit enabled":"Auto white limit disabled");try{(lt()?.channels||[]).forEach(r=>{typeof un<"u"&&un(r)})}catch(n){console.warn("Error updating processing details:",n)}typeof yt<"u"&&yt(),typeof Fn<"u"&&Fn()}),m.autoBlackLimitToggle&&m.autoBlackLimitToggle.addEventListener("change",e=>{const t=!!e.target.checked;try{localStorage.setItem("autoBlackLimitV1",t?"1":"0")}catch(n){console.warn("Could not save auto black limit preference:",n)}Z(t?"Auto black limit enabled":"Auto black limit disabled");try{(lt()?.channels||[]).forEach(r=>{typeof un<"u"&&un(r)})}catch(n){console.warn("Error updating processing details:",n)}typeof yt<"u"&&yt(),typeof Fn<"u"&&Fn()})}function Dd(){const e=m.loadReferenceQuadBtn;if(!e)return;const t=e.dataset.defaultLabel||"â†’ Load Reference",n=vf(),r=zb();if(n&&r?.filename){const i=r.filename,a=i.length>28?`${i.slice(0,25)}â€¦`:i;e.textContent=`Ref âœ“ ${a}`;const o=`Loaded reference: ${i}. Click to clear the reference overlay.`;e.title=o,e.setAttribute("aria-label",o),e.setAttribute("aria-pressed","true"),e.classList.add("ring-2","ring-violet-200")}else{e.textContent=t;const i="Load a reference .quad file (non-editable overlay).";e.title=i,e.setAttribute("aria-label",i),e.setAttribute("aria-pressed","false"),e.classList.remove("ring-2","ring-violet-200")}}function xD(){try{console.log("ðŸ“ Initializing file handlers..."),m.loadQuadBtn?m.loadQuadBtn.addEventListener("click",()=>{console.log("ðŸ“ Load .quad button clicked"),m.quadFile?m.quadFile.click():console.warn("quadFile element not found")}):console.warn("loadQuadBtn element not found"),m.quadFile?m.quadFile.addEventListener("change",async t=>{const n=t.target.files[0];if(n){try{if(console.log("ðŸ“ Processing .quad file:",n.name),!n.name.toLowerCase().endsWith(".quad")){console.error("Please select a .quad file");return}const r=await Ek(n);console.log("ðŸ“ File content read, length:",r.length);const i=Am(r);if(console.log("ðŸ“ Parsed result:",i),!i.valid){console.error(`Error parsing .quad file: ${i.error}`);return}D.clear(),nt({linearizationData:null,linearizationApplied:!1,perChannelLinearization:{}}),mn&&(ze.linearizationData=null,ze.linearizationApplied=!1,ze.perChannelLinearization={},ze.perChannelEnabled={},ze.perChannelFilenames={});const a={...i,filename:n.name},o=Array.isArray(a.channels)&&a.channels.length?a.channels:Object.keys(a.curves||{}),s={};if(o.forEach(l=>{const c=a.curves?.[l];Array.isArray(c)&&(s[l]=c.slice())}),a.originalCurves=s,a.baselineEnd||(a.baselineEnd={},o.forEach(l=>{const c=a.curves?.[l];Array.isArray(c)&&c.length&&(a.baselineEnd[l]=Math.max(...c))})),!a._originalBaselineEnd){const l={};o.forEach(c=>{typeof a.baselineEnd?.[c]=="number"?l[c]=a.baselineEnd[c]:Array.isArray(a.originalCurves?.[c])&&(l[c]=Math.max(...a.originalCurves[c]))}),a._originalBaselineEnd=l}na(a),console.log("ðŸ“ Stored .quad data in global state"),T1(a,{silent:!1}),console.log("âœ… .quad file loaded and applied successfully")}catch(r){console.error("Error loading .quad file:",r)}t.target.value=""}}):console.warn("quadFile element not found"),m.loadReferenceQuadBtn?m.loadReferenceQuadBtn.addEventListener("click",()=>{if(console.log("ðŸ“ Load Reference .quad button clicked"),vf()){const t=jm();m.referenceQuadFile&&(m.referenceQuadFile.value=""),Dd(),Be(),Z(t?`Cleared reference overlay (${t})`:"Cleared reference overlay");return}m.referenceQuadFile?(m.referenceQuadFile.value="",m.referenceQuadFile.click()):console.warn("referenceQuadFile element not found")}):console.warn("loadReferenceQuadBtn element not found"),m.referenceQuadFile?m.referenceQuadFile.addEventListener("change",async t=>{const n=t.target.files?.[0];if(n){try{console.log("ðŸ“ Processing reference .quad file:",n.name);const r=await Ak(n);if(!r.success){console.error("Reference load error:",r.error),Z(r.error),r.warning&&(jm(),Dd());return}XE(r.data),console.log("ðŸ“ Reference .quad loaded:",r.filename);const i=document.getElementById("lightBlockingOverlayToggle");i&&!i.checked&&(i.checked=!0,nm(!0),nt({showLightBlockingOverlay:!0})),Dd(),Be();const a=[`Loaded reference ${r.filename}`,`${r.matchedCount}/${r.totalCount} channels matched`];r.unmatchedCount>0&&a.push(`${r.unmatchedCount} unmatched`),Z(a.join(" Â· "))}catch(r){console.error("Error loading reference .quad file:",r),Z(`Failed to load reference: ${r.message}`)}t.target.value=""}}):console.warn("referenceQuadFile element not found"),m.globalLinearizationBtn?m.globalLinearizationBtn.addEventListener("click",()=>{console.log("ðŸ“ Global linearization button clicked"),m.linearizationFile?m.linearizationFile.click():console.warn("linearizationFile element not found")}):console.warn("globalLinearizationBtn element not found");const e=t=>{const n=D.getGlobalData();if(!n){m.globalLinearizationToggle&&(m.globalLinearizationToggle.checked=!1,m.globalLinearizationToggle.setAttribute("aria-checked","false")),Z("Load a global correction before enabling the toggle.");return}if(D.isGlobalBaked?.()&&!t){m.globalLinearizationToggle&&(m.globalLinearizationToggle.checked=!0,m.globalLinearizationToggle.setAttribute("aria-checked","true")),Z("Global correction is baked into Smart curves. Undo or revert to disable.");return}const r=!!t;D.globalApplied=r,n.applied=r,mn&&(ze.linearizationApplied=r,ze.linearizationData={...n});try{const d=at?.();d&&(d.set("linearization.global.applied",r),d.set("linearization.global.enabled",r),d.set("linearization.global.data",n))}catch(d){console.warn("Failed to sync global linearization state manager flags:",d)}try{nt({linearizationApplied:r,linearizationData:{...n}})}catch(d){console.warn("Failed to update app state for global linearization:",d)}if(m.globalLinearizationToggle&&(m.globalLinearizationToggle.checked=r,m.globalLinearizationToggle.setAttribute("aria-checked",String(r))),r&&ht())try{Op()}catch(d){console.warn("Failed to refresh Smart curves after global toggle:",d)}const a=lt()?.channels||[],o=D.getGlobalData?.(),s=D.getGlobalCorrectedCurves?.(),l=D.getGlobalBaselineCurves?.(),c=typeof o?.previewSmoothingPercent=="number"?o.previewSmoothingPercent:Gn();let u=!1;if(a.length){if(r?s&&(u=Jp(s,{skipScaleBaselineUpdate:!0})):l&&(u=Jp(l,{skipScaleBaselineUpdate:!0})),!u)typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[Global Toggle] Falling back to rebase",{applied:r,hasCorrectedSnapshot:!!s,hasBaselineSnapshot:!!l}),Is(a,{source:"globalToggle",filename:o?.filename||null,useOriginalBaseline:c>0,globalAppliedState:r,skipScaleBaselineUpdate:!0});else if(r&&typeof D.setGlobalCorrectedCurves=="function")try{const d=Ee?.();d?.curves&&D.setGlobalCorrectedCurves(d.curves)}catch(d){console.warn("[Global Toggle] Failed to refresh corrected snapshot after restore:",d)}}try{Be(),typeof nn<"u"&&nn(),(lt()?.channels||[]).forEach(f=>{try{un(f)}catch(h){console.warn(`Failed to refresh processing detail for ${f}:`,h)}}),yt()}catch(d){console.warn("Failed to refresh UI after global toggle:",d)}try{Qr()}catch(d){console.warn("Failed to update revert buttons after global toggle:",d)}Z(r?"Global correction enabled":"Global correction disabled")};if(m.linearizationFile?m.linearizationFile.addEventListener("change",async t=>{const n=t.target.files[0];if(n){try{console.log("ðŸ“ Processing global linearization file:",n.name);const r=n.name.toLowerCase().split(".").pop();let i;r==="acv"?i=await n.arrayBuffer():i=await n.text();const a=await hu(i,n.name);if(a&&a.samples){console.log("âœ… Global linearization file loaded:",n.name),typeof CurveHistory<"u"&&CurveHistory&&typeof CurveHistory.captureState=="function"&&CurveHistory.captureState("Before: Load Global Linearization");const o=Rn(a);o.filename=n.name,D.setGlobalData(o,!0,{source:"external"}),Sr(null,{skipHistory:!0}),nt({linearizationData:o,linearizationApplied:!0}),Zp();try{const l=Ee?.();if(l&&l.originalCurves&&typeof l.originalCurves=="object"){(!l.curves||typeof l.curves!="object")&&(l.curves={}),l.rebasedCurves={},l.rebasedSources={};const c={};Object.entries(l.originalCurves).forEach(([d,p])=>{if(!Array.isArray(p))return;const f=p.slice();l.curves[d]=f.slice(),l.rebasedCurves[d]=f.slice(),l.rebasedSources[d]=f.slice(),c[d]=Math.max(...f)}),Object.keys(c).length&&(l.baselineEnd={...c});const u=Object.keys(l.originalCurves).filter(d=>Array.isArray(l.originalCurves[d]));u.length&&Ec(u,{skipRefresh:!1,skipScaleBaselineUpdate:!0})}}catch(l){console.warn("Failed to restore original curves before applying new global linearization:",l)}try{ic({skipHistory:!0,reason:"globalLinearizationLoad"})}catch(l){console.warn("[GLOBAL LOAD] Failed to reapply existing global scale:",l)}if(Ri(o,{scope:"global",label:"global correction",source:"global-linearization"}),ht()&&Op(),mn&&(ze.linearizationData=o,ze.linearizationApplied=!0),m.globalLinearizationFilename&&(m.globalLinearizationFilename.textContent=n.name),m.globalLinearizationDetails){const l=Pt(o),c=String(o.format||"").split(" ").filter(Boolean).shift()||"",u=c?c.toUpperCase():"",d=[];l&&d.push(l),u&&d.push(`(${u})`),m.globalLinearizationDetails.textContent=d.length?` - ${d.join(" ")}`:""}if(m.globalLinearizationBtn){const l=Pt(o);m.globalLinearizationBtn.setAttribute("data-tooltip",`Loaded: ${n.name} (${l})`)}m.globalLinearizationToggle&&(m.globalLinearizationToggle.disabled=!1,m.globalLinearizationToggle.checked=!0,m.globalLinearizationToggle.setAttribute("aria-checked","true")),m.globalLinearizationInfo&&m.globalLinearizationInfo.classList.remove("hidden"),m.globalLinearizationHint&&m.globalLinearizationHint.classList.add("hidden");try{Qr()}catch{}if(typeof ze.updateInterpolationControls=="function")try{ze.updateInterpolationControls()}catch{}try{const l=Ee?.();if(l){const c=l.originalCurves;if(c&&typeof D.setGlobalBaselineCurves=="function"){const u={};Object.keys(c).forEach(d=>{const p=c[d];Array.isArray(p)&&(u[d]=p.slice())}),Object.keys(u).length&&D.setGlobalBaselineCurves(u)}else{const u=Ms(l);u&&D.setGlobalBaselineCurves(u)}}l&&(delete l.rebasedCurves,delete l.rebasedSources)}catch(l){console.warn("Failed to capture global baseline snapshot:",l)}Be(),typeof yt=="function"&&yt();try{Co()}catch(l){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabTechSummary] Failed to post summary after global load:",l)}hc(),console.log("âœ… Global linearization applied successfully");const s=Pt(o);if(Z(`Loaded global correction: ${n.name} (${s})`),e(!0),Gn()<=0)la(o.filename)||km(o.filename);else{const l=Ee?.();l&&(delete l._zeroSmoothingCurves,delete l._zeroSmoothingSignature,delete l._zeroSmoothingRestored)}try{Dm()}catch(l){console.warn("Failed to refresh normalization after loading global linearization:",l)}typeof CurveHistory<"u"&&CurveHistory&&typeof CurveHistory.captureState=="function"&&CurveHistory.captureState("After: Load Global Linearization (rebased)"),Gn()<=0&&la(o.filename)}else throw new Error("Failed to parse linearization data")}catch(r){console.error("Error loading global linearization file:",r)}t.target.value=""}}):console.warn("linearizationFile element not found"),m.globalLinearizationToggle){const t=m.globalLinearizationToggle;t.addEventListener("change",()=>{e(t.checked)});const n=!!(D.getGlobalData()&&D.globalApplied);t.checked=n,t.setAttribute("aria-checked",String(n))}else console.warn("globalLinearizationToggle element not found");m.revertGlobalToMeasurementBtn?(m.revertGlobalToMeasurementBtn.addEventListener("click",()=>{try{const s=Mo(),{isMeasurement:l,hasSmartEdits:c,wasEdited:u,isBaked:d,globalData:p}=s,f=String(p?.format||"").toUpperCase(),h=Array.isArray(p?.originalData),g=D.isGlobalEnabled(),b=!d&&l&&(c||u);if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[DEBUG REVERT] Button clicked: fmt="${f}", hasData=${!!p}, applied=${g}, hasOriginal=${h}, isMeasurement=${l}, hasSmartEdits=${c}, wasEdited=${u}, isBaked=${d}, shouldRevert=${b}`),!b){d&&Z("Global correction already baked into Smart curves. Use undo to restore measurement."),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Guard check failed - nothing to revert");return}}catch(s){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Guard check error:",s);return}const t=ht()&&typeof EDIT<"u"&&EDIT&&EDIT.selectedChannel?EDIT.selectedChannel:null;try{typeof CurveHistory<"u"&&CurveHistory.captureState("Before: Revert Global to Measurement")}catch(s){console.warn("Failed to capture history state:",s)}const r=lt()?.channels||[],i=Im(r,{skipUiRefresh:!0,forceReinitialize:!0});typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Smart points restored during global revert",i);const a=Ec(r);typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Baselines restored for channels",a);try{ic({skipHistory:!0,reason:"globalRevert"})}catch(s){console.warn("[DEBUG REVERT] Failed to reapply global scale after revert:",s)}const o=document.getElementById("revertGlobalToMeasurementBtn");o&&(o.disabled=!0,o.setAttribute("disabled","disabled")),globalData&&(globalData.edited=!1),globalData&&(D.setGlobalData(globalData,!0,{source:"measurement"}),nt({linearizationData:globalData,linearizationApplied:!0}),mn&&(ze.linearizationData=globalData,ze.linearizationApplied=!0),Sr(null));try{Be(),typeof nn<"u"&&nn(),r.forEach(s=>{try{un(s)}catch(l){console.warn(`Failed to update processing detail for ${s}:`,l)}}),typeof yt<"u"&&yt()}catch(s){console.warn("Failed to refresh UI before revert state sync:",s)}try{Qr(),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Post-reset revert button state refreshed");try{const s=Mo(),l=!s.isBaked&&s.isMeasurement&&(s.hasSmartEdits||s.wasEdited);if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Final global revert state",s),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Final revert state applied",s),!l){const c=document.getElementById("revertGlobalToMeasurementBtn");c&&(c.disabled=!0,c.setAttribute("disabled","disabled"))}}catch(s){console.warn("Failed to enforce final revert button state:",s)}}catch(s){console.warn("Failed to update revert button states:",s)}try{Z("Reverted to measurement (global)")}catch(s){console.warn("Failed to show status after revert:",s)}try{const s=()=>{try{Sr(null,{skipHistory:!0})}catch(l){console.warn("Failed to clear baked state after global revert:",l)}};typeof queueMicrotask=="function"&&queueMicrotask(s),typeof requestAnimationFrame=="function"&&requestAnimationFrame(()=>requestAnimationFrame(s)),setTimeout(s,0),setTimeout(s,16),setTimeout(s,100)}catch(s){console.warn("Failed to schedule baked-state reset after global revert:",s)}try{if(t&&ht()){const s=Array.from(m.rows.children).find(c=>c.getAttribute("data-channel")===t);(s?q.clampEnd(s.querySelector(".end-input")?.value||0):0)>0&&(m.editChannelSelect&&(m.editChannelSelect.value=t),typeof EDIT<"u"&&(EDIT.selectedChannel=t),typeof edit_refreshState=="function"&&edit_refreshState(),Be())}}catch(s){console.warn("Failed to restore Edit Mode selection:",s)}}),console.log("âœ… Global revert button handler initialized")):console.warn("revertGlobalToMeasurementBtn element not found"),console.log("âœ… File handlers initialized")}catch(e){console.error("Error initializing file handlers:",e)}}function BD(){const e=t=>{typeof ze.requestAnimationFrame=="function"?ze.requestAnimationFrame(()=>ze.requestAnimationFrame(t)):setTimeout(t,0)};ND(),mn&&(ze.setContrastIntent=nb),m.contrastIntentSelect?(m.contrastIntentSelect.addEventListener("change",t=>{const n=t.target.value;if(console.log("ðŸŽ¯ Contrast intent changed to:",n),n==="enter_custom"){console.log("ðŸŽ¯ Custom intent modal not yet implemented");const i=gt().contrastIntent?.id||"linear";m.contrastIntentSelect.value=i;return}const r=bu(n);r?e(()=>nb(r.id,r.params,"preset")):console.warn("Unknown intent preset:",n)}),console.log("âœ… Contrast intent dropdown handler initialized")):console.warn("Contrast intent dropdown not found"),m.applyIntentToQuadBtn&&m.applyIntentToQuadBtn.addEventListener("click",()=>{sv()})}function sv(){if(!As()){const f=!!Ee()?.curves,h=!!(D?.getGlobalData?.()&&D.globalApplied);Z(f?h?"Disable or remove global measurement data (LAB/CGATS/TI3) before remapping intent":"Intent remap is currently unavailable":"Load a .quad before remapping intent");return}const e=Ee();if(!e||!e.curves){Z("No curve data available for intent remap");return}const t=Array.isArray(e.channels)&&e.channels.length?[...e.channels]:Object.keys(e.curves);if(!t.length){Z("No channels available for intent remap");return}const n=gt().contrastIntent||{id:"linear",name:"Linear"},r=String(n.id||"linear"),i=n.name||"Linear",a=r==="linear",o=[],s=[],l=ve,c=Ft?.()??null,u=c?c.isBatchOperation:!1;c&&(c.isBatchOperation=!0);try{for(const f of t){const h=e.curves[f];if(!Array.isArray(h)||h.length===0)continue;const g=h.length,b=Math.max(1,g-1),S=h.slice(),E=e.keyPoints?.[f]||null,y=E?E.map(C=>({input:C.input,output:C.output})):null,v=e.keyPointsMeta?.[f]?.interpolationType||null,A=e.sources?.[f];let w;const M=Array.isArray(e.originalCurves?.[f])?e.originalCurves[f]:null;if(a){const C=M;if(!Array.isArray(C)||C.length!==g){console.warn("Intent remap: missing original curve for",f);continue}const P=$r(f)?.querySelector(".end-input"),k=P?q.clampEnd(P.value):l,N=e.baselineEnd?.[f]??Math.max(...C,0),F=N>0?k/N:0;w=C.map(U=>{const j=Math.round(U*F);return Math.max(0,Math.min(l,Number.isFinite(j)?j:0))}),w.length&&(w[0]=Math.max(0,Math.min(l,Math.round(C[0]*F))),w[g-1]=Math.max(0,Math.min(l,Math.round(C[g-1]*F))));try{e.keyPoints?.[f]&&delete e.keyPoints[f],e.keyPointsMeta?.[f]&&delete e.keyPointsMeta[f],e.sources?.[f]&&delete e.sources[f]}catch(U){console.warn("Intent remap: failed clearing Smart metadata for",f,U)}}else{const C=Array.isArray(M)&&M.length===g?M:h,x=new Array(g),P=new Array(g);for(let F=0;F<g;F++)x[F]=b===0?0:F/b,P[F]=ce(C[F]/l);let k=null;try{k=zr(x,P)}catch(F){console.warn("Intent remap: PCHIP creation failed for",f,F)}const N=F=>{const U=ce(F);if(k)try{const K=k(U);if(Number.isFinite(K))return ce(K)}catch(K){console.warn("Intent remap: sampler error for",f,K)}if(U<=0)return P[0];if(U>=1)return P[g-1];const j=U*b,B=Math.floor(j),G=Math.min(g-1,B+1),V=j-B;return ce(P[B]+V*(P[G]-P[B]))};w=new Array(g);for(let F=0;F<g;F++){const U=b===0?0:F/b,j=ce(Hi(U)),B=N(j);w[F]=Math.round(ce(B)*l)}w.length&&(w[0]=Math.max(0,Math.min(l,w[0])),w[g-1]=Math.max(0,Math.min(l,w[g-1])));try{const F=Ar(w,{maxErrorPercent:vn.maxErrorPercent,maxPoints:vn.maxPoints});Te.persist(f,F,v||"smooth");const U=e.keyPointsMeta?.[f];U&&U.bakedGlobal&&delete U.bakedGlobal}catch(F){console.warn("Intent remap: failed to persist key points for",f,F)}}e.curves[f]=w;let I=null,_=null;!a&&e.keyPoints?.[f]&&(I=e.keyPoints[f].map(C=>({input:C.input,output:C.output})),_=e.keyPointsMeta?.[f]?.interpolationType||v||"smooth"),o.push({channelName:f,type:"curve",oldValue:S,newValue:w.slice(),oldKeyPoints:y,newKeyPoints:I,oldInterpolation:v,newInterpolation:_,oldSource:A,newSource:e.sources?.[f]??A,clearKeyPoints:a,linearRestore:a}),s.push(f)}}catch(f){c&&(c.isBatchOperation=u),console.error("Intent remap failed:",f),Z(f?.message?`Intent remap failed: ${f.message}`:"Intent remap failed");return}if(c&&(c.isBatchOperation=u),!o.length){Z("No eligible channel data to remap intent");return}const d=a?"Intent remap â†’ Linear (restore original)":`Intent remap â†’ ${i}`;c?.recordBatchAction&&c.recordBatchAction(d,o);try{nn()}catch(f){console.warn("Intent remap: failed to update preview",f)}try{Be()}catch(f){console.warn("Intent remap: chart update failed",f)}try{fi()}catch(f){console.warn("Intent remap: compact list update failed",f)}try{s.forEach(f=>{try{un(f)}catch(h){console.warn("Intent remap: processing detail update failed for",f,h)}})}catch(f){console.warn("Intent remap: processing detail batch update failed",f)}try{yt()}catch(f){console.warn("Intent remap: session status update failed",f)}Ao(),Z(`Applied ${a?"Linear":i} intent to ${s.length} channel${s.length===1?"":"s"}`)}mn&&(ze.applyIntentToLoadedCurve=sv);function nf(){if(!m?.scaleAllInput)return;const e=typeof lt=="function"?lt():null,t=Tc(e?.channels||[]),n=t.length>0,r=Of(t);m.scaleAllInput.disabled=n,m.scaleAllInput.classList.toggle("bg-gray-50",n),m.scaleAllInput.classList.toggle("cursor-not-allowed",n),n&&r?(m.scaleAllInput.setAttribute("title",r),m.scaleAllInput.dataset.tooltip=r,m.scaleAllInput.setAttribute("aria-disabled","true")):(m.scaleAllInput.removeAttribute("title"),delete m.scaleAllInput.dataset.tooltip,m.scaleAllInput.removeAttribute("aria-disabled"))}function TD(e){if(e&&typeof e._lockCleanup=="function"){try{e._lockCleanup()}catch(B){console.warn("Failed to cleanup existing lock subscription for row",e.dataset?.channel,B)}delete e._lockCleanup}const t=e.querySelector(".percent-input"),n=e.querySelector(".end-input"),r=e.querySelector("[data-disabled]"),i=e.querySelector(".processing-label"),a=e.dataset.channel,o=e.querySelector(".density-input"),s=e.querySelector(".channel-lock-btn"),l={locked:'<svg class="w-3.5 h-3.5 pointer-events-none" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect x="5.5" y="11" width="13" height="9.5" rx="2"></rect><path d="M16 11V8a4 4 0 00-8 0v3"></path><path d="M12 15v2.5"></path></svg>',unlocked:'<svg class="w-3.5 h-3.5 pointer-events-none" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect x="5.5" y="11" width="13" height="9.5" rx="2"></rect><path d="M16 11V8.5a4 4 0 00-7.5-2"></path></svg>'},c=(B,G)=>{if(B)if(G)B.dataset.lockDisabled!=="true"&&(B.dataset.lockDisabled="true",B.dataset.lockPrevDisabled=B.disabled?"true":"false"),B.disabled=!0,B.classList.add("bg-gray-50");else if(B.dataset.lockDisabled==="true"){const V=B.dataset.lockPrevDisabled==="true";B.disabled=V,delete B.dataset.lockPrevDisabled,delete B.dataset.lockDisabled,B.disabled||B.classList.remove("bg-gray-50")}else B.disabled||B.classList.remove("bg-gray-50")},u=t?q.clampPercent(t.value):0,d=n?q.clampEnd(n.value):0,p=Ca(a,{percentLimit:u,endValue:d}),f=B=>{if(!s)return;const G=!!B?.locked;s.innerHTML=G?l.locked:l.unlocked,s.setAttribute("aria-pressed",G?"true":"false"),s.dataset.locked=G?"true":"false";const V=G?"Unlock to allow edits":"Lock to prevent edits";s.dataset.tooltip=V,s.title=V,s.classList.toggle("bg-slate-600",G),s.classList.toggle("text-white",G),s.classList.toggle("border-gray-300",!G),s.classList.toggle("text-gray-600",!G),s.classList.toggle("bg-white",!G),c(t,G),c(n,G),c(o,G),nf()};f(p),Ko(e,kr(a));let h=null;s&&(h=sw(a,f),s.addEventListener("click",()=>{const B=Ft?.(),G=ki(a),V=!!G.locked,K={percentLimit:q.clampPercent(t?t.value:u),endValue:q.clampEnd(n?n.value:d)};if(V||Zl(a,K),Ql(a,!V,K),B&&typeof B.recordChannelAction=="function")try{const W=ki(a);B.recordChannelAction(a,"lock",G.locked,W.locked,{beforeLock:G,afterLock:W})}catch(W){console.warn("[history] Failed to record lock toggle for",a,W)}const se=V?`${a} ink limit unlocked`:`${a} ink limit locked`;Z(se)})),typeof h=="function"&&(e._lockCleanup=h),av(e,a),i?(i.textContent="â†’ Linear ramp",i.setAttribute("title","Linear ramp"),console.log("[status] seeded default label",a)):console.log("[status] no processing label found during setup",a);const g=e.querySelector(".per-channel-btn"),b=e.querySelector(".per-channel-file"),S=e.querySelector(".per-channel-toggle"),E=e.querySelector(".per-channel-revert"),{linearization:y,enabled:v,filenames:A}=rD();let w=y[a]||D.getPerChannelData(a)||null;if(w){y[a]=w,A[a]||(A[a]=w.filename||null);const B=v[a],G=typeof B=="boolean"?B:D.isPerChannelEnabled(a);v[a]=G!==!1,D.setPerChannelData(a,w,v[a]),Yi(a,w)}else v[a]=!1;const M=()=>typeof Ni=="function"&&Ni(a),I=()=>{const B=y[a]||D.getPerChannelData(a)||null;if(B&&y[a]!==B&&(y[a]=B),g)if(B){const Se=ur(A[a]||B.filename||"unknown file",!!B.edited);g.setAttribute("data-tooltip",`Loaded: ${Se}`)}else g.setAttribute("data-tooltip","Load LUT.cube, LABdata.txt, or .acv curve files");const G=!!B,V=Ee()?.sources?.[a]||null,K=M()||V==="smart";G&&e.removeAttribute("data-allow-toggle");const se=e.getAttribute("data-allow-toggle")==="true",W=S?.getAttribute("data-baked")==="true",fe=!W&&(G||K||se);if(S){const Se=G&&v[a]!==!1;S.disabled=!fe||W,S.checked=!W&&G&&Se}E&&(E.disabled=!G&&!K,G?E.title=`Revert ${a} to measurement`:K?E.title=`Clear Smart on ${a}`:E.title="No measurement loaded",E.classList.toggle("invisible",E.disabled),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&a==="MK"&&console.log("[DEBUG REFRESH] MK button state",{hasMeasurement:G,hasSmart:K,disabled:E.disabled}))},_=async B=>{if(!(!B||!g))try{if(typeof CurveHistory<"u"&&CurveHistory&&typeof CurveHistory.captureState=="function"){if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const we=document.querySelector(`[data-channel="${a}"]`),Ne=we?.querySelector(".percent-input"),ct=we?._virtualCheckbox;console.log(`[UNDO DEBUG] Before snapshot for ${a}:`,{percent:Ne?.value,enabled:ct?.checked})}CurveHistory.captureState(`Before: Load Per-Channel Linearization (${a})`)}const V=B.name.toLowerCase().split(".").pop()==="acv"?await B.arrayBuffer():await B.text(),K=await hu(V,B.name),se=Rn(K);if(se.edited=!1,y[a]=se,v[a]=!0,A[a]=B.name,w=se,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[per-channel] parsed 1D LUT",a,{format:se.format,sampleCount:Array.isArray(se.samples)?se.samples.length:"n/a",first:se.samples?.[0],mid:se.samples?.[Math.floor((se.samples?.length||1)/2)],last:se.samples?.[se.samples?.length-1]}),D.setPerChannelData(a,se,!0),Yi(a,se),Ri(se,{scope:"channel",channelName:a,label:`${a} correction`,source:"per-channel-linearization"}),S&&(S.disabled=!1,S.checked=!0),Is([a],{source:"perChannelLoad"}),v[a]=!1,typeof updateInterpolationControls=="function")try{updateInterpolationControls()}catch{}else if(typeof ze.updateInterpolationControls=="function")try{ze.updateInterpolationControls()}catch{}const W=Pt(se)||`${Array.isArray(se.samples)?se.samples.length:0} points`,fe=String(se.format||"").toLowerCase();let Se="";if((fe.includes("lab")||fe.includes("manual"))&&(Se=" (CIE density; Gaussian-weighted reconstruction with PCHIP interpolation)"),se.is3DLUT){const we=Array.isArray(se.samples)?se.samples.length:0,Ne=se.lutSize?` (${se.lutSize}Â³ grid)`:"";Z(`Loaded 3D LUT and extracted ${we} neutral axis points for ${a}${Ne}`)}else Z(`Loaded per-channel correction for ${a}: ${W}${Se}`);if(I(),un(a),Be(),Fn(),typeof ze.reinitializeChannelSmartCurves=="function")try{ze.reinitializeChannelSmartCurves(a)}catch(we){console.warn("[per-channel] Failed to reinitialize Smart Curves for",a,we)}if(yt(),Qr(),typeof CurveHistory<"u"&&CurveHistory&&typeof CurveHistory.captureState=="function")try{CurveHistory.captureState(`After: Load Per-Channel Linearization (${a})`)}catch(we){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[per-channel] Failed to capture After snapshot:",we)}}catch(G){console.error("Per-channel linearization file error:",G),Z(`Error loading ${a} linearization: ${G.message}`),delete y[a],delete A[a],v[a]=!1,w=null,D.clearPerChannel(a),Yi(a,null),S&&(S.disabled=!0,S.checked=!1),I(),un(a),Be(),Ls()}finally{b&&(b.value="")}};g&&g.addEventListener("click",()=>{if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[per-channel] load click",a,{hasInput:!!b}),b){try{b.value=""}catch(B){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[per-channel] unable to reset file input",B)}b.click()}else Z(`Unable to open file picker for ${a} (input missing)`)}),b&&b.addEventListener("change",B=>{const G=B.target?.files?.[0];typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[per-channel] file selected",a,{hasFile:!!G,name:G?.name}),G&&_(G)}),S&&S.addEventListener("change",B=>{const G=y[a]||D.getPerChannelData(a);if(!G){S.checked=!1;return}const V=!!B.target.checked;v[a]=V,D.setPerChannelData(a,G,V),Yi(a,G),Z(V?`Enabled per-channel linearization for ${a}`:`Disabled per-channel linearization for ${a}`),I(),un(a),Be(),Fn(),Qr()}),E&&E.addEventListener("click",()=>{const B=ht()&&typeof EDIT<"u"&&EDIT&&EDIT.selectedChannel?EDIT.selectedChannel:null,G=y[a]||D.getPerChannelData(a)||null,V=!!G,K=M();if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[DEBUG REVERT] Per-channel revert click",{channelName:a,hasMeasurement:V,hasSmart:K,measurementLabel:G?.filename||G?.format||null,linearizationEnabled:D.isPerChannelEnabled(a)}),!V&&!K){Z(`No per-channel measurement to revert for ${a}`);return}$g(!0);try{typeof CurveHistory<"u"&&CurveHistory&&typeof CurveHistory.captureState=="function"&&CurveHistory.captureState(`Before: Revert ${a} to Measurement`);const se=typeof at=="function"?at():null,W=$t(()=>({curves:{},sources:{},keyPoints:{},keyPointsMeta:{},baselineEnd:{},rebasedCurves:{},rebasedSources:{}}));let fe=[];if(V){fe=Ec([a]),e.removeAttribute("data-allow-toggle");try{G.edited=!1}catch{}v[a]=!0,D.setPerChannelData(a,G,!0),Yi(a,G),w=G,typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[DEBUG REVERT] Restoring Smart points for ${a}`);const Se=yu(a,{skipUiRefresh:!0,forceReinitialize:!0});if(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS){const we=Te.get(a)?.points?.length||null;console.log(`[DEBUG REVERT] Post-restore state for ${a}`,{restoredFromSeed:Se?.restoredFromSeed,pointCount:we,rebasedBaselineRestored:fe.includes(a)})}}else{e.setAttribute("data-allow-toggle","true"),v[a]=!1,delete y[a],delete A[a],D.clearPerChannel(a),Yi(a,null),w=null;let Se=!1;const we=W?.originalCurves?.[a];if(Array.isArray(we)&&we.length){const Ne=Math.max(...we),ct=q.computePercentFromEnd(Ne),mt=e.querySelector(".percent-input"),Vt=e.querySelector(".end-input");if(mt&&(mt.value=Mr(ct),mt.setAttribute("data-base-percent",String(ct)),q.clearValidationStyling(mt)),Vt&&(Vt.value=String(Ne),Vt.setAttribute("data-base-end",String(Ne)),q.clearValidationStyling(Vt)),se)try{se.setChannelValue(a,"percentage",ct),se.setChannelValue(a,"endValue",Ne),se.setChannelEnabled(a,Ne>0)}catch(xt){console.warn("[DEBUG REVERT] Failed to sync state manager for original restore on",a,xt)}W.curves=W.curves||{},W.curves[a]=we.slice(),W.rebasedCurves=W.rebasedCurves||{},W.rebasedCurves[a]=we.slice(),W.rebasedSources&&W.rebasedSources[a]&&delete W.rebasedSources[a],W.baselineEnd=W.baselineEnd||{},W.baselineEnd[a]=Ne,gi(a),Se=!0}else W.curves?.[a]&&delete W.curves[a],W.rebasedCurves?.[a]&&delete W.rebasedCurves[a],W.baselineEnd?.[a]&&delete W.baselineEnd[a],W.rebasedSources?.[a]&&delete W.rebasedSources[a];typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[DEBUG REVERT] Cleared per-channel measurement for ${a}`,{restored:Se})}if(I(),S&&(S.disabled=!1,S.checked=V),Z(V?`Reverted ${a} to measurement`:`Cleared Smart on ${a} (restored loaded .quad)`),e.refreshDisplayFn)try{e.refreshDisplayFn()}catch{}if(un(a),Fn(),Be(),typeof updateInterpolationControls=="function")try{updateInterpolationControls()}catch{}else if(typeof ze.updateInterpolationControls=="function")try{ze.updateInterpolationControls()}catch{}Qr(),yt();try{if(B&&ht()){const Se=Array.from(m.rows.children).find(Ne=>Ne.getAttribute("data-channel")===B);(Se?q.clampEnd(Se.querySelector(".end-input")?.value||0):0)>0&&(m.editChannelSelect&&(m.editChannelSelect.value=B),EDIT.selectedChannel=B,edit_refreshState(),Be())}}catch{}}finally{$g(!1);try{Qr()}catch(se){console.warn("[revert-global] final button refresh failed:",se)}}}),I();const C={checked:!e.hasAttribute("data-user-disabled"),addEventListener:function(B,G){e._checkboxChangeHandler=G},dispatchEvent:function(B){e._checkboxChangeHandler&&B.type==="change"&&e._checkboxChangeHandler()}};e._virtualCheckbox=C,wy(a,e);const x=(B,G)=>{B&&(B.addEventListener("focus",()=>{vr(B),B.dataset.userEditing="true",B.dataset.userEditingNew="true",e.dataset.userEditing="true",B.dataset.initialNumericValue=B.value??""}),B.addEventListener("keydown",V=>{if(B.dataset.userEditing==="true")if(V.key&&V.key.length===1&&/[0-9]/.test(V.key)){if(B.dataset.userEditingNew==="true"){B.value=V.key,B.dataset.userEditingNew="false",V.preventDefault();return}}else V.key!=="Shift"&&(B.dataset.userEditingNew="false")}),B.addEventListener("blur",()=>{delete B.dataset.userEditing,delete B.dataset.userEditingNew,delete e.dataset.userEditing,typeof G=="function"&&G()}))};x(t,()=>ef(t,{commit:!0})),x(n,()=>tf(n,{commit:!0}));const P=()=>{if(!o)return;const B=typeof o.value=="string"?o.value.trim():"",G=B===""?0:Number(B);if(!Number.isFinite(G)){Jy(a),Ko(e,kr(a));return}if(G===0){const K=fs[a],se=Number.isFinite(K)&&K>0?K:1;typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[density] immediate fallback",a,se);const W=tc(a,se)||{value:se,source:"solver"};Ko(e,W);return}const V=Zy(a,G);Ko(e,V)};o&&(x(o,()=>P()),o.addEventListener("input",()=>P()),o.addEventListener("change",()=>P()));const k=parseFloat((t?.getAttribute("data-base-percent")??t?.value)||0),N=parseFloat((n?.getAttribute("data-base-end")??n?.value)||0);e._originalPercent=k,e._originalEnd=N,C.addEventListener("change",()=>{if(C.checked){if(e.removeAttribute("data-user-disabled"),r&&r.classList.add("invisible"),t&&(e._originalPercent>0?(wr(t,e._originalPercent),t.value=e._originalPercent.toString()):(wr(t,100),t.value="100")),n)if(e._originalEnd>0)Cr(n,e._originalEnd),n.value=e._originalEnd.toString();else{const B=Math.round(parseFloat(t?.value||100)/100*65535);Cr(n,B),n.value=B.toString()}}else e._originalPercent=parseFloat((t?.getAttribute("data-base-percent")??t?.value)||0),e._originalEnd=parseFloat((n?.getAttribute("data-base-end")??n?.value)||0),e.setAttribute("data-user-disabled","true"),r&&r.classList.remove("invisible"),t&&(wr(t,0),t.value="0"),n&&(Cr(n,0),n.value="0");typeof Be=="function"&&Be(),fi(),Cs(),e.refreshDisplayFn&&typeof e.refreshDisplayFn=="function"&&e.refreshDisplayFn()});function F(){const B=q.clampEnd(n.value);n.dataset.userEditing!=="true"&&(n.value=String(B)),e.hasAttribute("data-user-disabled");const G=B===0,V=q.clampPercent(t.value);if(Nt(a)||Zl(a,{percent:V,endValue:B}),r&&r.classList.toggle("invisible",!G),o&&(o.disabled=G||o.dataset.lockDisabled==="true",o.classList.toggle("bg-gray-50",o.disabled)),t?.dataset.userEditing==="true"||n?.dataset.userEditing==="true"||o?.dataset.userEditing==="true"?(e.setAttribute("data-compact","false"),e.style.display=""):G?(e.setAttribute("data-compact","true"),e.style.display="none"):(e.setAttribute("data-compact","false"),e.style.display=""),typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log("[compact] refresh",a,{isAtZero:G,attr:e.getAttribute("data-compact")}),fi(),Cs(),C.checked=!G,typeof un=="function")try{un(e.dataset.channel)}catch(se){console.warn("Failed to refresh processing detail:",se)}f(ki(a))}e.refreshDisplayFn=F;const U=parseFloat(t?.value||0),j=parseFloat(n?.value||0);U>0||j>0?(C.checked=!0,e.removeAttribute("data-user-disabled"),r&&r.classList.add("invisible")):(C.checked=!1,e.setAttribute("data-user-disabled","true"),r&&r.classList.remove("invisible"));try{const B=at?.()??null;B&&a&&(typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.log(`[INIT DEBUG] Syncing initial values for ${a}: percent=${U}, end=${j}`),B.setChannelValue(a,"percentage",U),B.setChannelValue(a,"endValue",j),B.setChannelEnabled(a,U>0||j>0))}catch(B){console.warn(`Failed to sync initial channel values for ${a}:`,B)}F(),I()}P1(TD);Xa&&Xa();Xa=e0((e,t)=>{const n=$r(e);n&&t&&typeof t=="object"&&(Ko(n,t),Hs(),typeof Be=="function"&&Be())});function OD(){const e=m.editModeToggleBtn;e?(e.addEventListener("click",()=>{const i=ht();ys(!i,{recordHistory:!0})}),console.log("âœ… Edit mode toggle button handler initialized")):console.warn("Edit mode toggle button not found");const t=document.getElementById("editModeHelpBtn"),n=document.getElementById("editModeHelpPopup"),r=document.getElementById("closeEditModeHelpBtn");t&&n&&t.addEventListener("click",()=>{n.classList.remove("hidden")}),r&&n&&(r.addEventListener("click",()=>{n.classList.add("hidden")}),n.addEventListener("click",i=>{i.target===n&&n.classList.add("hidden")})),ys(!1,{recordHistory:!1}),console.log("ðŸ”„ Edit mode initialized to OFF state")}function _D(){console.log("ðŸ§¹ Event handlers cleanup requested (placeholder)"),Xa&&(Xa(),Xa=null)}function ND(){const e=bu("linear"),t={id:"linear",name:e?.label||"Linear",params:e?.params||{},source:"preset"};gt().contrastIntent||nt({contrastIntent:t}),mn&&!ze.contrastIntent&&(ze.contrastIntent=t)}function nb(e,t={},n="preset"){const r=bu(e)||{},i={...r.params||{},...t},a={id:e,name:r.label||e,params:i,source:n};nt({contrastIntent:a}),mn&&(ze.contrastIntent=a),typeof Ao=="function"&&Ao(),typeof yt=="function"&&yt(),Be(),Fn()}function Lo(e){const t=(o,s,l)=>Math.max(s,Math.min(l,o)),n=t(Number(e),0,100);let r;if(n>8){const o=(n+16)/116;r=o*o*o}else r=n/903.3;let i=r<=.0031308?12.92*r:1.055*Math.pow(r,1/2.4)-.055;i=t(i,0,1);const a=Math.round(i*255).toString(16).padStart(2,"0");return`#${a}${a}${a}`}function lv(e,t){return t<=1?"0.0":(e/(t-1)*100).toFixed(1)}function Cu(e){const t=Number(e);return Number.isFinite(t)?Math.max(0,Math.min(100,t)):null}function Au(e){for(let t=1;t<e.length;t++)if(!(e[t]>e[t-1]))return!1;return!0}function FD(e,t={}){const{value:n="",patchValue:r,total:i=11,targetLstarFloor:a=20,compact:o=!1,xInputClass:s="lstar-measured-x",lInputClass:l="lstar-input"}=t,c=Math.max(2,i),u=r??Number(lv(e,c)),d=n!==""&&!Number.isNaN(parseFloat(n)),p=d?Lo(n):"#ffffff",f=Math.max(a,100-u),h=Lo(f),g=d?`background-color: ${p};`:"background-image: repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px); background-color: #ffffff; border-style: dashed;",b=d?"":'<span class="text-[10px] text-gray-500">-</span>',S=o?"px-1 py-0.5":"px-2 py-1",E=o?"w-16":"w-20",y=o?"w-16":"w-24";return`
    <tr>
      <td class="${S} w-8 text-xs text-gray-500">${e+1}.</td>
      <td class="${S}">
        <input type="number" class="${s} ${E} px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" value="${u.toFixed(1)}" min="0" max="100" step="0.1" title="Patch % (0-100)">
      </td>
      <td class="${S} text-center">
        <span class="inline-flex items-center justify-center gap-[2px]">
          <span class="lstar-target-swatch inline-flex items-center justify-center w-5 h-5 rounded border border-gray-300" style="background-color: ${h};" title="Linear target preview (based on Patch %, min L* = ${a})"></span>
          <span class="lstar-swatch inline-flex items-center justify-center w-5 h-5 rounded border border-gray-300" style="${g}" title="Measured L* preview">${b}</span>
        </span>
      </td>
      <td class="${S}">
        <input type="number" class="${l} ${y} px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" placeholder="L*" min="0" max="100" step="0.1" value="${n}">
      </td>
    </tr>
  `}function Qa(e,t){const n=e?e.querySelector(".lstar-swatch"):null;if(n){if(t===null){n.style.backgroundColor="#ffffff",n.style.backgroundImage="repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px)",n.style.borderStyle="dashed",n.innerHTML='<span class="text-[10px] text-gray-500">-</span>';return}n.style.backgroundImage="none",n.style.borderStyle="solid",n.style.backgroundColor=Lo(t),n.innerHTML=""}}function cv(e,t,n=20){const r=e?e.querySelector(".lstar-target-swatch"):null;if(!r)return;const i=Math.max(n,100-t);r.style.backgroundColor=Lo(i)}function GD(e,t={}){const{minRows:n=5,targetLstarFloor:r=20,xInputClass:i="lstar-measured-x",lInputClass:a="lstar-input"}=t,o={valid:!0,values:[],measuredX:[],measuredPairs:[],errors:[]};if(!e)return o.valid=!1,o.errors.push("Container not found"),o;const s=Array.from(e.querySelectorAll("tr"));if(s.length===0)return o.valid=!1,o.errors.push("No measurement rows found"),o;const l=[];s.forEach((u,d)=>{const p=u.querySelector(`.${i}`),f=u.querySelector(`.${a}`),h=p?parseFloat(p.value):NaN;if(p&&(Number.isFinite(h)&&h>=0&&h<=100?(l[d]=h,p.style.borderColor="#d1d5db",cv(u,h,r)):(o.valid=!1,o.errors.includes("All Patch % must be set (0-100)")||o.errors.push("All Patch % must be set (0-100)"),p.style.borderColor="#ef4444")),!f)return;const g=f.value.trim();if(!g){o.valid=!1,o.errors.includes("All L* values must be set (0-100)")||o.errors.push("All L* values must be set (0-100)"),f.style.borderColor="#d1d5db",Qa(u,null);return}const b=parseFloat(g);if(!Number.isFinite(b)||b<0||b>100){o.valid=!1,o.errors.includes("L* values must be between 0 and 100")||o.errors.push("L* values must be between 0 and 100"),f.style.borderColor="#d1d5db",Qa(u,null);return}o.values.push({index:d,value:b}),o.measuredX[d]=l[d],f.style.borderColor="#d1d5db",Qa(u,b)}),o.values.length<n&&(o.valid=!1,o.errors.some(u=>u.includes("values must be set"))||o.errors.push(`Need at least ${n} measurement points`)),o.values.length!==s.length&&(o.valid=!1,o.errors.includes("All L* values must be set (0-100)")||o.errors.push("All L* values must be set (0-100)"));const c=o.measuredX.filter(u=>Number.isFinite(u));return c.length!==s.length?(o.valid=!1,o.errors.includes("All Patch % must be set (0-100)")||o.errors.push("All Patch % must be set (0-100)")):Au(c)||(o.valid=!1,o.errors.includes("Patch % must be strictly increasing (0->100)")||o.errors.push("Patch % must be strictly increasing (0->100)")),o.valid&&s.forEach((u,d)=>{const p=o.values.find(h=>h.index===d)?.value,f=o.measuredX[d];Number.isFinite(p)&&Number.isFinite(f)&&o.measuredPairs.push({x:f,l:p})}),o}function RD(e){return e.map(t=>({input:t.x,lstar:t.l}))}const ti=5,Mu=50,uv=20,dv="quadgen.manualLstarLayout";let rn=ti,wc=[],Zn=[];const zD=bS();function pv(){if(typeof window>"u"||!window.localStorage)return null;let e=null;try{e=window.localStorage.getItem(dv)}catch{return null}if(!e)return null;try{const t=JSON.parse(e);if(!t||typeof t!="object")return null;const r=(Array.isArray(t.patchPercents)?t.patchPercents:[]).map(Cu).filter(o=>o!==null);if(!r.length)return null;let i=Number(t.patchCount);if((!Number.isFinite(i)||i<=0)&&(i=r.length),i=Math.round(i),i=Math.max(ti,Math.min(Mu,i)),i=Math.min(i,r.length),i<ti)return null;const a=r.slice(0,i);return Au(a)?{patchCount:i,patchPercents:a}:null}catch{return null}}function Pm(e,t){const n=Number(e);if(!Number.isFinite(n)||n<ti)return;const r=Math.max(ti,Math.min(Mu,Math.round(n))),i=Array.isArray(t)?t.map(Cu).filter(o=>o!==null):[];if(i.length<r)return;const a=i.slice(0,r);if(Au(a)&&(Zn=a,!(typeof window>"u"||!window.localStorage)))try{window.localStorage.setItem(dv,JSON.stringify({patchCount:r,patchPercents:a}))}catch{}}function fv(){const e=pv();return e?(rn=e.patchCount,Zn=e.patchPercents.slice(),Lu(),Iu(),e):(Zn=[],null)}function UD(e,t="",n){const r=Math.max(2,rn),i=n??Number(lv(e,r)),a=t!==""&&!Number.isNaN(parseFloat(t)),o=a?Lo(t):"#ffffff",s=Math.max(uv,100-i),l=Lo(s),c=a?`background-color: ${o};`:"background-image: repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px); background-color: #ffffff; border-style: dashed;",u=a?"":'<span class="text-[10px] text-gray-500">â€”</span>';return`
    <tr>
      <td class="px-2 py-1 w-8 text-xs text-gray-500">${e+1}.</td>
      <td class="px-2 py-1 w-24">
        <input type="number" class="lstar-measured-x w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" value="${i.toFixed(1)}" min="0" max="100" step="0.1" title="Patch % (0â€“100)">
      </td>
      <td class="px-2 py-1 w-24 text-center">
        <span class="inline-flex items-center justify-center gap-[2px]">
          <span class="lstar-target-swatch inline-flex items-center justify-center w-6 h-6 rounded border border-gray-300" style="background-color: ${l};" title="Linear target preview (based on Patch %, min L* = 20)"></span>
          <span class="lstar-swatch inline-flex items-center justify-center w-6 h-6 rounded border border-gray-300" style="${c}" title="Measured L* preview">${u}</span>
        </span>
      </td>
      <td class="px-2 py-1 w-24">
        <input type="number" class="lstar-input w-24 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" placeholder="L*" min="0" max="100" step="0.1" value="${t}">
      </td>
    </tr>
  `}function mv(e){try{const t=e?"add":"remove";document.documentElement.classList[t]("overflow-hidden"),document.body.classList[t]("overflow-hidden")}catch{}}function rf(){if(m.lstarModal){if(fv(),al(),m.manualLstarDensityToggle){const e=va();m.manualLstarDensityToggle.checked=e,m.manualLstarDensityToggle.setAttribute("aria-checked",String(e))}m.lstarModal.classList.remove("hidden"),mv(!0)}}function as(){m.lstarModal&&(m.lstarModal.classList.add("hidden"),mv(!1))}function Lu(){m.lstarCountInput&&(m.lstarCountInput.value=rn);const e=document.getElementById("lstarCountInputHeader");e&&(e.value=rn)}function Iu(){m.removeLstarInput&&(m.removeLstarInput.disabled=rn<=ti);const e=document.getElementById("removeLstarInputHeader");e&&(e.disabled=rn<=ti)}function al(e={}){if(!m.lstarInputs)return;const t=m.lstarInputs;t.innerHTML="";const n=e.savedValues||wc;Array.isArray(Zn)||(Zn=[]),Zn=Zn.slice(0,rn);const i=(Array.isArray(e.savedPatchPercents)?e.savedPatchPercents:Zn).slice(0,rn);for(let a=0;a<rn;a++){const o=n[a]||"",s=Number.isFinite(i[a])?i[a]:void 0;t.insertAdjacentHTML("beforeend",UD(a,o,s))}Lu(),Iu(),ol()}function ol(){const e={valid:!0,values:[],measuredX:[],measuredPairs:[]};if(!m.lstarInputs)return e;const t=Array.from(m.lstarInputs.querySelectorAll("tr")),n=[];let r=!1,i="";t.forEach((o,s)=>{const l=o.querySelector(".lstar-measured-x"),c=o.querySelector(".lstar-input"),u=l?parseFloat(l.value):NaN;if(l&&(Number.isFinite(u)&&u>=0&&u<=100?(n[s]=u,l.style.borderColor="#d1d5db",cv(o,u,uv)):(r=!0,i||(i="All Patch % must be set (0â€“100)"),l.style.borderColor="#ef4444")),!c)return;const d=c.value.trim();if(!d){r=!0,i||(i="All L* values must be set (0â€“100)"),c.style.borderColor="#d1d5db",Qa(o,null);return}const p=parseFloat(d);if(!Number.isFinite(p)||p<0||p>100){r=!0,i||(i="L* values must be between 0 and 100"),c.style.borderColor="#d1d5db",Qa(o,null);return}e.values.push({index:s,value:p}),e.measuredX[s]=n[s],c.style.borderColor="#d1d5db",Qa(o,p)}),e.values.length<ti&&(r=!0,i||(i="")),e.values.length!==t.length&&(r=!0,i||(i="All L* values must be set (0â€“100)"));const a=e.measuredX.filter(o=>Number.isFinite(o));return a.length!==t.length?(r=!0,i||(i="All Patch % must be set (0â€“100)")):Au(a)||(r=!0,i||(i="Patch % must be strictly increasing (0â†’100)")),r?(m.lstarValidation&&(i?(m.lstarValidation.textContent=i,i==="All L* values must be set (0â€“100)"?m.lstarValidation.classList.add("text-center"):m.lstarValidation.classList.remove("text-center"),m.lstarValidation.classList.remove("hidden")):(m.lstarValidation.classList.add("hidden"),m.lstarValidation.classList.remove("text-center"))),m.generateFromLstar&&(m.generateFromLstar.disabled=!0)):(m.lstarValidation&&(m.lstarValidation.classList.add("hidden"),m.lstarValidation.classList.remove("text-center")),m.generateFromLstar&&(m.generateFromLstar.disabled=!1),t.forEach((o,s)=>{const l=e.values.find(u=>u.index===s)?.value,c=e.measuredX[s];Number.isFinite(l)&&Number.isFinite(c)&&e.measuredPairs.push({x:c,l})})),e.valid=!r,e}function rb(){rn>=Mu||(rn+=1,Zn=Zn.slice(0,rn),al())}function ib(){rn<=ti||(rn-=1,wc=wc.slice(0,rn),Zn=Zn.slice(0,rn),al())}function ab(e){const t=parseInt(e.target.value,10);Number.isFinite(t)&&t>=ti&&t<=Mu&&(rn=t,Zn=Zn.slice(0,rn),al())}function $D(e){const t=rr(),n=xm(e);n.filename=`Manual-L-${e.values.length}pts`;const r=Rn(n,ft.SPACE.PRINTER);try{const s=Ee?.(),l=u=>{if(!u||typeof u!="object")return null;const d={};let p=!1;return Object.entries(u).forEach(([f,h])=>{Array.isArray(h)&&(d[f]=h.slice(),p=!0)}),p?d:null},c=l(s?.plotBaseCurvesBaseline)||l(s?._plotSmoothingOriginalCurves)||l(s?.curves);c&&D.setGlobalBaselineCurves(c)}catch(s){console.warn("[Manual L*] Failed to capture baseline snapshot:",s)}D.setGlobalData(r,!0,{source:"manual"}),typeof window<"u"&&typeof window.__quadSetGlobalBakedState=="function"&&window.__quadSetGlobalBakedState(null,{skipHistory:!0}),nt({linearizationData:r,linearizationApplied:!0}),zD.setGlobalState(r,!0),ye.linearizationData=r,ye.linearizationApplied=!0,Ri(r,{scope:"global",label:"manual L* correction",source:"manual-lstar"}),m.globalLinearizationBtn&&m.globalLinearizationBtn.setAttribute("data-tooltip",`Loaded: Manual L* (${Pt(n)})`),m.globalLinearizationToggle&&(m.globalLinearizationToggle.disabled=!1,m.globalLinearizationToggle.checked=!0,m.globalLinearizationToggle.setAttribute("aria-checked","true")),m.globalLinearizationInfo&&m.globalLinearizationInfo.classList.remove("hidden"),m.globalLinearizationFilename&&(m.globalLinearizationFilename.textContent="Manual L* Entry"),m.globalLinearizationDetails&&(m.globalLinearizationDetails.textContent=` (${Pt(n)})`),m.globalLinearizationHint&&m.globalLinearizationHint.classList.add("hidden");try{Er()}catch{}Wd("updateInterpolationControls"),nn(),wo();try{Co()}catch(s){typeof DEBUG_LOGS<"u"&&DEBUG_LOGS&&console.warn("[LabTechSummary] Failed to post summary after manual L* apply:",s)}const i=Array.isArray(e.measuredPairs)?e.measuredPairs.map(s=>Cu(s.x)).filter(s=>s!==null):[];Pm(e.values.length,i),as();const a=t===Kt.DENSITY?"CIE density (log)":"CIE L* (perceptual)";Z(`Applied manual L* correction curve (${Pt(n)}) (${a}; Gaussian-weighted reconstruction with PCHIP interpolation)`),Wd("postGlobalDeltaChatSummary"),wc=(m.lstarInputs?Array.from(m.lstarInputs.querySelectorAll(".lstar-input")):[]).map(s=>s.value),rn=e.values.length}function VD(){const e=ol();if(e.valid)try{$D(e)}catch(t){console.error("Error processing L* values:",t),Z(`Error processing L* values: ${t.message}`)}}function HD(){const e=ol();if(!e.valid){m.lstarValidation&&(m.lstarValidation.textContent="Please fix errors and complete all fields before saving .txt",m.lstarValidation.classList.remove("hidden"),m.lstarValidation.classList.remove("text-center"));return}const t=e.measuredPairs||[],n=`GRAY	LAB_L	LAB_A	LAB_B
`,r=t.map(o=>{const s=Number(o.x).toFixed(2),l=Number(o.l).toFixed(2);return`${s}	${l}	0.00	0.00`}),i=n+r.join(`
`)+`
`;To(i,"LAB-Data.txt","text/plain");const a=t.map(o=>Cu(o.x)).filter(o=>o!==null);Pm(e.values.length,a)}function xm(e){return gu(e,{normalizationMode:rr()})}function qD(){m.manualLstarBtn&&m.manualLstarBtn.addEventListener("click",rf),m.closeLstarModal&&m.closeLstarModal.addEventListener("click",as),m.cancelLstar&&m.cancelLstar.addEventListener("click",as),m.lstarModal&&m.lstarModal.addEventListener("click",r=>{r.target===m.lstarModal&&as()}),m.addLstarInput&&m.addLstarInput.addEventListener("click",rb),m.removeLstarInput&&m.removeLstarInput.addEventListener("click",ib),m.lstarCountInput&&m.lstarCountInput.addEventListener("input",ab);const e=document.getElementById("addLstarInputHeader");e&&e.addEventListener("click",rb);const t=document.getElementById("removeLstarInputHeader");t&&t.addEventListener("click",ib);const n=document.getElementById("lstarCountInputHeader");n&&n.addEventListener("input",ab),m.lstarInputs&&m.lstarInputs.addEventListener("input",()=>ol()),m.generateFromLstar&&m.generateFromLstar.addEventListener("click",VD),m.saveLstarTxt&&m.saveLstarTxt.addEventListener("click",HD),m.manualLstarDensityToggle&&m.manualLstarDensityToggle.addEventListener("change",r=>{const i=r.target.checked?Kt.DENSITY:Kt.LSTAR;us(i)})}function Bm(){qD(),m.generateFromLstar&&(m.generateFromLstar.disabled=!0),Lu(),Iu()}const jD={initializeManualLstar:Bm,parseManualLstarData:xm,_internal:{validateInputs:ol,updateRows:al,syncCountInputs:Lu,toggleRemoveButtons:Iu,restoreLayoutFromStorage:fv,loadStoredLayout:pv,persistLayout:Pm}};Xe("manualLstar",{initializeManualLstar:Bm,parseManualLstarData:xm,showModal:rf,hideModal:as,manualLstarModule:jD,openManualLstarModal:rf},{exposeOnWindow:!0,windowAliases:["parseManualLstarData","openManualLstarModal","manualLstarModule"]});function hv(e){return!!e&&!e.classList.contains("hidden")}function WD(){return[m.helpPopup,m.globalCorrectionHelpPopup,m.editModeHelpPopup,m.intentHelpPopup,m.lstarModal,m.optionsModal]}function KD(){try{document.body.style.overflow="hidden"}catch(e){console.warn("Unable to lock body scroll for options modal",e)}}function YD(){try{WD().some(hv)||(document.body.style.overflow="")}catch(e){console.warn("Unable to unlock body scroll after closing options modal",e)}}let Za=null,af=null;function Cc({returnFocus:e=!0}={}){const{optionsModal:t,closeOptionsBtn:n,optionsBtn:r}=m;if(!t)return;t.classList.add("hidden"),t.setAttribute("aria-hidden","true"),Za&&(document.removeEventListener("keydown",Za),Za=null),YD();const i=e?af||r||n:null;i&&typeof i.focus=="function"&&i.focus({preventScroll:!0}),af=null}function ob(){const{optionsModal:e,closeOptionsBtn:t}=m;if(e){if(hv(e)){t&&typeof t.focus=="function"&&t.focus({preventScroll:!0});return}af=document.activeElement,e.classList.remove("hidden"),e.setAttribute("aria-hidden","false"),KD(),Za||(Za=n=>{(n.key==="Escape"||n.key==="Esc")&&(n.preventDefault(),Cc())},document.addEventListener("keydown",Za)),t&&typeof t.focus=="function"&&t.focus({preventScroll:!0})}}function XD(e){e.target===m.optionsModal&&Cc()}function QD(){const{optionsBtn:e,optionsModal:t,closeOptionsBtn:n}=m;if(!(!t||t.dataset.initialized==="true"))return e&&e.addEventListener("click",r=>{r.preventDefault(),ob()}),n&&n.addEventListener("click",r=>{r.preventDefault(),Cc()}),t.addEventListener("click",XD),t.dataset.initialized="true",{open:ob,close:Cc}}function sb(e){const t=Math.max(0,Math.min(100,Number(e)||0));if(t>8){const n=(t+16)/116;return n*n*n}return t/903.3}function ZD(e,t){const n=sb(e),r=sb(t);return Math.log10(r/Math.max(n,1e-10))}function gv(e){if(!e||e.length<2)return{densities:[],dMax:0,L_paper:100};const t=e[0].lstar,n=e.map(i=>ZD(i.lstar,t)),r=Math.max(...n);return{densities:n,dMax:r,L_paper:t}}function JD(e,t){if(!t||t<=0)return 50;const n=e/t;return Math.max(5,Math.min(95,n*100))}function eP(e,t){if(!t||t.length<2)return 50;for(let n=0;n<t.length-1;n++)if(t[n].lstar>=e&&t[n+1].lstar<e){const r=(e-t[n].lstar)/(t[n+1].lstar-t[n].lstar),i=t[n].input+r*(t[n+1].input-t[n].input);return Math.max(5,Math.min(95,i))}return 100}function tP(e){if(!e||e.length<3)return 1;const t=e[0].lstar,n=e[e.length-1].lstar,r=t-n;if(r<=0)return 1;const i=t-.2*r,a=t-.8*r;let o=0,s=100;for(const d of e)if(d.lstar<=i&&o===0&&(o=d.input),d.lstar<=a){s=d.input;break}const l=Math.max(1,s-o),c=Math.abs(a-i)/l,u=r/60;return Math.max(.6,Math.min(1.4,1.4-c/u*.8))}function bv(e){return e<40?"highlight":e<70?"midtone":"shadow"}function nP(e,t,n){if(!n||n<=0)return e;const r=Math.min(1,t/n);return Math.round(e*r*10)/10}function rP(e,t,n,r={}){const{densities:i,dMax:a,L_paper:o}=gv(e);let s;if(r.useLstarMatching&&r.kMeasurements){const d=e[e.length-1].lstar;s=eP(d,r.kMeasurements)}else s=JD(a,t);const l=tP(e),c=nP(n,a,t),u=bv(s);return{dMax:a,apex:s,widthFactor:l,end:c,role:u,L_paper:o}}function iP(e){const t=new Array(256),n=e/100*65535;for(let r=0;r<256;r++)t[r]=Math.round(r/255*n);return t}function aP(e,t=65535){const i=[{x:Math.max(0,e-60),y:0},{x:Math.max(0,e-30),y:t*.5},{x:e,y:t},{x:Math.min(255,e+30),y:t*.5},{x:Math.min(255,e+60),y:0}],a=[];for(const u of i)(a.length===0||u.x>a[a.length-1].x)&&a.push(u);if(a.length<2)return new Array(256).fill(0);const o=a.map(u=>u.x),s=a.map(u=>u.y),l=zr(o,s),c=new Array(256);for(let u=0;u<256;u++){const d=l(u);c[u]=Math.max(0,Math.round(d))}return c[0]=Math.min(c[0],c[1]||0),c[255]=Math.min(c[255],c[254]||0),c}function oP(e,t,n){const r=Math.round(e/100*255),i=aP(r),a=i.indexOf(Math.max(...i)),o=(r-a)/255*100;let s=o!==0?Ly(i,a,o):i.slice();const l=s.indexOf(Math.max(...s));let c,u;n==="highlight"?(c=.6,u=1.5):n==="midtone"?(c=1.4,u=.7):(c=1,u=1),s=cm(s,l,{leftFactor:c,rightFactor:u});const d=Math.max(...s),p=t/100*65535,f=d>0?p/d:0;return s.map(h=>Math.round(Math.max(0,h*f)))}function sP(e){const{apex:t,end:n,widthFactor:r=1,role:i}=e;let a=oP(t,n,i||bv(t));if(Math.abs(r-1)>.01){const o=a.indexOf(Math.max(...a)),s=r;a=cm(a,o,{leftFactor:s,rightFactor:s})}return a}function lP(e,t=50,n=.13,r=.5){const i=Math.round((t-n*100)/100*255),a=new Array(256).fill(0);for(const c of e)if(c.curve)for(let u=0;u<256;u++)a[u]+=c.curve[u]/65535;const o=Math.max(...a);if(o<.01)return Math.max(0,i);const s=o*r;let l=0;for(let c=255;c>=0;c--)if(a[c]>=s){l=c;break}return Math.max(i,l)}function cP(e,t,n=20){const r=new Array(256),i=Math.max(0,Math.min(254,t)),a=Math.min(255,i+n),o=[{x:0,y:0},{x:Math.max(1,i),y:0},{x:a,y:1},{x:255,y:1}],s=[];for(const d of o)(s.length===0||d.x>s[s.length-1].x)&&s.push(d);const l=s.map(d=>d.x),c=s.map(d=>d.y),u=zr(l,c);for(let d=0;d<256;d++){const p=Math.max(0,Math.min(1,u(d)));r[d]=Math.round((e[d]||0)*p)}return r}function Tm(e,t,n=50,r={}){const{bracketMargin:i=.13,thresholdFraction:a=.5,transitionWidth:o=20}=r,s=lP(e,n,i,a);return{kCurve:cP(t,s,o),startIndex:s}}function yv(e){const t=[],n=[];if(!e||!Array.isArray(e))return t.push("Measurements must be an array"),{valid:!1,errors:t,warnings:n};e.length<5&&t.push("Minimum 5 measurement points required"),e.length>0&&e[0].input>5&&t.push("First measurement should be at or near 0% input (paper white)"),e.length>0&&e[e.length-1].input<95&&t.push("Last measurement should be at or near 100% input (max ink)");for(const i of e)(i.lstar<0||i.lstar>100)&&t.push(`L* value ${i.lstar} out of range [0, 100]`);for(let i=1;i<e.length;i++){const a=e[i].input-e[i-1].input;a>20&&n.push(`Large gap (${a}%) between points ${i-1} and ${i}`)}let r=!1;for(let i=1;i<e.length;i++)if(e[i].lstar>e[i-1].lstar+1){r=!0;break}return r&&n.push("Non-monotonic L* values detected - consider PCHIP smoothing"),{valid:t.length===0,errors:t,warnings:n}}function uP(e,t=50,n=100){const r=[];let i=0,a=0;for(let o=0;o<256;o++){let s=0;for(const l of e){if(!l.curve)continue;const c=l.endPercent||100;s+=l.curve[o]/65535*c}if(s>n){if(a++,a<=3){const l=Math.round(o/2.55);r.push(`Total ink ${s.toFixed(1)}% at input ${l}% exceeds max ${n}%`)}}else s>t&&i++}return a>3&&r.push(`... and ${a-3} more points exceeding ${n}%`),i>0&&r.unshift(`âš ï¸ ${i} points exceed ${t}% (warning threshold)`),r}function dP(e,t,n={}){const r=yv(t.measurements),i=rP(t.measurements,e.dMax,t.inkLimit,{useLstarMatching:n.useLstarMatching,kMeasurements:e.measurements}),a=sP({apex:i.apex,end:i.end,widthFactor:i.widthFactor,role:i.role});let o=null;if(e.curve){const s=n.existingSecondaries||[];s.push({curve:a,endPercent:i.end});const{kCurve:l}=Tm(s,e.curve,n.midtonePeakPercent||i.apex,n);o=l}return{dMax:i.dMax,recommendedEnd:i.end,recommendedApex:i.apex,recommendedWidth:i.widthFactor,role:i.role,curve:a,kReductionCurve:o,validation:r}}const Sv="quadgen.channelBuilder.session";let Ue={referenceK:null,secondaryChannels:[],kReduction:null,createdAt:null,modifiedAt:null,currentStep:0,options:{useLstarMatching:!1,bracketMargin:.13,thresholdFraction:.5,transitionWidth:20,entryMode:"paste",manualRowCount:7}};const of=new Set;function zi(e){if(!e)return e;if(typeof structuredClone=="function")try{return structuredClone(e)}catch{}try{return JSON.parse(JSON.stringify(e))}catch{return Array.isArray(e)?e.slice():{...e}}}function qi(){const e=fP();of.forEach(t=>{try{t(e)}catch(n){console.warn("[ChannelBuilder] Listener error:",n)}})}function ji(){try{if(typeof localStorage<"u"){const e=JSON.stringify({...Ue,modifiedAt:Date.now()});localStorage.setItem(Sv,e)}}catch(e){console.warn("[ChannelBuilder] Failed to persist session:",e)}}function pP(){try{if(typeof localStorage<"u"){const e=localStorage.getItem(Sv);if(e){const t=JSON.parse(e);if(t&&typeof t=="object")return Ue={referenceK:t.referenceK||null,secondaryChannels:Array.isArray(t.secondaryChannels)?t.secondaryChannels:[],kReduction:t.kReduction||null,createdAt:t.createdAt||null,modifiedAt:t.modifiedAt||null,currentStep:typeof t.currentStep=="number"?t.currentStep:0,options:{useLstarMatching:t.options?.useLstarMatching||!1,bracketMargin:t.options?.bracketMargin??.13,thresholdFraction:t.options?.thresholdFraction??.5,transitionWidth:t.options?.transitionWidth??20,entryMode:t.options?.entryMode||"paste",manualRowCount:t.options?.manualRowCount??7}},!0}}}catch(e){console.warn("[ChannelBuilder] Failed to load persisted session:",e)}return!1}function fP(){return zi(Ue)}function mP(){return Ue.referenceK!==null||Ue.secondaryChannels.length>0}function vv(){Ue={referenceK:null,secondaryChannels:[],kReduction:null,createdAt:null,modifiedAt:null,currentStep:0,options:{useLstarMatching:!1,bracketMargin:.13,thresholdFraction:.5,transitionWidth:20,entryMode:"paste",manualRowCount:7}},ji(),qi()}function Ev(){vv(),Ue.createdAt=Date.now(),Ue.modifiedAt=Date.now(),ji(),qi()}function wv(e){e?Ue.referenceK={name:e.name||"K",inkLimit:typeof e.inkLimit=="number"?e.inkLimit:null,measurements:Array.isArray(e.measurements)?zi(e.measurements):[],dMax:typeof e.dMax=="number"?e.dMax:null,curve:Array.isArray(e.curve)?e.curve.slice():null,L_paper:typeof e.L_paper=="number"?e.L_paper:null}:Ue.referenceK=null,Ue.modifiedAt=Date.now(),Ue.createdAt||(Ue.createdAt=Ue.modifiedAt),ji(),qi()}function Oo(){return Ue.referenceK?zi(Ue.referenceK):null}function hP(e,t,n){if(!t||t.length<2)return console.warn("[ChannelBuilder] Invalid measurements for K"),!1;if(typeof e!="number"||e<=0||e>100)return console.warn("[ChannelBuilder] Invalid ink limit for K"),!1;let r=null,i=null;if(typeof n=="function"){const o=n(t);r=o.dMax,i=o.L_paper}const a=iP(e);return wv({name:"K",inkLimit:e,measurements:t,dMax:r,curve:a,L_paper:i}),!0}function gP(e){if(!e?.curves?.K)return console.warn("[ChannelBuilder] No K curve found in quad data"),!1;const t=e.curves.K,r=Math.max(...t)/65535*100,i=[],a=16;for(let o=0;o<256;o+=a){const s=o/255*100,c=100-t[o]/65535*100;i.push({input:s,lstar:c})}return i.push({input:100,lstar:100-t[255]/65535*100}),wv({name:"K",inkLimit:Math.round(r*10)/10,measurements:i,dMax:null,curve:t.slice()}),!0}function bP(e){const t={name:e.name,inkLimit:e.inkLimit||100,measurements:Array.isArray(e.measurements)?zi(e.measurements):[],computed:e.computed?zi(e.computed):null},n=Ue.secondaryChannels.findIndex(r=>r.name===t.name);return n>=0?Ue.secondaryChannels[n]=t:Ue.secondaryChannels.push(t),Ue.modifiedAt=Date.now(),ji(),qi(),n>=0?n:Ue.secondaryChannels.length-1}function yP(e){const t=Ue.secondaryChannels.findIndex(n=>n.name===e);return t>=0?(Ue.secondaryChannels.splice(t,1),Ue.modifiedAt=Date.now(),ji(),qi(),!0):!1}function Bi(){return zi(Ue.secondaryChannels)}function sf(e){e?Ue.kReduction={curve:Array.isArray(e.curve)?e.curve.slice():null,startIndex:typeof e.startIndex=="number"?e.startIndex:0,midtonePeakPercent:typeof e.midtonePeakPercent=="number"?e.midtonePeakPercent:50}:Ue.kReduction=null,Ue.modifiedAt=Date.now(),ji(),qi()}function Om(){return Ue.kReduction?zi(Ue.kReduction):null}function _m(){return Ue.currentStep}function Nm(e){const t=Math.max(0,Math.min(3,Math.round(e)));Ue.currentStep!==t&&(Ue.currentStep=t,Ue.modifiedAt=Date.now(),ji(),qi())}function Ac(){return zi(Ue.options)}function ku(e){Ue.options={...Ue.options,...e},Ue.modifiedAt=Date.now(),ji(),qi()}function SP(e){return typeof e!="function"?()=>{}:(of.add(e),()=>{of.delete(e)})}function vP(){const e=[];if(Ue.kReduction?.curve){const t=Ue.referenceK?.curve?Math.max(...Ue.referenceK.curve)/65535*100:100;e.push({name:"K",curve:Ue.kReduction.curve,endPercent:t})}else if(Ue.referenceK?.curve){const t=Math.max(...Ue.referenceK.curve)/65535*100;e.push({name:"K",curve:Ue.referenceK.curve,endPercent:t})}for(const t of Ue.secondaryChannels)t.computed?.curve&&e.push({name:t.name,curve:t.computed.curve,endPercent:t.computed.end||100});return e}typeof window<"u"&&pP();let Ui=null,lf=!1;const Cv=["channelBuilderTabK","channelBuilderTabAdd","channelBuilderTabPreview","channelBuilderTabApply"],EP=["channelBuilderPanelK","channelBuilderPanelAdd","channelBuilderPanelPreview","channelBuilderPanelApply"],Mc=3,cf=15,Av=7,Mv=20;let Ti=Av,Oi=Av;function Lv(){if(!lf){if(Ui=document.getElementById("channelBuilderModal"),!Ui){console.warn("[ChannelBuilder] Modal element not found");return}wP(),SP(OP),lf=!0,console.log("[ChannelBuilder] Modal initialized")}}function wP(){const e=document.getElementById("closeChannelBuilderModal");e&&e.addEventListener("click",uf),Ui?.addEventListener("click",t=>{t.target===Ui&&uf()}),Cv.forEach((t,n)=>{const r=document.getElementById(t);r&&r.addEventListener("click",()=>Nm(n))}),IP(),DP(),document.getElementById("channelBuilderNextBtn")?.addEventListener("click",AP),document.getElementById("channelBuilderPrevBtn")?.addEventListener("click",MP),document.getElementById("channelBuilderClearBtn")?.addEventListener("click",LP)}function Iv(){if(lf||Lv(),!Ui){console.warn("[ChannelBuilder] Modal not available");return}const e=Ac();mP()||(Ev(),ku({entryMode:e.entryMode,manualRowCount:e.manualRowCount}));const t=Ac();t.manualRowCount&&t.manualRowCount>=Mc&&t.manualRowCount<=cf&&(Ti=t.manualRowCount,Oi=t.manualRowCount),Rm(),Ui.classList.remove("hidden"),document.body.style.overflow="hidden"}function uf(){Ui&&(Ui.classList.add("hidden"),document.body.style.overflow="")}function CP(){const e=_m();Cv.forEach((r,i)=>{const a=document.getElementById(r);a&&(i===e?(a.classList.add("border-green-600","text-gray-800"),a.classList.remove("border-transparent","text-gray-500")):(a.classList.remove("border-green-600","text-gray-800"),a.classList.add("border-transparent","text-gray-500")))}),EP.forEach((r,i)=>{const a=document.getElementById(r);a&&(i===e?a.classList.remove("hidden"):a.classList.add("hidden"))});const t=document.getElementById("channelBuilderPrevBtn"),n=document.getElementById("channelBuilderNextBtn");t&&(t.disabled=e===0,t.classList.toggle("opacity-50",e===0)),n&&(e===3?n.textContent="Apply & Close":n.textContent="Next")}function AP(){const e=_m();e===3?(TP(),uf()):Nm(e+1)}function MP(){const e=_m();e>0&&Nm(e-1)}function LP(){confirm("Clear all channel builder data and start fresh?")&&(vv(),Ev(),Rm(),pn("Channel builder session cleared"))}function IP(){const e=document.getElementById("cbLoadKFromQuad");e&&e.addEventListener("click",()=>{const n=Ee();if(!n?.curves?.K){pn("No K curve loaded. Load a .quad file first.");return}gP(n),pn("Reference K loaded from quad file"),Fm()});const t=document.getElementById("cbParseKMeasurements");t&&t.addEventListener("click",kP),Dv("K")}function kP(){const e=kv("K","cbKMeasurementsInput");if(!e)return;if(e.length===0){pn("Enter L* measurements first");return}if(e.length<3){pn("Need at least 3 measurement points");return}const t=document.getElementById("cbKInkLimit"),n=parseFloat(t?.value)||33;if(n<=0||n>100){pn("K ink limit must be between 1 and 100%");return}if(hP(n,e,gv)){const i=Oo();pn(`Reference K set: ink limit ${n}%, dMax = ${i.dMax?.toFixed(3)||"N/A"}`),Fm()}else pn("Failed to set reference K. Check measurements.")}function Fm(){const e=Oo(),t=document.getElementById("cbKStatus");if(!t)return;const n=document.getElementById("cbKInkLimit");if(n&&e?.inkLimit!=null&&(n.value=e.inkLimit),e&&e.dMax!==null){const r=e.inkLimit!=null?`${e.inkLimit}%`:"N/A";t.innerHTML=`
            <div class="p-3 bg-green-50 border border-green-200 rounded text-sm">
                <div class="font-semibold text-green-800">Reference K Set</div>
                <div class="text-green-700 mt-1">
                    Ink Limit: <span class="font-mono">${r}</span>
                    &nbsp;|&nbsp;
                    dMax: <span class="font-mono">${e.dMax.toFixed(3)}</span>
                    &nbsp;|&nbsp;
                    Points: ${e.measurements?.length||0}
                    ${e.curve?" | Linear ramp generated":""}
                </div>
            </div>
        `}else if(e?.curve){const r=e.inkLimit!=null?`${e.inkLimit}%`:"N/A";t.innerHTML=`
            <div class="p-3 bg-yellow-50 border border-yellow-200 rounded text-sm">
                <div class="font-semibold text-yellow-800">K Curve Imported</div>
                <div class="text-yellow-700 mt-1">
                    Ink Limit: ${r}
                    &nbsp;|&nbsp;
                    Enter L* measurements to compute dMax
                </div>
            </div>
        `}else t.innerHTML=`
            <div class="p-3 bg-gray-50 border border-gray-200 rounded text-sm text-gray-600">
                No reference K set. Enter ink limit and L* measurements above.
            </div>
        `}function DP(){const e=document.getElementById("cbChannelSelect");if(e){const n=["C","M","Y","LC","LM","LK","LLK","OR","GR","V"];e.innerHTML=n.map(r=>`<option value="${r}">${r}</option>`).join("")}const t=document.getElementById("cbAddChannelBtn");t&&t.addEventListener("click",PP),Dv("Ch")}function PP(){const e=document.getElementById("cbChannelSelect"),t=document.getElementById("cbInkLimit");if(!e||!t)return;const n=e.value,r=parseFloat(t.value)||100,i=kv("Ch","cbChannelMeasurementsInput");if(!i)return;if(i.length===0){pn("Enter L* measurements for the channel");return}const a=yv(i);if(!a.valid){pn("Validation errors: "+a.errors.join("; "));return}a.warnings.length>0&&console.warn("[ChannelBuilder] Warnings:",a.warnings);const o=Oo();if(!o||o.dMax===null){pn("Set reference K first");return}const s=Ac(),l=dP(o,{inkLimit:r,measurements:i},{...s,existingSecondaries:Bi().map(u=>({curve:u.computed?.curve,endPercent:u.computed?.end})).filter(u=>u.curve)});if(bP({name:n,inkLimit:r,measurements:i,computed:{dMax:l.dMax,apex:l.recommendedApex,widthFactor:l.recommendedWidth,end:l.recommendedEnd,role:l.role,curve:l.curve}}),o.curve){const u=Bi().map(h=>({curve:h.computed?.curve,endPercent:h.computed?.end})).filter(h=>h.curve);let d=50;const p=Bi().find(h=>h.computed?.role==="midtone");p&&(d=p.computed.apex);const f=Tm(u,o.curve,d,s);sf({curve:f.kCurve,startIndex:f.startIndex,midtonePeakPercent:d})}pn(`Added ${n}: apex ${l.recommendedApex.toFixed(1)}%, end ${l.recommendedEnd.toFixed(1)}%`);const c=document.getElementById("cbChannelMeasurementsInput");c&&(c.value=""),Du("Ch"),Gm()}function Gm(){const e=document.getElementById("cbChannelList");if(!e)return;const t=Bi();if(t.length===0){e.innerHTML='<div class="text-gray-500 text-sm">No channels added yet</div>';return}e.innerHTML=t.map(n=>`
        <div class="flex items-center justify-between p-2 bg-gray-50 rounded border" data-channel="${n.name}">
            <div>
                <span class="font-semibold">${n.name}</span>
                <span class="text-gray-500 text-sm ml-2">
                    ${n.computed?`Apex: ${n.computed.apex.toFixed(1)}% | End: ${n.computed.end.toFixed(1)}% | ${n.computed.role}`:"Not computed"}
                </span>
            </div>
            <button class="text-red-500 hover:text-red-700 text-sm cb-remove-channel" data-channel="${n.name}">
                Remove
            </button>
        </div>
    `).join(""),e.querySelectorAll(".cb-remove-channel").forEach(n=>{n.addEventListener("click",r=>{const i=r.target.dataset.channel;yP(i);const a=Oo(),o=Bi();if(a?.curve&&o.length>0){const s=o.map(p=>({curve:p.computed?.curve,endPercent:p.computed?.end})).filter(p=>p.curve);let l=50;const c=o.find(p=>p.computed?.role==="midtone");c&&(l=c.computed.apex);const u=Ac(),d=Tm(s,a.curve,l,u);sf({curve:d.kCurve,startIndex:d.startIndex,midtonePeakPercent:l})}else sf(null);Gm(),pn(`Removed ${i}`)})})}function xP(){const e=document.getElementById("cbPreviewContent");if(!e)return;const t=Bi(),n=Om(),r=Oo();let i='<div class="space-y-4">';if(n){const o=(n.startIndex/255*100).toFixed(1);i+=`
            <div class="p-3 bg-gray-100 rounded">
                <div class="font-semibold">K Carve-Out</div>
                <div class="text-sm text-gray-600 mt-1">
                    K starts at: ${o}% | Midtone anchor: ${n.midtonePeakPercent.toFixed(1)}%
                </div>
            </div>
        `}i+='<div class="font-semibold">Channel Summary</div>',r&&(i+=`
            <div class="p-2 bg-gray-50 rounded border-l-4 border-gray-400">
                <span class="font-semibold">K</span>
                <span class="text-gray-500 text-sm ml-2">
                    Reference dMax: ${r.dMax?.toFixed(3)||"N/A"}
                    ${n?" | Carved out":""}
                </span>
            </div>
        `),t.forEach(o=>{const s=o.computed?.role==="highlight"?"blue":o.computed?.role==="midtone"?"green":"orange";i+=`
            <div class="p-2 bg-gray-50 rounded border-l-4 border-${s}-400">
                <span class="font-semibold">${o.name}</span>
                <span class="text-gray-500 text-sm ml-2">
                    ${o.computed?`Apex: ${o.computed.apex.toFixed(1)}% | End: ${o.computed.end.toFixed(1)}% | ${o.computed.role}`:"Not computed"}
                </span>
            </div>
        `});const a=vP();if(a.length>0){const o=uP(a,50,100);o.length>0?i+=`
                <div class="p-3 bg-yellow-50 border border-yellow-200 rounded mt-4">
                    <div class="font-semibold text-yellow-800">Total Ink Warnings</div>
                    <ul class="text-sm text-yellow-700 mt-1 list-disc list-inside">
                        ${o.slice(0,5).map(s=>`<li>${s}</li>`).join("")}
                        ${o.length>5?`<li>...and ${o.length-5} more</li>`:""}
                    </ul>
                </div>
            `:i+=`
                <div class="p-3 bg-green-50 border border-green-200 rounded mt-4">
                    <div class="text-green-700 text-sm">Total ink within limits</div>
                </div>
            `}i+="</div>",e.innerHTML=i}function BP(){const e=document.getElementById("cbApplyContent");if(!e)return;const t=Bi(),n=Om();let r='<div class="space-y-4">';r+=`
        <div class="p-4 bg-gray-50 rounded border">
            <div class="font-semibold mb-2">Changes to Apply</div>
            <ul class="text-sm text-gray-700 space-y-1">
    `,n&&(r+="<li>K curve will be carved out where secondaries provide coverage</li>"),t.forEach(i=>{i.computed?.curve&&(r+=`<li>${i.name}: Bell curve at ${i.computed.apex.toFixed(1)}%, End ${i.computed.end.toFixed(1)}%</li>`)}),r+=`
            </ul>
        </div>
        <div class="text-sm text-gray-500">
            Click "Apply & Close" to apply these changes to the current quad.
        </div>
    `,r+="</div>",e.innerHTML=r}function TP(){const e=Ee();if(!e){pn("No quad data loaded");return}const t=Bi(),n=Om();n?.curve&&e.curves.K&&(e.curves.K=n.curve.slice(),e.baselineEnd&&(e.baselineEnd.K=Math.max(...n.curve))),t.forEach(i=>{i.computed?.curve&&(e.curves[i.name]=i.computed.curve.slice(),e.baselineEnd&&(e.baselineEnd[i.name]=Math.max(...i.computed.curve)))});const r=Oo();r?.dMax!=null&&tc("K",r.dMax),t.forEach(i=>{i.computed?.dMax!=null&&tc(i.name,i.computed.dMax)}),typeof window.updateChartFromData=="function"&&window.updateChartFromData(),pn(`Applied ${t.length} channel${t.length!==1?"s":""} + K carve-out`)}function OP(e){Rm()}function Rm(){CP(),Fm(),Gm(),xP(),BP()}function lb(e,t){const n=document.getElementById(`cb${e}EntryPaste`),r=document.getElementById(`cb${e}EntryManual`),i=document.getElementById(`cb${e}EntryModePaste`),a=document.getElementById(`cb${e}EntryModeManual`);t==="paste"?(n?.classList.remove("hidden"),r?.classList.add("hidden"),i?.classList.add("border-green-600","text-gray-800"),i?.classList.remove("border-transparent","text-gray-500"),a?.classList.remove("border-green-600","text-gray-800"),a?.classList.add("border-transparent","text-gray-500")):(n?.classList.add("hidden"),r?.classList.remove("hidden"),i?.classList.remove("border-green-600","text-gray-800"),i?.classList.add("border-transparent","text-gray-500"),a?.classList.add("border-green-600","text-gray-800"),a?.classList.remove("border-transparent","text-gray-500"),Du(e)),ku({entryMode:t})}function Du(e){const t=document.getElementById(`cb${e}EntryRows`),n=document.getElementById(`cb${e}RowCount`);if(!t)return;const r=e==="K"?Ti:Oi;n&&(n.textContent=r),t.innerHTML="";for(let i=0;i<r;i++)t.insertAdjacentHTML("beforeend",FD(i,{total:r,targetLstarFloor:Mv,compact:!0,xInputClass:`cb${e}-measured-x`,lInputClass:`cb${e}-lstar-input`}));t.querySelectorAll("input").forEach(i=>{i.addEventListener("input",()=>df(e))}),df(e)}function df(e){const t=document.getElementById(`cb${e}EntryRows`),n=document.getElementById(`cb${e}Validation`);if(!t)return;const r=GD(t,{minRows:Mc,targetLstarFloor:Mv,xInputClass:`cb${e}-measured-x`,lInputClass:`cb${e}-lstar-input`});return n&&(!r.valid&&r.errors.length>0?(n.textContent=r.errors[0],n.classList.remove("hidden")):n.classList.add("hidden")),r}function _P(e){if(e==="K"){if(Ti>=cf)return;Ti++}else{if(Oi>=cf)return;Oi++}Du(e),ku({manualRowCount:e==="K"?Ti:Oi})}function NP(e){if(e==="K"){if(Ti<=Mc)return;Ti--}else{if(Oi<=Mc)return;Oi--}Du(e),ku({manualRowCount:e==="K"?Ti:Oi})}function kv(e,t){const n=document.getElementById(`cb${e}EntryManual`);if(!(n&&!n.classList.contains("hidden"))){const a=document.getElementById(t);return FP(a?.value||"")}const i=df(e);return!i||!i.valid?null:RD(i.measuredPairs)}function Dv(e){const t=document.getElementById(`cb${e}EntryModePaste`),n=document.getElementById(`cb${e}EntryModeManual`),r=document.getElementById(`cb${e}AddRow`),i=document.getElementById(`cb${e}RemoveRow`);t?.addEventListener("click",()=>lb(e,"paste")),n?.addEventListener("click",()=>lb(e,"manual")),r?.addEventListener("click",()=>_P(e)),i?.addEventListener("click",()=>NP(e))}function FP(e){const t=e.trim().split(/[\r\n]+/),n=[];for(let r=0;r<t.length;r++){const i=t[r].trim();if(!i||i.startsWith("#"))continue;const a=i.split(/[,\t]+/).map(s=>s.trim());if(a.length>=2){const s=parseFloat(a[0]),l=parseFloat(a[1]);if(!isNaN(s)&&!isNaN(l)){n.push({input:s,lstar:l});continue}}const o=parseFloat(a[0]);if(!isNaN(o)){const s=r/Math.max(1,t.length-1)*100;n.push({input:s,lstar:o})}}return n.sort((r,i)=>r.input-i.input),n}typeof window<"u"&&(window.openChannelBuilderModal=Iv);let Dt=null,di=null,Ja=null,eo=null;function Pu(e){const t=e?.target;return!t||typeof t.closest!="function"?null:t.closest(".tooltip-trigger")}function GP(){if(Dt)return Dt;const e=document.createElement("div");return e.id="floatingTooltip",e.className="floating-tooltip hidden",e.setAttribute("role","tooltip"),e.style.position="fixed",e.style.zIndex="4000",document.body.appendChild(e),Dt=e,Dt}function xu(){Dt&&(Dt.classList.add("hidden"),Dt.textContent="",Dt.style.left="-9999px",Dt.style.top="-9999px",Dt.style.maxWidth="",Dt.style.width="",Dt.setAttribute("aria-hidden","true"),di=null,eo&&(eo.disconnect(),eo=null),Ja&&(cancelAnimationFrame(Ja),Ja=null))}function cb(e,t,n=8){const r=window.innerWidth||document.documentElement.clientWidth,i=window.innerHeight||document.documentElement.clientHeight,a={...e};a.left<n&&(a.left=n);const o=r-t.width-n;a.left>o&&(a.left=Math.max(n,o)),a.top<n&&(a.top=n);const s=i-t.height-n;return a.top>s&&(a.top=Math.max(n,s)),a}function zm(e){if(!Dt||!e||!document.body.contains(e)){xu();return}const t=e.getBoundingClientRect();Dt.style.left="0px",Dt.style.top="0px",Dt.style.maxWidth=`${Math.min(320,Math.max(180,window.innerWidth-32))}px`,Dt.style.width="auto";const n=Dt.getBoundingClientRect(),r={left:t.left+t.width/2-n.width/2,top:t.top-n.height-10};let i=cb(r,n);i.top+n.height+6>t.top&&t.top-n.height-10<8&&(i=cb({left:r.left,top:t.bottom+10},n)),Dt.style.left=`${Math.round(i.left)}px`,Dt.style.top=`${Math.round(i.top)}px`}const Pv=Ns(()=>{di&&Dt&&!Dt.classList.contains("hidden")&&zm(di)},16);function RP(e){const t=Pu(e);t&&xv(t)}function zP(e){const t=Pu(e);t&&di===t&&xu()}function UP(e){const t=Pu(e);t&&xv(t)}function $P(e){const t=Pu(e);t&&di===t&&xu()}function xv(e){const t=e?.getAttribute("data-tooltip");t&&(GP(),Dt.textContent=t,Dt.classList.remove("hidden"),Dt.setAttribute("aria-hidden","false"),di=e,zm(e),!eo&&typeof ResizeObserver<"u"&&(eo=new ResizeObserver(()=>Pv()),eo.observe(e)))}function VP(){if(di){if(!document.body.contains(di)){xu();return}Ja&&cancelAnimationFrame(Ja),Ja=requestAnimationFrame(()=>{zm(di)})}}function HP(){typeof document>"u"||(document.addEventListener("pointerenter",RP,!0),document.addEventListener("pointerleave",zP,!0),document.addEventListener("focusin",UP,!0),document.addEventListener("focusout",$P,!0),window.addEventListener("scroll",VP,!0),window.addEventListener("resize",Pv,!0))}const Bu=typeof window<"u",qP=65535;let kn=null,ca=null,to=null,no=null,ua=null,ai=null,Ai=null,Wn=null,Ua=null,$a=null,ro=null,io=null,ao=null,oo=null,Ji=null,Kn=null,Pd=null,xd=null,oi=null,da=null,pa=null,Bd=null,Td=!1,ub=!1,db=null;function Ge(e,t={}){const n=document.createElement(e);return t.className&&(n.className=t.className),t.dataset&&Object.entries(t.dataset).forEach(([r,i])=>{n.dataset[r]=i}),t.text&&(n.textContent=t.text),t.id&&(n.id=t.id),n}function Lc(e,t=1){return Number.isFinite(e)?`${e.toFixed(t)}%`:"â€”"}function Bv(e,t=1){return Number.isFinite(e)?`${(e*100).toFixed(t)}%`:"â€”"}function jP(e){if(!Number.isFinite(e)||e<0)return"â€”";const t=e/qP*100;return Lc(Math.max(0,Math.min(100,t)),1)}function Od(e){if(!Number.isFinite(e))return"â€”";const t=Math.abs(e);return t>=1e5?`${Math.round(e/1e3)}k`:t>=1e4?`${(e/1e3).toFixed(1)}k`:Math.round(e).toString()}function Ic(e,t=3){return Number.isFinite(e)?e.toFixed(t):"â€”"}function Tv(e){if(!Number.isFinite(e))return"â€”";const t=Math.max(0,Math.min(100,e*100));return Lc(t,1)}function _d(e,t=3,n=""){if(!Number.isFinite(e)||Math.abs(e)<1e-6)return`Â±0${n}`;const r=e.toFixed(t);return`${e>=0?"+":""}${r}${n}`}function pf(e){if(!e||!e.parentElement)return;const t=e.parentElement,n=document.getElementById("editPanelBody");if(!n){e.style.top="12px";return}let r=n,i=0;for(;r&&r!==t&&r instanceof HTMLElement;)i+=r.offsetTop||0,r=r.offsetParent;if(r===t){const a=Math.max(0,i-8);e.style.top=`${a}px`}else e.style.top="12px"}function WP(){if(!Bu||kn)return kn;const e=document.querySelector("[data-linearization-column]");if(!e)return null;getComputedStyle(e).position==="static"&&(e.style.position="relative"),getComputedStyle(e).position==="static"&&(e.style.position="relative"),kn=Ge("div",{className:"absolute inset-x-2 z-30 rounded-xl border border-slate-600 bg-slate-900/95 text-slate-100 shadow-2xl backdrop-blur-sm px-4 py-3 space-y-3 hidden",id:"compositeDebugPanel"}),kn.setAttribute("role","region"),kn.setAttribute("aria-label","Composite correction debug information");const n=Ge("div",{className:"flex items-center justify-between gap-3 text-sm font-semibold text-slate-50"});n.appendChild(Ge("span",{text:"Composite Debug"})),Ua=Ge("span",{dataset:{debugSelected:""},text:"â€”",className:"text-slate-300 font-medium"}),n.appendChild(Ua),$a=Ge("span",{dataset:{debugSmoothingBadge:""},className:"hidden rounded-full border border-amber-400/60 bg-amber-400/10 px-2 py-0.5 text-[11px] font-semibold text-amber-100 shadow-sm",text:"Smoothing window active"}),n.appendChild($a);const r=Ge("div",{className:"space-y-1.5 text-[13px] text-slate-100"}),i=Ge("div",{className:"flex items-start gap-2 text-slate-200",dataset:{debugMode:""}});i.appendChild(Ge("span",{className:"shrink-0 text-slate-300 font-medium",text:"Mode"})),ca=Ge("span",{className:"flex-1 text-slate-50 font-semibold"}),ca.textContent="â€”",i.appendChild(ca);const a=Ge("div",{className:"flex items-start gap-2"});a.appendChild(Ge("span",{className:"shrink-0 text-slate-300 font-medium",text:"Maxima"})),to=Ge("span",{dataset:{debugMaxima:""},className:"flex-1 text-slate-50 font-semibold"}),to.textContent="â€”",a.appendChild(to);const o=Ge("div",{className:"flex items-start gap-2"});o.appendChild(Ge("span",{className:"shrink-0 text-slate-300 font-medium",text:"Weights"})),no=Ge("span",{dataset:{debugWeights:""},className:"flex-1 text-slate-50 font-semibold"}),no.textContent="â€”",o.appendChild(no);const s=Ge("div",{className:"flex items-start gap-2",dataset:{debugMomentum:""}});s.appendChild(Ge("span",{className:"shrink-0 text-slate-300 font-medium",text:"Momentum"})),ua=Ge("span",{className:"flex-1 text-slate-50 font-semibold"}),ua.textContent="â€”",s.appendChild(ua),ai=s;const l=Ge("div",{className:"flex items-start gap-2",dataset:{debugCoverage:""}});l.appendChild(Ge("span",{className:"shrink-0 text-slate-300 font-medium",text:"Coverage"})),Ai=Ge("span",{className:"flex-1 text-slate-50 font-semibold"}),Ai.textContent="â€”",l.appendChild(Ai),Wn=l,r.append(i,a,o,s,l);const c=Ge("div",{className:"flex items-center gap-2 pt-1"});Pd=Ge("button",{id:"compositeDebugPrev",className:"px-2.5 py-1 rounded-md bg-slate-700 hover:bg-slate-600 text-slate-100 text-xs font-semibold transition-colors",text:"â—€"}),Kn=Ge("input",{id:"compositeDebugSnapshotInput",className:"flex-1 border border-slate-600 rounded-md px-2 py-1 bg-slate-900 text-xs text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-400"}),Kn.type="number",Kn.min="0",Kn.max="255",Kn.step="1",Kn.value="",xd=Ge("button",{id:"compositeDebugNext",className:"px-2.5 py-1 rounded-md bg-slate-700 hover:bg-slate-600 text-slate-100 text-xs font-semibold transition-colors",text:"â–¶"}),c.append(Pd,Kn,xd),da=Ge("div",{dataset:{debugFlags:""},className:"space-y-1 text-[12px] text-rose-100"});const u=Ge("div",{className:"flex items-center justify-between text-xs font-semibold uppercase tracking-wide text-rose-200"});u.appendChild(Ge("span",{text:"Flagged snapshots"})),da.appendChild(u),pa=Ge("div",{className:"flex flex-wrap gap-1.5"});const d=Ge("span",{className:"text-rose-200/70 italic",text:"No flagged snapshots"});d.dataset.emptyFlag="true",pa.appendChild(d),da.appendChild(pa);const p=Ge("div",{className:"space-y-1 text-[13px] text-slate-200"});return oo=Ge("div",{className:"font-semibold tracking-wide"}),oo.textContent="Ink â€”",ro=Ge("div",{dataset:{debugTarget:""},className:"font-medium"}),ro.textContent="Target Î”Ï â€”",io=Ge("div",{dataset:{debugMeasurement:""},className:"font-medium"}),io.textContent="Measured Ï â€”",ao=Ge("div",{dataset:{debugDelta:""},className:"text-sm text-slate-300 font-medium"}),ao.textContent="Î”Ï â€”",p.append(oo,ro,io,ao),Ji=Ge("div",{dataset:{debugChannels:""},className:"divide-y divide-slate-700 pt-2 text-[13px]"}),kn.append(n,r,c,da,p,Ji),e.appendChild(kn),pf(kn),pb(Pd,-1),pb(xd,1),Kn.addEventListener("keydown",f=>{if(f.key==="Enter"){f.preventDefault();const h=Number(Kn.value);Number.isFinite(h)&&Zc(Math.max(0,Math.min(255,Math.round(h))))}}),Kn.addEventListener("blur",()=>{const f=xo(),h=Number.isInteger(f.selection?.index)?f.selection.index:"";Kn.value=h===""?"":String(h)}),ub||(ub=!0,db=()=>{kn&&pf(kn)},window.addEventListener("resize",db,{passive:!0})),kn}function pb(e,t){if(!e||e.dataset.stepperAttached==="true")return;e.dataset.stepperAttached="true";const n=400,r=120;let i=null,a=null,o=!1;const s=()=>{i&&(clearTimeout(i),i=null),a&&(clearInterval(a),a=null)},l=()=>{s(),o=!1,Bu&&(i=window.setTimeout(()=>{o=!0,Rl(t),a=window.setInterval(()=>{Rl(t)},r)},n))},c=(p=!1)=>{s(),p&&(o=!1)},u=p=>{e.disabled||p.button!=null&&p.button!==0||l()};typeof window<"u"&&typeof window.PointerEvent<"u"?(e.addEventListener("pointerdown",u),e.addEventListener("pointerup",()=>c(!1)),e.addEventListener("pointerleave",()=>c(!0)),e.addEventListener("pointercancel",()=>c(!0))):(e.addEventListener("mousedown",u),e.addEventListener("mouseup",()=>c(!1)),e.addEventListener("mouseleave",()=>c(!0))),e.addEventListener("blur",()=>c(!0)),e.addEventListener("contextmenu",()=>c(!0)),e.addEventListener("click",p=>{if(o){p.preventDefault(),p.stopPropagation(),o=!1;return}Rl(t)})}function KP(){if(!Bu)return null;const e=document.querySelectorAll("tr[data-channel]"),t=new Set;return e.forEach(n=>{const r=n.getAttribute("data-channel");if(!r)return;const i=n.querySelector(".percent-input"),a=i?.value??i?.getAttribute?.("data-base-percent"),o=Number.parseFloat(String(a??"0").replace(/[^0-9.-]/g,""));Number.isFinite(o)&&o>0&&t.add(r)}),t}function YP(e){if(!to||!no)return;if(!e){oi=null,ca&&(ca.textContent="â€”"),to.textContent="â€”",no.textContent="â€”",ua&&(ua.textContent="â€”"),ai&&ai.classList.add("opacity-60"),Ai&&(Ai.textContent="â€”"),Wn&&(Wn.classList.add("opacity-60"),Wn.classList.remove("text-amber-200"),Wn.removeAttribute("title"));return}if(Array.isArray(e.channelNames)&&e.channelNames.length?oi=e.channelNames.slice():e.ladderOrderIndex&&typeof e.ladderOrderIndex=="object"?(oi=Object.entries(e.ladderOrderIndex).filter(i=>i&&typeof i[0]=="string"&&Number.isFinite(i[1])).sort((i,a)=>i[1]-a[1]).map(([i])=>i),oi.length||(oi=null)):oi=null,ca){const i={equal:"Equal",isolated:"Isolated",normalized:"Normalized",momentum:"Momentum"},a=typeof e.weightingMode=="string"?e.weightingMode.toLowerCase():"";ca.textContent=i[a]||"â€”"}const t=KP(),n=Object.entries(e.channelMaxima||{}).filter(([i])=>!t||!t.size?!0:t.has(i));n.sort((i,a)=>(a[1]||0)-(i[1]||0)),to.textContent=n.length?n.map(([i,a])=>`${i} ${jP(a)}`).join(", "):"â€”";const r=Object.entries(e.densityWeights||{});if(r.sort((i,a)=>(a[1]||0)-(i[1]||0)),no.textContent=r.length?r.map(([i,a])=>`${i} ${Ic(a,3)}`).join(", "):"â€”",ua){const i=Object.entries(e.momentumPeaks||{});i.sort((o,s)=>(s[1]||0)-(o[1]||0));const a=(e.weightingMode||"").toLowerCase()==="momentum"&&i.length>0;ai&&ai.classList.toggle("opacity-60",!a),ua.textContent=a?i.map(([o,s])=>`${o} ${Tv(s||0)}`).join(", "):"â€”",ai&&a&&e.momentumWindow!=null&&e.momentumSigma!=null?ai.title=`Gaussian window Â±${e.momentumWindow} â€¢ Ïƒ=${Ic(e.momentumSigma,2)}`:ai&&ai.removeAttribute("title")}if(Ai)if(e.perSampleCeilingEnabled!==!0)Ai.textContent="Disabled",Wn&&(Wn.classList.add("opacity-60"),Wn.classList.remove("text-amber-200"),Wn.removeAttribute("title"));else{const i=Object.entries(e.coverageSummary||{}).filter(([o])=>!t||!t.size?!0:t.has(o));i.sort((o,s)=>(Number(s[1]?.maxNormalized)||0)-(Number(o[1]?.maxNormalized)||0));const a=i.map(([o,s])=>{const l=Number(s?.maxNormalized),c=Array.isArray(s?.clampedSamples)?s.clampedSamples.length:Number(s?.overflow)||0,u=c>0?`Ã—${c}`:"ok";return`${o} ${Bv(Number.isFinite(l)?l:0,1)} ${u}`});if(Ai.textContent=a.length?a.join(", "):"â€”",Wn){const o=i.some(([s,l])=>(Array.isArray(l?.clampedSamples)?l.clampedSamples.length:Number(l?.overflow)||0)>0);if(Wn.classList.toggle("opacity-60",!a.length),Wn.classList.toggle("text-amber-200",o),o){const s=[];i.forEach(([l,c])=>{const u=Array.isArray(c?.clampedSamples)?c.clampedSamples:[];if(!u.length)return;const d=u.slice(0,3).map(p=>{const f=Number.isFinite(p.inputPercent)?`${p.inputPercent.toFixed(1)}%`:Number.isInteger(p.index)?`sample ${p.index}`:"sample";return Number.isFinite(p.overflowNormalized)&&p.overflowNormalized>0?`${f} (+${(p.overflowNormalized*100).toFixed(2)}%)`:f});s.push(`${l}: ${d.join(", ")}`)}),Wn.title=s.join(`
`)}else Wn.removeAttribute("title")}}}function XP(e){if(!e||typeof e!="object")return"";const t=[];if(Number.isFinite(e.percent)&&t.push(`Input ${e.percent.toFixed(1)}%`),Array.isArray(e.details)&&e.details.length){const n=e.details.map(r=>{if(!r||typeof r.channel!="string"||!r.channel)return null;if(Number.isFinite(r.delta)){const i=Math.abs(r.delta).toFixed(1),a=r.delta>=0?"+":"âˆ’";return`${r.channel}: ${a}${i}%`}if(Number.isFinite(r.magnitude)){const i=Math.abs(r.magnitude).toFixed(1),a=r.direction==="drop"?"âˆ’":"+";return`${r.channel}: ${a}${i}%`}return r.channel}).filter(Boolean);n.length&&t.push(`Channels: ${n.join(", ")}`)}else Array.isArray(e.channels)&&e.channels.length&&t.push(`Channels: ${e.channels.join(", ")}`);if(Number.isFinite(e.magnitude)){const n=e.kind==="drop"?"Drop":"Rise";t.push(`${n} ${e.magnitude.toFixed(1)}%`)}return Number.isFinite(e.threshold)&&t.push(`Threshold â‰¥ ${e.threshold.toFixed(1)}%`),t.join(`
`)}function QP(e){if(!da||!pa)return;const t=e?.flags&&typeof e.flags=="object"?e.flags:{},n=Array.isArray(e?.snapshots)?e.snapshots:[],r=Number.isInteger(e?.selection?.index)?e.selection.index:null,i=Object.entries(t).map(([a,o])=>{if(!o||typeof o!="object")return null;const s=Number.parseInt(a,10);if(!Number.isInteger(s))return null;const l=n[s]&&n[s]?.index===s?n[s]:n.find(u=>u&&u.index===s)||null,c=Number.isFinite(o.inputPercent)?o.inputPercent:l&&Number.isFinite(l.inputPercent)?l.inputPercent:null;return{index:s,kind:o.kind==="drop"?"drop":"rise",magnitude:Number.isFinite(o.magnitude)?o.magnitude:null,threshold:Number.isFinite(o.threshold)?o.threshold:null,percent:c,channels:Array.isArray(o.channels)?o.channels.slice():[],details:Array.isArray(o.details)?o.details.map(u=>({...u})):[]}}).filter(Boolean);if(i.sort((a,o)=>a.index-o.index),pa.innerHTML="",!i.length){da.classList.add("opacity-60");const a=Ge("span",{className:"text-rose-200/70 italic",text:"No flagged snapshots"});pa.appendChild(a);return}da.classList.remove("opacity-60"),i.forEach(a=>{const o=Ge("button",{className:"rounded-full border border-rose-400/70 bg-rose-500/10 px-2.5 py-1 text-xs font-semibold text-rose-100 hover:bg-rose-500/20 transition-colors flex items-center gap-1"});o.dataset.flagIndex=String(a.index);const s=a.kind==="drop"?"â†“":"â†‘",l=Number.isFinite(a.magnitude)?`${a.magnitude.toFixed(1)}%`:"";o.textContent=`ðŸš© #${a.index} ${s} ${l}`.trim(),r===a.index&&o.classList.add("ring-2","ring-rose-300");const c=XP(a);c&&(o.title=c),o.addEventListener("click",()=>Zc(a.index)),pa.appendChild(o)})}function ZP(e){if(!kn)return;const t=Number.isInteger(e.selection?.index)?e.selection.index:null,n=Number.isInteger(t)?e.snapshots?.[t]:null;if(!Ua||!Kn||!ro||!io||!ao||!Ji||!oo)return;if(!n){Ua.textContent="â€”",Kn.value="",ro.textContent="Target Ï â€”",io.textContent="Measured Ï â€”",ao.textContent="Î”Ï â€”",oo.textContent="Ink â€”",Ji.innerHTML='<div class="py-1 text-gray-500 dark:text-gray-400">Select a snapshot to view channel details.</div>',$a&&$a.classList.add("hidden");return}Ua.textContent=`#${n.index} (${Lc(n.inputPercent??0,1)})`,e.flags&&e.flags[t]&&(Ua.textContent+=" ðŸš©"),Kn.value=String(n.index),ro.textContent=`Target Ï ${Ic(n.targetDensity??NaN,4)}`,io.textContent=`Measured Ï ${n.measurementDensity!=null?Ic(n.measurementDensity,4):"â€”"}`,ao.textContent=`Î”Ï ${_d(n.deltaDensity??0,4)}`;const r=n.baselineInk??NaN,i=n.correctedInk??NaN,a=n.inkDelta??NaN,o=Number.isFinite(a)?`${a>=0?"+":""}${Od(Math.abs(a))}`:"â€”";oo.textContent=`Ink Î£ ${Od(r)} â†’ ${Od(i)} (${o})`;const s=new Map(Object.entries(n.perChannel||{}));let l=[];oi&&oi.length?l=oi.filter(p=>s.has(p)):e.summary?.ladderOrderIndex&&typeof e.summary.ladderOrderIndex=="object"&&(l=Object.entries(e.summary.ladderOrderIndex).filter(([p,f])=>s.has(p)&&Number.isFinite(f)).sort((p,f)=>p[1]-f[1]).map(([p])=>p));const c=Array.from(s.keys()).filter(p=>!l.includes(p));!l.length&&c.length&&c.sort(),l=l.concat(c);const u=l.map(p=>[p,s.get(p)]);if($a){let p=!1;Array.isArray(n.smoothingWindows)&&n.smoothingWindows.length?p=!0:Array.isArray(e.summary?.smoothingWindows)&&Number.isInteger(n.index)&&(p=e.summary.smoothingWindows.some(f=>{if(!f||typeof f!="object")return!1;const h=Number(f.startIndex),g=Number(f.endIndex);return!Number.isInteger(h)||!Number.isInteger(g)?!1:n.index>=h&&n.index<=g})),!p&&e.summary?.coverageSummary&&(p=Object.values(e.summary.coverageSummary).some(f=>{if(!f||typeof f!="object")return!1;const h=Number(f.overflow);return Number.isFinite(h)&&h>0})),$a.classList.toggle("hidden",!p)}if(!u.length){Ji.innerHTML='<div class="py-1 text-gray-500 dark:text-gray-400">No channel data available.</div>';return}const d=document.createDocumentFragment();u.slice(0,8).forEach(([p,f])=>{const h=Ge("div",{className:"py-2 flex items-start justify-between gap-3"}),g=Ge("div",{className:"flex items-center gap-2 text-sm font-semibold text-slate-50"}),b=Ge("span",{className:"inline-block w-3.5 h-3.5 rounded-full shadow-sm ring-2 ring-slate-900/30"}),S=ni?.[p]||"#94a3b8";b.style.backgroundColor=S;const E=Ge("span",{className:"tracking-wide uppercase",text:p});g.append(b,E);const y=Ge("div",{className:"text-right text-slate-100 space-y-1 leading-4"}),v=(W,fe=2)=>Number.isFinite(W)?Bv(W,fe):"â€”",A=Number.isFinite(f?.normalizedBefore)?f.normalizedBefore:null,w=Number.isFinite(f?.normalizedAfter)?f.normalizedAfter:null,M=Number.isFinite(f?.normalizedDelta)?f.normalizedDelta:null,I=Ge("div",{className:"text-[13px] font-semibold"});I.textContent=`${v(A,1)} â†’ ${v(w,1)} (${_d((M??0)*100,2,"%")})`,y.appendChild(I);const _=Number.isFinite(f?.shareAfter)?f.shareAfter:Number.isFinite(f?.shareBefore)?f.shareBefore:null;if(_!=null){const W=Ge("div",{className:"text-xs text-slate-300 font-medium",text:`Share ${v(_,1)}`});y.appendChild(W)}if(Number.isFinite(f?.momentum)){const W=Ge("div",{className:"text-xs text-sky-300 font-medium",text:`Momentum ${Tv(f.momentum)}`});y.appendChild(W)}const C=Ge("div",{className:"text-xs font-semibold text-emerald-300",text:`Î”Ï ${_d(f?.densityContributionDelta??0,4)}`});y.appendChild(C);const x=Number.isFinite(f?.coverageFloorNormalized)?f.coverageFloorNormalized:null,P=Number.isFinite(f?.layerNormalized)?f.layerNormalized:null,k=Number.isFinite(f?.allowedNormalized)?f.allowedNormalized:null;if(x!=null||P!=null||k!=null){const W=Ge("div",{className:"text-xs text-slate-400 font-medium",text:`Coverage floor ${v(x,2)} â€¢ Layer ${v(P,2)} â€¢ Allowed ${v(k,2)}`});y.appendChild(W)}const N=Number.isFinite(f?.capacityBeforeNormalized)?f.capacityBeforeNormalized:null,F=Number.isFinite(f?.capacityAfterNormalized)?f.capacityAfterNormalized:null,U=Number.isFinite(f?.effectiveHeadroomNormalized)?f.effectiveHeadroomNormalized:Number.isFinite(f?.effectiveHeadroomAfter)?f.effectiveHeadroomAfter:null;if(N!=null||F!=null||U!=null){const W=Ge("div",{className:"text-xs text-slate-400 font-medium",text:`Capacity ${v(N,2)} â†’ ${v(F,2)} â€¢ Effective ${v(U,2)}`});y.appendChild(W)}const j=typeof f?.reserveState=="string"?f.reserveState:null,B=Number.isFinite(f?.frontReserveBase)?f.frontReserveBase:null,G=Number.isFinite(f?.frontReserveApplied)?f.frontReserveApplied:null,V=Number.isFinite(f?.reserveAllowanceRemaining)?f.reserveAllowanceRemaining:Number.isFinite(f?.reserveAllowanceNormalized)?f.reserveAllowanceNormalized:null,K=Number.isFinite(f?.reserveReleaseScale)?f.reserveReleaseScale:null;if(j||B!=null||G!=null||V!=null||K!=null){const W=[];W.push(`State ${j||"â€”"}`),W.push(`Base ${v(B,2)}`),W.push(`Applied ${v(G,2)}`),W.push(`Allowance ${v(V,2)}`),K!=null&&W.push(`Release ${Lc(K*100,1)}`);const fe=Ge("div",{className:"text-xs text-slate-400 font-medium",text:W.join(" â€¢ ")});y.appendChild(fe)}const se=[];if(Number.isFinite(f?.blendCapNormalized)){const W=Number.isFinite(f?.blendProgress)&&Number.isFinite(f?.blendWindow)?` (${f.blendProgress}/${f.blendWindow})`:"";se.push(`Blend cap ${v(f.blendCapNormalized,2)}${W}`)}if(Number.isFinite(f?.blendAppliedNormalized)&&se.push(`Blend applied ${v(f.blendAppliedNormalized,2)}`),Number.isFinite(f?.shadowBlendCapNormalized)){const W=Number.isFinite(f?.shadowBlendProgress)&&Number.isFinite(f?.shadowBlendWindow)?` (${f.shadowBlendProgress}/${f.shadowBlendWindow})`:"",fe=Number.isFinite(f?.shadowBlendAppliedNormalized)?` applied ${v(f.shadowBlendAppliedNormalized,2)}`:"",Se=typeof f?.shadowBlendFromChannel=="string"&&f.shadowBlendFromChannel?` from ${f.shadowBlendFromChannel}`:"";se.push(`Shadow cap ${v(f.shadowBlendCapNormalized,2)}${W}${fe}${Se}`)}if(se.length){const W=Ge("div",{className:"text-xs text-indigo-300 font-medium",text:se.join(" â€¢ ")});y.appendChild(W)}h.append(g,y),d.appendChild(h)}),Ji.innerHTML="",Ji.appendChild(d)}function fb(e){if(kn){if(!e.enabled||!e.summary){kn.classList.add("hidden");return}kn.classList.remove("hidden"),pf(kn),YP(e.summary),QP(e),e.sessionId,ZP(e)}}function Ov(){if(!Bu)return;if(!WP()){Td||(Td=!0,setTimeout(()=>{Td=!1,Ov()},100));return}Bd&&Bd(),Bd=em(fb),fb(xo())}const _v="quadgen.activeTabHorizontal",Nv="quadgen.activeTabVertical",Fv="channels";let Va=Fv,ea=null,gn=[],bn=[],Io=[];function JP(){const e=document.querySelector(".tab-content-wrapper-vertical"),t=document.querySelector('.tab-content[data-tab-content="global"]');if(e&&t&&t.parentElement!==e&&e.appendChild(t),gn=Array.from(document.querySelectorAll(".tab-btn")),bn=Array.from(document.querySelectorAll(".tab-btn-vertical")),Io=Array.from(document.querySelectorAll(".tab-content")),gn.length===0&&bn.length===0||Io.length===0){console.warn("[TabManager] No tabs found in DOM");return}ex(),tx(),console.log(`[TabManager] Initialized ${gn.length} horizontal tabs and ${bn.length} vertical tabs`)}function ex(){if(gn.length===0)return;const e=ox(),t=gn.find(n=>n.classList.contains("active"));e&&gn.some(n=>n.dataset.tab===e)?Va=e:t&&t.dataset.tab?Va=t.dataset.tab:Va=Fv,gn.forEach(n=>{n.addEventListener("click",()=>{const r=n.dataset.tab;r&&os(r)})}),gn.forEach((n,r)=>{n.addEventListener("keydown",i=>{let a=-1;if(i.key==="ArrowRight"?(a=(r+1)%gn.length,i.preventDefault()):i.key==="ArrowLeft"&&(a=(r-1+gn.length)%gn.length,i.preventDefault()),a>=0){gn[a].focus();const o=gn[a].dataset.tab;o&&os(o)}})}),os(Va,!1)}function tx(){if(bn.length===0)return;const e=sx(),t=bn.find(n=>n.classList.contains("active"));e&&bn.some(n=>n.dataset.tab===e)?ea=e:t&&t.dataset.tab?ea=t.dataset.tab:ea=null,bn.forEach(n=>{n.addEventListener("click",()=>{const r=n.dataset.tab;r&&ss(r)})}),bn.forEach((n,r)=>{n.addEventListener("keydown",i=>{let a=-1;if(i.key==="ArrowDown"?(a=(r+1)%bn.length,i.preventDefault()):i.key==="ArrowUp"&&(a=(r-1+bn.length)%bn.length,i.preventDefault()),a>=0){bn[a].focus();const o=bn[a].dataset.tab;o&&ss(o)}})}),ea&&ss(ea,!1)}function os(e,t=!0){if(!e)return;const n=gn.find(a=>a.dataset.tab===e),r=Io.find(a=>a.dataset.tabContent===e);if(!n||!r){console.warn(`[TabManager] Horizontal tab not found: ${e}`);return}gn.forEach(a=>{a.classList.remove("active"),a.setAttribute("aria-selected","false")});const i=gn.map(a=>a.dataset.tab);Io.forEach(a=>{i.includes(a.dataset.tabContent)&&(a.classList.remove("active"),a.setAttribute("hidden",""))}),n.classList.add("active"),n.setAttribute("aria-selected","true"),r.classList.add("active"),r.removeAttribute("hidden"),Va=e,t&&lx(e),console.log(`[TabManager] Switched to horizontal tab: ${e}`)}function ss(e,t=!0){if(!e)return;const n=bn.find(a=>a.dataset.tab===e),r=Io.find(a=>a.dataset.tabContent===e);if(!n||!r){console.warn(`[TabManager] Vertical tab not found: ${e}`);return}bn.forEach(a=>{a.classList.remove("active"),a.setAttribute("aria-selected","false")});const i=bn.map(a=>a.dataset.tab);Io.forEach(a=>{i.includes(a.dataset.tabContent)&&(a.classList.remove("active"),a.setAttribute("hidden",""))}),n.classList.add("active"),n.setAttribute("aria-selected","true"),r.classList.add("active"),r.removeAttribute("hidden"),nx(n),ea=e,t&&cx(e),console.log(`[TabManager] Switched to vertical tab: ${e}`)}function nx(e){if(!e)return;const t=e.closest(".vertical-tab-nav");if(!t)return;const n=e.closest(".tab-btn-vertical-row");n&&t.lastElementChild!==n&&t.appendChild(n)}function rx(e,t=!0){if(gn.some(i=>i.dataset.tab===e)){os(e,t);return}if(bn.some(i=>i.dataset.tab===e)){ss(e,t);return}console.warn(`[TabManager] Tab not found in any group: ${e}`)}function ix(){return Va}function ax(){return ea}function ox(){try{return localStorage.getItem(_v)}catch(e){return console.warn("[TabManager] Failed to read horizontal tab from localStorage:",e),null}}function sx(){try{return localStorage.getItem(Nv)}catch(e){return console.warn("[TabManager] Failed to read vertical tab from localStorage:",e),null}}function lx(e){try{localStorage.setItem(_v,e)}catch(t){console.warn("[TabManager] Failed to save horizontal tab to localStorage:",t)}}function cx(e){try{localStorage.setItem(Nv,e)}catch(t){console.warn("[TabManager] Failed to save vertical tab to localStorage:",t)}}typeof window<"u"&&(window.TabManager={switchTab:rx,getActiveTab:ix,getActiveVerticalTab:ax,switchHorizontalTab:e=>os(e,!0),switchVerticalTab:e=>ss(e,!0)});const Gv="quadgen.chartHeight",Rv="60vh",ux=320,dx=80;let ks=!1,zv=0,Uv=0,Ha=null,$i=null;const $v="quadgen.rightPanelWidth",Vv="256px",px=256,fx=450;let Ds=!1,Hv=0,qv=0,qa=null,mi=null,Jr=null;function mx(){if(Ha=document.getElementById("chartDivider"),$i=document.getElementById("chartContainer"),!Ha||!$i){console.warn("[ChartDivider] Required elements not found in DOM");return}const e=hx();jv(e,!1),Ha.addEventListener("mousedown",mb),document.addEventListener("mousemove",hb),document.addEventListener("mouseup",gb),Ha.addEventListener("touchstart",t=>{const n=t.touches[0];mb({clientY:n.clientY}),t.preventDefault()}),document.addEventListener("touchmove",t=>{if(!ks)return;const n=t.touches[0];hb({clientY:n.clientY}),t.preventDefault()}),document.addEventListener("touchend",gb),console.log("[ChartDivider] Initialized with height:",e)}function mb(e){ks=!0,zv=e.clientY,Uv=$i.offsetHeight,Ha.classList.add("dragging"),document.body.style.cursor="row-resize",document.body.style.userSelect="none",e.preventDefault()}function hb(e){if(!ks)return;const t=e.clientY-zv,n=Uv+t,r=window.innerHeight,i=dx/100*r,a=Math.max(ux,Math.min(n,i));$i.style.height=`${a}px`,document.documentElement.style.setProperty("--chart-height",`${a}px`),e.preventDefault()}function gb(e){if(!ks)return;ks=!1,Ha.classList.remove("dragging"),document.body.style.cursor="",document.body.style.userSelect="";const t=$i.style.height;Wv(t),Tu(),console.log("[ChartDivider] Drag ended, height:",t)}function jv(e,t=!0){$i&&($i.style.height=e,document.documentElement.style.setProperty("--chart-height",e),t&&Wv(e),setTimeout(()=>{Tu()},50))}function hx(){try{const e=localStorage.getItem(Gv);if(e)return e}catch(e){console.warn("[ChartDivider] Failed to read from localStorage:",e)}return Rv}function Wv(e){try{localStorage.setItem(Gv,e)}catch(t){console.warn("[ChartDivider] Failed to save to localStorage:",t)}}function Tu(){typeof window<"u"&&window.dispatchEvent(new Event("chart-height-changed"))}function Kv(){if(qa=document.getElementById("panelDivider"),mi=document.getElementById("chartPanel"),Jr=document.getElementById("rightPanel"),!qa||!mi||!Jr){console.warn("[PanelDivider] Required elements not found in DOM - panel resize disabled");return}const e=bx();Yv(e,!1),qa.addEventListener("mousedown",bb),document.addEventListener("mousemove",yb),document.addEventListener("mouseup",Sb),qa.addEventListener("touchstart",t=>{const n=t.touches[0];bb({clientX:n.clientX}),t.preventDefault()}),document.addEventListener("touchmove",t=>{if(!Ds)return;const n=t.touches[0];yb({clientX:n.clientX}),t.preventDefault()}),document.addEventListener("touchend",Sb),console.log("[PanelDivider] Initialized with width:",e)}function bb(e){Ds=!0,Hv=e.clientX,qv=Jr.offsetWidth,mi.offsetWidth,qa.classList.add("dragging"),document.body.style.cursor="col-resize",document.body.style.userSelect="none",e.preventDefault()}function yb(e){if(!Ds)return;const t=e.clientX-Hv,n=qv-t,r=mi.parentElement.parentElement.offsetWidth-10,i=Math.max(px,Math.min(n,r*.5)),a=Math.max(fx,r-i-10);if(a+i+10>r)return;const o=mi.parentElement;o.style.flexBasis=`${a}px`,Jr.style.flexBasis=`${i}px`,document.documentElement.style.setProperty("--main-content-width",`${a}px`),document.documentElement.style.setProperty("--right-panel-width",`${i}px`),e.preventDefault()}function Sb(e){if(!Ds)return;Ds=!1,qa.classList.remove("dragging"),document.body.style.cursor="",document.body.style.userSelect="";const t=Jr.offsetWidth,n=mi.parentElement.parentElement.offsetWidth,r=t/n*100;Xv(`${r.toFixed(2)}%`),Tu(),console.log("[PanelDivider] Drag ended, width:",`${r.toFixed(2)}%`)}function Yv(e,t=!0){if(!Jr||!mi)return;const n=mi.parentElement;n&&(e.endsWith("%")?(Jr.style.flexBasis=e,n.style.flexBasis=`${100-parseFloat(e)}%`):(Jr.style.flexBasis=e,n.style.flexBasis="auto"),document.documentElement.style.setProperty("--right-panel-width",e),t&&Xv(e),setTimeout(()=>{Tu()},50))}function gx(){if(!Jr)return Vv;const e=Jr.offsetWidth,t=mi?.parentElement?.parentElement?.offsetWidth||1;return`${(e/t*100).toFixed(2)}%`}function bx(){try{const e=localStorage.getItem($v);if(e)return e}catch(e){console.warn("[PanelDivider] Failed to read from localStorage:",e)}return Vv}function Xv(e){try{localStorage.setItem($v,e)}catch(t){console.warn("[PanelDivider] Failed to save to localStorage:",t)}}typeof window<"u"&&(window.ChartDivider={updateChartHeight:jv,getCurrentHeight:()=>$i?.style.height||Rv,updatePanelWidth:Yv,getPanelWidth:gx,initPanelDivider:Kv});const Ou="quadgen.theme";function yx(){try{const e=Mb();return!!(e&&e("(prefers-color-scheme: dark)").matches)}catch{return!1}}function sl(e,t=!0){try{const n=document.documentElement;e==="dark"?n.setAttribute("data-theme","dark"):n.removeAttribute("data-theme"),t&&localStorage.setItem(Ou,e);const r=document.getElementById("themeToggle");if(r){const i=e==="dark";r.textContent=i?"â˜€ï¸":"ðŸŒ™",r.setAttribute("aria-pressed",i?"true":"false"),r.title=i?"Switch to light mode":"Switch to dark mode"}try{Je()}catch{}console.log(`ðŸŽ¨ Theme applied: ${e}`)}catch(n){console.error("Error applying theme:",n)}}function Qv(){const e=localStorage.getItem(Ou);return e&&(e==="dark"||e==="light")?e:"light"}function Zv(){const n=document.documentElement.getAttribute("data-theme")==="dark"?"light":"dark";return sl(n),n}function Jv(){console.log("ðŸŽ¨ Initializing theme system...");const e=Qv();sl(e,!1),Sx(),vx(),console.log("âœ… Theme system initialized")}function Sx(){const e=document.getElementById("themeToggle");if(!e){console.warn("Theme toggle button not found");return}e.addEventListener("click",()=>{Zv()}),console.log("ðŸŽ¨ Theme toggle button initialized")}function vx(){try{const e=Mb(),t=e?e("(prefers-color-scheme: dark)"):null;if(!t||!t.addEventListener&&!t.addListener)return;const n=r=>{const i=localStorage.getItem(Ou);(!i||i==="system")&&sl(r.matches?"dark":"light",!1)};t.addEventListener?t.addEventListener("change",n):t.addListener(n),console.log("ðŸŽ¨ System theme change listener initialized")}catch(e){console.warn("Failed to set up system theme listener:",e)}}function Ex(){localStorage.removeItem(Ou);const e=yx()?"dark":"light";sl(e,!1),console.log("ðŸŽ¨ Theme reset to system preference:",e)}function wx(){return document.documentElement.getAttribute("data-theme")==="dark"}Xe("theme",{applyTheme:sl,toggleTheme:Zv,getCurrentTheme:Qv,isDarkMode:wx,resetToSystemTheme:Ex,initializeTheme:Jv},{exposeOnWindow:!0,windowAliases:["applyTheme","toggleTheme","getCurrentTheme","isDarkMode","resetToSystemTheme"]});const pt=typeof window<"u"?window:globalThis,Nd=typeof document<"u";class eE{constructor(){this.lastAction=null,this.lastActionTime=null}_resolveChannel(t=null){if(t)return t;try{const n=lt();if(!n||!n.channels)return"K";for(const r of n.channels){const i=document.querySelector(`tr[data-channel="${r}"]`);if(i){const a=i.querySelector(".percent-input"),o=i.querySelector(".end-input"),s=a&&parseFloat(a.value)||0,l=o&&parseInt(o.value)||0;if(s>0||l>0)return r}}return n.channels[0]||"K"}catch(n){return console.warn("Error resolving channel:",n),"K"}}setChannelValue(t,n){try{const r=q.clampPercent(n),i=q.computeEndFromPercent(r),a=document.querySelector(`tr[data-channel="${t}"]`);if(!a)return{success:!1,message:`Channel ${t} not found`};const o=a.querySelector(".percent-input"),s=a.querySelector(".end-input");return o&&(o.value=r,o.dispatchEvent(new Event("input",{bubbles:!0})),o.dispatchEvent(new Event("change",{bubbles:!0}))),s&&(s.value=i,s.dispatchEvent(new Event("input",{bubbles:!0})),s.dispatchEvent(new Event("change",{bubbles:!0}))),Yn(t),Be(),{success:!0,message:`Set ${t} channel to ${r}%`}}catch(r){return{success:!1,message:`Error setting channel value: ${r.message}`}}}setChannelEndValue(t,n){try{const r=q.clampEndValue(n),i=q.computePercentFromEnd(r),a=document.querySelector(`tr[data-channel="${t}"]`);if(!a)return{success:!1,message:`Channel ${t} not found`};const o=a.querySelector(".percent-input"),s=a.querySelector(".end-input");return s&&(s.value=r,s.dispatchEvent(new Event("input",{bubbles:!0})),s.dispatchEvent(new Event("change",{bubbles:!0}))),o&&(o.value=i,o.dispatchEvent(new Event("input",{bubbles:!0})),o.dispatchEvent(new Event("change",{bubbles:!0}))),Yn(t),Be(),{success:!0,message:`Set ${t} channel end value to ${r} (${i}%)`}}catch(r){return{success:!1,message:`Error setting channel end value: ${r.message}`}}}applyToAllChannels(t){try{const n=q.clampPercent(t),r=lt();if(!r||!r.channels)return{success:!1,message:"No printer configuration available"};let i=0;const a=[];return r.channels.forEach(o=>{const s=document.querySelector(`tr[data-channel="${o}"]`);if(s){const l=s.querySelector(".percent-input"),c=s.querySelector(".end-input"),u=l&&parseFloat(l.value)||0,d=c&&parseInt(c.value)||0;if(u>0||d>0){const p=this.setChannelValue(o,n);a.push(`${o}: ${p.message}`),p.success&&i++}}}),{success:i>0,message:i>0?`Applied ${n}% to ${i} enabled channels`:"No enabled channels found to apply percentage to",details:a}}catch(n){return{success:!1,message:`Error applying to all channels: ${n.message}`}}}_applyGlobalLinearization(t,n,r,i){try{const a=Array.isArray(t.samples)?t.samples.length:0,o=ur(n,!1),s=r||Pt(t),l=i||`Applied global correction (${s})`;if(D.setGlobalData(t,!0,{source:"ai"}),typeof window<"u"&&typeof window.__quadSetGlobalBakedState=="function"&&window.__quadSetGlobalBakedState(null,{skipHistory:!0}),nt({linearizationData:t,linearizationApplied:!0}),Ri(t,{scope:"global",label:"global correction",source:"global-linearization"}),Nd&&(pt.linearizationData=t,pt.linearizationApplied=!0),m.globalLinearizationBtn&&m.globalLinearizationBtn.setAttribute("data-tooltip",`Loaded: ${o}`),m.globalLinearizationFilename&&(m.globalLinearizationFilename.textContent=n),m.globalLinearizationDetails&&(m.globalLinearizationDetails.textContent=` (${s})`),m.globalLinearizationToggle&&(m.globalLinearizationToggle.disabled=!1,m.globalLinearizationToggle.checked=!0,m.globalLinearizationToggle.setAttribute("aria-checked","true")),m.globalLinearizationInfo&&m.globalLinearizationInfo.classList.remove("hidden"),m.globalLinearizationHint&&m.globalLinearizationHint.classList.add("hidden"),Be(),Nd){if(typeof pt.updateInterpolationControls=="function")try{pt.updateInterpolationControls()}catch{}try{Er()}catch{}try{Li()}catch{}if(typeof pt.postGlobalDeltaChatSummary=="function")try{pt.postGlobalDeltaChatSummary()}catch{}}return Z(l),{success:!0,message:l,format:t.format,sampleCount:a}}catch(a){return console.error("Failed to apply global linearization:",a),{success:!1,message:`Error applying global linearization: ${a.message}`}}}_applyPerChannelLinearization(t,n,r,i){try{if(!t)return{success:!1,message:"Channel name is required for per-channel linearization"};const a=Array.isArray(n.samples)?n.samples.length:0,o=ur(r,!1),s=i||`Loaded ${t} correction (${Pt(n)})`;D.setPerChannelData(t,n,!0);const c={...gt().perChannelLinearization||{},[t]:n};nt({perChannelLinearization:c}),Ri(n,{scope:"channel",channelName:t,label:`${t} correction`,source:"per-channel-linearization"});let u=!1;const d=document.querySelector(`tr[data-channel="${t}"]`);if(d){const p=d.querySelector(".per-channel-btn");p&&p.setAttribute("data-tooltip",`Loaded: ${o}`);const f=d.querySelector(".per-channel-revert");f&&(f.disabled=!1,f.classList.remove("invisible"),f.title=`Revert ${t} to measurement`);const h=d.querySelector(".per-channel-toggle");if(h){h.disabled=!1,h.checked=!0,h.setAttribute("aria-checked","true");try{h.dispatchEvent(new Event("change",{bubbles:!0})),u=!0}catch(g){console&&console.warn&&console.warn("Unable to dispatch toggle change event:",g)}}}if(!u){Yn(t),Be();try{Er()}catch{}try{Li()}catch{}try{Je()}catch{}}return Z(s),{success:!0,message:s,channel:t,format:n.format,sampleCount:a}}catch(a){return console.error("Failed to apply per-channel linearization:",a),{success:!1,message:`Error applying per-channel linearization: ${a.message}`}}}loadLabData(t,n=!0,r=null){try{const i=typeof t=="string"?t.trim():"";if(!i)return{success:!1,message:"LAB data text is required"};let a=null;if(!n&&(a=(r||this._resolveChannel()).toUpperCase(),!(lt()?.channels||[]).includes(a)))return{success:!1,message:`Channel ${a} is not available for the current printer`};const o=n?"Lab Tech LAB (global).txt":`Lab Tech LAB (${a}).txt`,s=uo(i,o);if(!s||s.valid===!1)return{success:!1,message:s?.error||"Unable to parse LAB data"};const l=Nl(s);l.filename=o;const c=Rn(l);c.filename=o,c.edited=!1;const u=Array.isArray(c.samples)?c.samples.length:0,d=Pt(c);if(n){const f=`Loaded global LAB correction via Lab Tech (${d})`;return this._applyGlobalLinearization(c,o,d,f)}const p=`Loaded ${a} LAB correction via Lab Tech (${d})`;return this._applyPerChannelLinearization(a,c,o,p)}catch(i){return console.error("Failed to load LAB data:",i),{success:!1,message:`Error loading LAB data: ${i.message}`}}}applyManualLstarValues(t,n=null,r=null){try{if(!Array.isArray(t)||t.length<3)return{success:!1,message:"At least three L* values are required to build a correction"};const i=t.map(P=>Number(P)).filter(P=>Number.isFinite(P));if(i.length!==t.length)return{success:!1,message:"All L* values must be numeric"};const a=i.map(P=>Math.max(0,Math.min(100,P))),o=a.length,s=Array.isArray(r)&&r.length===o?r.map(P=>Number(P)):null,u={isValid:!0,measuredPairs:(s&&s.every(P=>Number.isFinite(P))?s.map(P=>Math.max(0,Math.min(100,P))):a.map((P,k)=>o===1?0:k/(o-1)*100)).map((P,k)=>({x:P,l:a[k]}))},d=gu(u);if(!d||d.valid===!1)return{success:!1,message:d?.error||"Unable to generate manual L* correction"};const p=Rn(d);p.edited=!1;const f=P=>({...p,samples:Array.isArray(p.samples)?p.samples.slice():[],baseSamples:Array.isArray(p.baseSamples)?p.baseSamples.slice():void 0,rawSamples:Array.isArray(p.rawSamples)?p.rawSamples.slice():void 0,previewSamples:Array.isArray(p.previewSamples)?p.previewSamples.slice():void 0,originalData:Array.isArray(p.originalData)?p.originalData.map(k=>({...k})):[],filename:P,edited:!1}),h=Pt(p),g=Array.isArray(p.samples)?p.samples.length:0,b="Lab Tech Manual L* (global).txt",S=f(b),E=`Applied manual L* correction via Lab Tech (${h})`,y=this._applyGlobalLinearization(S,b,h,E);if(!n)return y.success&&(y.sampleCount=g),y;const v=n.toUpperCase();if(!(lt()?.channels||[]).includes(v))return{success:!1,message:`Channel ${v} is not available for the current printer`,details:{global:y}};const M=`Lab Tech Manual L* (${v}).txt`,I=f(M),_=`Loaded ${v} Manual L* correction via Lab Tech (${h})`,C=this._applyPerChannelLinearization(v,I,M,_),x=y.success&&C.success;return{success:x,message:x?`Applied manual L* correction globally and to ${v}`:`Results â€” global: ${y.message}; ${v}: ${C.message}`,channel:v,sampleCount:g,details:{global:y,perChannel:C}}}catch(i){return console.error("Failed to apply manual L* values:",i),{success:!1,message:`Error applying manual L* values: ${i.message}`}}}async scaleChannelEndsByPercent(t){try{const n=Number(t);if(!Number.isFinite(n)||n<=0)return{success:!1,message:`Invalid scale percent '${t}'`};const r=await tr.scale(n,"ai",{priority:"high",metadata:{trigger:"ai-scale_command"}});if(this._updateGraphStatus(),r&&typeof r=="object"){const i=typeof r.success=="boolean"?r.success:!0,a=r.message||`Scaled channels by ${t}%`;return{success:i,message:a,details:r.details}}return{success:!0,message:`Scaled channels by ${t}%`}}catch(n){return{success:!1,message:`Error scaling channels: ${n.message}`}}}changePrinter(t){try{if(!t||!dn[t])return{success:!1,message:`Invalid printer '${t}'. Available printers: ${Object.keys(dn).join(", ")}`};Su(t,{silent:!1});const n=dn[t];return this._updateGraphStatus(),{success:!0,message:`Switched to ${n.name}`}}catch(n){return console.error("Error changing printer:",n),{success:!1,message:`Error changing printer: ${n.message}`}}}getCurrentState(){try{const t=lt(),n=YE(),r={};return t&&t.channels&&t.channels.forEach(i=>{const a=document.querySelector(`tr[data-channel="${i}"]`);if(a){const o=a.querySelector(".percent-input"),s=a.querySelector(".end-input");r[i]={percentage:o&&parseFloat(o.value)||0,endValue:s&&parseInt(s.value)||0,enabled:(o&&parseFloat(o.value)||0)>0||(s&&parseInt(s.value)||0)>0}}}),{success:!0,message:"Retrieved current application state",data:{channels:r,printer:t||{name:"Unknown",channels:["K"]},hasLoadedQuad:!!Ee()?.curves,linearizationApplied:!!(D?.globalApplied||gt().linearizationApplied),autoWhiteLimit:!!m?.autoWhiteLimitToggle?.checked,autoBlackLimit:!!m?.autoBlackLimitToggle?.checked}}}catch(t){return{success:!1,message:`Error getting current state: ${t.message}`,data:{channels:{},printer:{name:"Unknown",channels:["K"]}}}}}generateAndDownloadQuadFile(){try{const t=Cm();return t&&typeof t=="object"&&t.success!==!1?{success:!0,message:"Generated and downloaded quad file successfully"}:{success:!1,message:t?.message||"Failed to generate quad file"}}catch(t){return{success:!1,message:`Error generating quad file: ${t.message}`}}}enableDisableChannel(t,n){try{const r=document.querySelector(`tr[data-channel="${t}"]`);if(!r)return{success:!1,message:`Channel ${t} not found`};const i=r.querySelector(".percent-input"),a=r.querySelector(".end-input");if(n){const o=i&&parseFloat(i.value)||0,s=a&&parseInt(a.value)||0;if(o===0&&s===0){const c=q.computeEndFromPercent(100);i&&(i.value=100,i.dispatchEvent(new Event("input",{bubbles:!0})),i.dispatchEvent(new Event("change",{bubbles:!0}))),a&&(a.value=c,a.dispatchEvent(new Event("input",{bubbles:!0})),a.dispatchEvent(new Event("change",{bubbles:!0})))}}else i&&(i.value=0,i.dispatchEvent(new Event("input",{bubbles:!0})),i.dispatchEvent(new Event("change",{bubbles:!0}))),a&&(a.value=0,a.dispatchEvent(new Event("input",{bubbles:!0})),a.dispatchEvent(new Event("change",{bubbles:!0})));return Yn(t),Be(),{success:!0,message:`${n?"Enabled":"Disabled"} ${t} channel`}}catch(r){return{success:!1,message:`Error toggling channel: ${r.message}`}}}setContrastIntentPreset(t,n={}){try{const r=["linear","gentle","moderate","strong","custom"];return r.includes(t)?(console.warn(`QuadGenActions.setContrastIntentPreset: ${t} preset not yet implemented`),{success:!1,message:`Contrast intent preset '${t}' recognized but not yet implemented`}):{success:!1,message:`Invalid preset: ${t}. Valid presets: ${r.join(", ")}`}}catch(r){return{success:!1,message:`Error setting contrast intent: ${r.message}`}}}revertGlobalToMeasurement(){try{const t=Mo(),{isMeasurement:n,hasSmartEdits:r,wasEdited:i,isBaked:a,globalData:o}=t;if(a)return{success:!1,message:"Global measurement already baked into Smart curves. Use undo to restore."};if(!n||!(r||i))return{success:!1,message:"No global measurement edits to revert"};try{pt.CurveHistory?.captureState?.("Before: Revert Global to Measurement (AI)")}catch(u){console.warn("CurveHistory capture failed during AI revert (global):",u)}const s=lt(),l=Array.isArray(s?.channels)?s.channels:[],c=Im(l,{skipUiRefresh:!0,forceReinitialize:!0});return o&&(o.edited=!1,D.setGlobalData(o,!0,{source:"measurement"}),typeof window<"u"&&typeof window.__quadSetGlobalBakedState=="function"&&window.__quadSetGlobalBakedState(null,{skipHistory:!0}),nt({linearizationData:o,linearizationApplied:!0}),Nd&&(pt.linearizationData=o,pt.linearizationApplied=!0)),Be(),Je(),po(),Pn(),this._updateGraphStatus(),Er(),Z("Reverted to measurement (global)"),{success:!0,message:"Global measurement restored",seededChannels:c.seeded,reinitializedChannels:c.reinitialized}}catch(t){return console.error("QuadGenActions.revertGlobalToMeasurement failed:",t),{success:!1,message:`Error reverting global measurement: ${t.message}`}}}revertChannelToMeasurement(t){try{const n=t||this._resolveChannel(),r=D.getPerChannelData(n),i=D.isPerChannelEnabled(n);if(!r||!i)return{success:!1,message:`${n} has no measurement data loaded`};try{pt.CurveHistory?.captureState?.(`Before: Revert ${n} to Measurement (AI)`)}catch(u){console.warn("CurveHistory capture failed during AI revert (per-channel):",u)}r.edited=!1,D.setPerChannelData(n,r,!0);const a=gt(),o={...a.perChannelLinearization||{}};o[n]=r;const s={...a.perChannelEnabled||{}};s[n]=!0,nt({perChannelLinearization:o,perChannelEnabled:s});const l=yu(n,{skipUiRefresh:!0,forceReinitialize:!0}),c=document.querySelector(`tr[data-channel="${n}"]`);if(c){c.removeAttribute("data-allow-toggle");const u=c.querySelector(".per-channel-toggle");u&&(u.disabled=!1,u.checked=!0,u.setAttribute("aria-checked","true"));const d=c.querySelector(".per-channel-revert");if(d&&(d.disabled=!0,d.classList.add("invisible")),typeof c.refreshDisplayFn=="function")try{c.refreshDisplayFn()}catch(p){console.warn("Per-channel display refresh failed after AI revert:",p)}}return Yn(n),Be(),Je(),Er(),Li(),Pn(),Z(`Reverted ${n} to measurement`),{success:!0,message:`Reverted ${n} to measurement`,channel:n,restoredFromSeed:!!l?.restoredFromSeed}}catch(n){return console.error("QuadGenActions.revertChannelToMeasurement failed:",n),{success:!1,message:`Error reverting channel: ${n.message}`}}}_updateGraphStatus(){try{Li();const t=lt();(t&&t.channels?t.channels:["K","C","M","Y"]).forEach(r=>{try{Yn(r)}catch(i){console.warn(`Failed to update processing detail for ${r}:`,i)}})}catch(t){console.warn("Error updating graph status:",t)}}setAutoWhiteLimit(t){try{const n=document.getElementById("autoWhiteLimitToggle");return n?(n.checked=!!t,n.dispatchEvent(new Event("change",{bubbles:!0})),this._updateGraphStatus(),{success:!0,message:t?"Auto white limit enabled":"Auto white limit disabled"}):{success:!1,message:"Auto white limit controls not found (feature may be disabled)"}}catch(n){return{success:!1,message:`Error setting auto white limit: ${n.message}`}}}setAutoBlackLimit(t){try{const n=document.getElementById("autoBlackLimitToggle");return n?(n.checked=!!t,n.dispatchEvent(new Event("change",{bubbles:!0})),this._updateGraphStatus(),{success:!0,message:t?"Auto black limit enabled":"Auto black limit disabled"}):{success:!1,message:"Auto black limit controls not found (feature may be disabled)"}}catch(n){return{success:!1,message:`Error setting auto black limit: ${n.message}`}}}insertSmartKeyPointAt(t,n,r=null){try{const i=bm(t,n,r);return i.success?(Be(),Yn(t)):i&&i.message&&Z(i.message),i}catch(i){return console.error("Failed to insert Smart key point:",i),{success:!1,message:`Error inserting point: ${i.message}`}}}deleteSmartKeyPointByIndex(t,n,r={}){try{const i=ym(t,n,r);return i.success?(Be(),Yn(t)):i&&i.message&&Z(i.message),i}catch(i){return console.error("Failed to delete Smart key point:",i),{success:!1,message:`Error deleting point: ${i.message}`}}}adjustSmartKeyPointByIndex(t,n,r={}){try{const i=rl(t,n,r);return i.success&&(Be(),Yn(t)),i}catch(i){return console.error("Failed to adjust Smart key point:",i),{success:!1,message:`Error adjusting point: ${i.message}`}}}simplifySmartKeyPointsFromCurve(t,n={}){try{const r=Fi(t,n);return r.success&&(Be(),Yn(t)),r}catch(r){return console.error("Failed to simplify Smart key points:",r),{success:!1,message:`Error simplifying points: ${r.message}`}}}setLabSpotMarkers(t){try{if(typeof t!="boolean")return{success:!1,message:"enabled parameter must be a boolean"};if(typeof pt.setLabSpotMarkerOverlayEnabled=="function"){const n=pt.setLabSpotMarkerOverlayEnabled(t);return{success:!0,message:`Measurement spot markers ${t?"enabled":"disabled"}`,enabled:n}}else return{success:!1,message:"setLabSpotMarkerOverlayEnabled function not available"}}catch(n){return console.error("Failed to set lab spot markers:",n),{success:!1,message:`Error: ${n.message}`}}}setAutoRaiseInkLimits(t){try{if(typeof t!="boolean")return{success:!1,message:"enabled parameter must be a boolean"};if(typeof pt.enableAutoRaiseInkLimitsOnImport=="function"){const n=pt.enableAutoRaiseInkLimitsOnImport(t);return{success:!0,message:`Auto-raise ink limits ${t?"enabled":"disabled"}`,enabled:n}}else return{success:!1,message:"enableAutoRaiseInkLimitsOnImport function not available"}}catch(n){return console.error("Failed to set auto-raise ink limits:",n),{success:!1,message:`Error: ${n.message}`}}}setLightBlockingOverlay(t){try{if(typeof t!="boolean")return{success:!1,message:"enabled parameter must be a boolean"};if(typeof pt.setLightBlockingOverlayEnabled=="function"){const n=pt.setLightBlockingOverlayEnabled(t);return{success:!0,message:`Light-blocking overlay ${t?"enabled":"disabled"}`,enabled:n}}else return{success:!1,message:"setLightBlockingOverlayEnabled function not available"}}catch(n){return console.error("Failed to set light-blocking overlay:",n),{success:!1,message:`Error: ${n.message}`}}}setCorrectionMethod(t){try{if(t!=="simple"&&t!=="density_solver")return{success:!1,message:'method must be "simple" or "density_solver"'};if(typeof pt.enableSimpleScalingCorrection=="function"){const n=t==="simple",r=pt.enableSimpleScalingCorrection(n);return{success:!0,message:`Correction method set to ${t==="simple"?"Simple Scaling":"Density Solver"}`,method:t,enabled:r}}else return{success:!1,message:"enableSimpleScalingCorrection function not available"}}catch(n){return console.error("Failed to set correction method:",n),{success:!1,message:`Error: ${n.message}`}}}setCorrectionGain(t){try{if(typeof t!="number"||t<0||t>100)return{success:!1,message:"percent must be a number between 0 and 100"};if(typeof pt.setCorrectionGainPercent=="function"){pt.setCorrectionGainPercent(t,{updateUI:!0});const n=typeof pt.getCorrectionGainPercent=="function"?pt.getCorrectionGainPercent():t;return{success:!0,message:`Correction gain set to ${t}%`,percent:n}}else return{success:!1,message:"setCorrectionGainPercent function not available"}}catch(n){return console.error("Failed to set correction gain:",n),{success:!1,message:`Error: ${n.message}`}}}getCorrectionGain(){try{if(typeof pt.getCorrectionGainPercent=="function")return{success:!0,percent:pt.getCorrectionGainPercent()};if(typeof pt.getCorrectionGain=="function"){const t=pt.getCorrectionGain();return{success:!0,percent:Math.round(t*100)}}else return{success:!1,message:"getCorrectionGain function not available"}}catch(t){return console.error("Failed to get correction gain:",t),{success:!1,message:`Error: ${t.message}`}}}lockChannel(t,n){try{return typeof n!="boolean"?{success:!1,message:"locked parameter must be a boolean"}:typeof pt.setChannelLock=="function"?(pt.setChannelLock(t,n),{success:!0,message:`Channel ${t} ${n?"locked":"unlocked"}`,channelName:t,locked:n}):{success:!1,message:"setChannelLock function not available"}}catch(r){return console.error("Failed to lock/unlock channel:",r),{success:!1,message:`Error: ${r.message}`}}}getChannelLockStatus(t=null){try{if(typeof pt.isChannelLocked=="function")if(t){const n=pt.isChannelLocked(t);return{success:!0,channelName:t,locked:n}}else{const n=lt();if(!n||!n.channels)return{success:!1,message:"No printer configured"};const r={};for(const i of n.channels)r[i]=pt.isChannelLocked(i);return{success:!0,locks:r}}else return{success:!1,message:"isChannelLocked function not available"}}catch(n){return console.error("Failed to get channel lock status:",n),{success:!1,message:`Error: ${n.message}`}}}}function Cx(){return new eE}const li={PROVIDER:"anthropic",WORKER_URL:"https://sparkling-shape-8b5a.marshmonkey.workers.dev",ANTHROPIC_MODEL:"claude-sonnet-4-5",OPENAI_MODEL:"gpt-5-mini",DEBUG_AI:!1,DEBUG_SMART:!1};function Ax(){return{provider:li.PROVIDER,model:li.ANTHROPIC_MODEL,workerUrl:li.WORKER_URL,debug:li.DEBUG_AI}}const Mx=[{name:"set_contrast_intent",description:"Set the contrast intent preset (linear, soft, hard, filmic) or explicit gamma.",parameters:{type:"object",properties:{preset:{type:"string",description:"Preset name: linear | soft | hard | filmic | gamma",enum:["linear","soft","hard","filmic","gamma"]},params:{type:"object",description:"Optional parameters for filmic or gamma presets",properties:{gamma:{type:"number",description:"Gamma value when preset='gamma' (e.g., 0.85, 1.20)"},filmicGain:{type:"number",description:"Filmic midtone gain (default 0.55)"},shoulder:{type:"number",description:"Filmic shoulder strength (default 0.35)"}}}},required:["preset"]}},{name:"apply_custom_intent_sliders",description:"Apply a custom intent using slider parameters (gamma or filmic-like).",parameters:{type:"object",properties:{gamma:{type:"number",description:"Custom gamma (used if gain/shoulder are at defaults)"},gain:{type:"number",description:"Filmic midtone gain (triggers filmic when not 0.55)"},shoulder:{type:"number",description:"Filmic shoulder (triggers filmic when not 0.35)"}},required:[]}},{name:"apply_custom_intent_paste",description:"Parse and apply a custom intent from pasted CSV/JSON data.",parameters:{type:"object",properties:{text:{type:"string",description:"Pasted CSV/JSON describing a 0â€“100% input to relative density target"}},required:["text"]}},{name:"get_contrast_intent",description:"Return the current contrast intent id/name/params and whether a saved custom exists.",parameters:{type:"object",properties:{},required:[]}},{name:"set_edit_mode",description:"Enable or disable Edit Mode for keyâ€‘point editing and overlays.",parameters:{type:"object",properties:{enabled:{type:"boolean",description:"true to enable Edit Mode; false to disable"}},required:["enabled"]}},{name:"explain_lab_linearization",description:"Return a concise explanation of quadGEN's LAB linearization and plotting semantics for user-facing help.",parameters:{type:"object",properties:{},required:[]}},{name:"set_channel_value",description:"Set the ink limit percentage for a specific channel",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},percentage:{type:"number",description:"Ink limit percentage (0-100)",minimum:0,maximum:100}},required:["channelName","percentage"]}},{name:"set_channel_end_value",description:"Set the ink limit end value for a specific channel (0-65535 range)",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},endValue:{type:"number",description:"Ink limit end value (0-65535). Common values: 21627 (~33%), 32768 (50%), 65535 (100%)",minimum:0,maximum:65535}},required:["channelName","endValue"]}},{name:"apply_to_all_channels",description:"Apply the same ink limit percentage to all enabled channels",parameters:{type:"object",properties:{percentage:{type:"number",description:"Ink limit percentage to apply to all enabled channels (0-100)",minimum:0,maximum:100}},required:["percentage"]}},{name:"apply_end_to_all_channels",description:"Apply the same ink limit end value to all enabled channels",parameters:{type:"object",properties:{endValue:{type:"number",description:"Ink limit end value to apply to all enabled channels (0-65535)",minimum:0,maximum:65535}},required:["endValue"]}},{name:"scale_channel_ends_by_percent",description:"Use the global Scale control to multiply every enabled channel's End against its cached baseline (100% = no change).",parameters:{type:"object",properties:{scalePercent:{type:"number",description:"Desired scale percent for all enabled channels (10â€“200). 100 leaves Ends unchanged.",minimum:10,maximum:200}},required:["scalePercent"]}},{name:"enable_disable_channel",description:"Enable or disable a specific ink channel",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},enabled:{type:"boolean",description:"Whether to enable (true) or disable (false) the channel"}},required:["channelName","enabled"]}},{name:"batch_channel_operations",description:"Perform multiple channel enable/disable operations in a single call",parameters:{type:"object",properties:{operations:{type:"array",description:"Array of channel operations to perform",items:{type:"object",properties:{channelName:{type:"string",description:"Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},enabled:{type:"boolean",description:"Whether to enable (true) or disable (false) the channel"}},required:["channelName","enabled"]}}},required:["operations"]}},{name:"open_global_linearization_file_picker",description:"Open file picker dialog to load global linearization file (.cube, .txt, or .acv)",parameters:{type:"object",properties:{},required:[]}},{name:"open_per_channel_linearization_file_picker",description:"Open file picker dialog to load linearization file for a specific channel",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name to load linearization for",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:["channelName"]}},{name:"load_sample_lab_file",description:"Load the sample LAB measurement data file for testing",parameters:{type:"object",properties:{},required:[]}},{name:"load_sample_cube_file",description:"Load the sample LUT cube file for testing",parameters:{type:"object",properties:{},required:[]}},{name:"load_lab_data_global",description:"Load LAB measurement data from pasted text for global linearization",parameters:{type:"object",properties:{labData:{type:"string",description:"LAB measurement data in standard format (GRAY_PERCENT LAB_L [LAB_A LAB_B])"}},required:["labData"]}},{name:"load_lab_data_per_channel",description:"Load LAB measurement data from pasted text for specific channel linearization",parameters:{type:"object",properties:{labData:{type:"string",description:"LAB measurement data in standard format (GRAY_PERCENT LAB_L [LAB_A LAB_B])"},channelName:{type:"string",description:"Channel name to apply the LAB data to",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:["labData","channelName"]}},{name:"apply_manual_lstar_values",description:"Generate a correction from manual L* measurements (top â†’ bottom evenly spaced unless patchPercents provided)",parameters:{type:"object",properties:{lValues:{type:"array",description:"Measured L* values (0â€“100), ordered from lightest patch (top row) to darkest",items:{type:"number"},minItems:3},channelName:{type:"string",description:"Optional channel name to apply the correction to (defaults to global)",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},patchPercents:{type:"array",description:"Optional patch percentages (0â€“100) matching lValues; defaults to even spacing",items:{type:"number"}}},required:["lValues"]}},{name:"load_cube_data_global",description:"Load .cube (LUT) file data from pasted text for global linearization",parameters:{type:"object",properties:{cubeData:{type:"string",description:".cube file data in standard LUT format (supports 1D and 3D LUTs)"}},required:["cubeData"]}},{name:"load_cube_data_per_channel",description:"Load .cube (LUT) file data from pasted text for specific channel linearization",parameters:{type:"object",properties:{cubeData:{type:"string",description:".cube file data in standard LUT format (supports 1D and 3D LUTs)"},channelName:{type:"string",description:"Channel name to apply the cube data to",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:["cubeData","channelName"]}},{name:"generate_and_download_quad_file",description:"Generate, save, export, or download the .quad file with current settings",parameters:{type:"object",properties:{},required:[]}},{name:"set_filename",description:"Set the filename for the .quad file (without extension)",parameters:{type:"object",properties:{filename:{type:"string",description:"Desired filename without extension (will be sanitized automatically)"}},required:["filename"]}},{name:"set_global_linearization",description:"Enable or disable global linearization (requires linearization file to be loaded)",parameters:{type:"object",properties:{enabled:{type:"boolean",description:"Whether to enable (true) or disable (false) global linearization"}},required:["enabled"]}},{name:"set_auto_white_limit",description:"(Temporarily disabled) Previously toggled the Auto white limit rolloff (toe near paper white).",parameters:{type:"object",properties:{enabled:{type:"boolean",description:"No effect in this build; auto white limit is disabled."}},required:["enabled"]}},{name:"set_auto_black_limit",description:"(Temporarily disabled) Previously toggled the Auto black limit rolloff (shoulder near max ink).",parameters:{type:"object",properties:{enabled:{type:"boolean",description:"No effect in this build; auto black limit is disabled."}},required:["enabled"]}},{name:"revert_global_to_measurement",description:"Revert all channels to the loaded global measurement source (clears Smart curves/points; undoable). Enabled only when a global measurement is loaded.",parameters:{type:"object",properties:{},required:[]}},{name:"revert_channel_to_measurement",description:"Revert a specific channel to its loaded perâ€‘channel measurement source (clears Smart curves/points; undoable). Enabled only when that channel has measurement loaded.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name to revert",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:["channelName"]}},{name:"set_lab_spot_markers",description:"Show or hide the measurement spot marker overlay with tolerance badges and delta arrows on the chart.",parameters:{type:"object",properties:{enabled:{type:"boolean",description:"true to show measurement spot markers; false to hide them"}},required:["enabled"]}},{name:"set_auto_raise_ink_limits",description:"Enable or disable automatic ink limit increases when importing corrections (LAB/CGATS) that exceed current channel limits.",parameters:{type:"object",properties:{enabled:{type:"boolean",description:"true to enable auto-raise on import; false to disable"}},required:["enabled"]}},{name:"set_light_blocking_overlay",description:"Toggle the composite light-blocking curve visualization overlay on the chart.",parameters:{type:"object",properties:{enabled:{type:"boolean",description:"true to show light-blocking overlay; false to hide it"}},required:["enabled"]}},{name:"set_correction_method",description:"Switch between Simple Scaling (default, proportional adjustment) and Density Solver (coverage-aware composite solver with ladder logic) correction methods.",parameters:{type:"object",properties:{method:{type:"string",description:"Correction method to use",enum:["simple","density_solver"]}},required:["method"]}},{name:"set_correction_gain",description:"Set the correction gain blend percentage between identity ramp (0%) and full correction (100%). Affects charts, previews, spot markers, and exports.",parameters:{type:"object",properties:{percent:{type:"number",description:"Gain percentage (0-100): 0% = no correction (identity), 100% = full correction",minimum:0,maximum:100}},required:["percent"]}},{name:"get_correction_gain",description:"Get the current correction gain blend percentage.",parameters:{type:"object",properties:{},required:[]}},{name:"lock_channel",description:"Lock or unlock a specific channel to prevent edits during corrections or global operations.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name to lock/unlock",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},locked:{type:"boolean",description:"true to lock the channel; false to unlock it"}},required:["channelName","locked"]}},{name:"get_channel_lock_status",description:"Get the lock status for a specific channel or all channels.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional: specific channel name. If omitted, returns status for all channels.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:[]}},{name:"set_per_channel_linearization",description:"Enable or disable linearization for a specific channel (requires linearization file to be loaded for that channel)",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},enabled:{type:"boolean",description:"Whether to enable (true) or disable (false) linearization for this channel"}},required:["channelName","enabled"]}},{name:"set_interpolation_method",description:"Set the interpolation method for curve generation",parameters:{type:"object",properties:{method:{type:"string",description:"Interpolation method to use",enum:["pchip","linear"]}},required:["method"]}},{name:"set_smoothing_percentage",description:"Set the data point smoothing percentage (0-600%)",parameters:{type:"object",properties:{percentage:{type:"number",description:"Smoothing percentage (0=none, 600=maximum)",minimum:0,maximum:600}},required:["percentage"]}},{name:"change_printer",description:"Switch between supported printer models",parameters:{type:"object",properties:{printerName:{type:"string",description:"Printer model to switch to",enum:["P700P900","P5-7-9000","P800","P400","x900","3880-7880","x800-x890","P4-6-8000"]}},required:["printerName"]}},{name:"generate_custom_curve",description:"Generate a curve from explicit numerical key points (single channel). Prefer set_ai_key_points for AI-driven curves.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel name to generate curve for",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},keyPoints:{type:"array",description:"Array of curve control points with input/output values (0-100 range)",items:{type:"object",properties:{input:{type:"number",description:"Input position (0-100%)",minimum:0,maximum:100},output:{type:"number",description:"Output value (0-100%)",minimum:0,maximum:100}},required:["input","output"]},minItems:2},interpolationType:{type:"string",description:"Interpolation method between points",enum:["linear","smooth"],default:"smooth"}},required:["channelName","keyPoints"]}},{name:"get_ai_key_points",description:"Get stored AI key points (endpoints included). If channelName is omitted, uses the first enabled channel. If none exist yet, returns an empty list with suggestions; edit calls will autoâ€‘create.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:[]}},{name:"get_smart_key_points",description:"Get stored Smart key points (endpoints included). If channelName is omitted, uses the first enabled channel. If none exist yet, returns an empty list with suggestions; edit calls will autoâ€‘create.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:[]}},{name:"set_ai_key_points",description:"Replace AI key points and reapply the curve. If channelName is omitted, uses the first enabled channel.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},keyPoints:{type:"array",description:"Array of {input, output} in 0-100%",items:{type:"object",properties:{input:{type:"number",minimum:0,maximum:100},output:{type:"number",minimum:0,maximum:100}},required:["input","output"]},minItems:2},interpolationType:{type:"string",enum:["linear","smooth"],default:"smooth"}},required:["keyPoints"]}},{name:"set_smart_key_points",description:"Replace Smart key points and reapply the curve. If channelName is omitted, uses the first enabled channel.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},keyPoints:{type:"array",description:"Array of {input, output} in 0-100%",items:{type:"object",properties:{input:{type:"number",minimum:0,maximum:100},output:{type:"number",minimum:0,maximum:100}},required:["input","output"]},minItems:2},interpolationType:{type:"string",enum:["linear","smooth"],default:"smooth"}},required:["keyPoints"]}},{name:"set_ai_key_points_batch",description:"Replace AI key points for multiple channels and reapply curves as a single batch action.",parameters:{type:"object",properties:{entries:{type:"array",description:"List of per-channel key points updates",items:{type:"object",properties:{channelName:{type:"string",description:"Channel to update",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},keyPoints:{type:"array",description:"Array of {input, output} in 0-100%",items:{type:"object",properties:{input:{type:"number",minimum:0,maximum:100},output:{type:"number",minimum:0,maximum:100}},required:["input","output"]},minItems:2},interpolationType:{type:"string",enum:["linear","smooth"],default:"smooth"}},required:["channelName","keyPoints"]},minItems:1}},required:["entries"]}},{name:"set_smart_key_points_batch",description:"Replace Smart key points for multiple channels and reapply curves as a single batch action.",parameters:{type:"object",properties:{entries:{type:"array",description:"List of per-channel key points updates",items:{type:"object",properties:{channelName:{type:"string",description:"Channel to update",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},keyPoints:{type:"array",description:"Array of {input, output} in 0-100%",items:{type:"object",properties:{input:{type:"number",minimum:0,maximum:100},output:{type:"number",minimum:0,maximum:100}},required:["input","output"]},minItems:2},interpolationType:{type:"string",enum:["linear","smooth"],default:"smooth"}},required:["channelName","keyPoints"]},minItems:1}},required:["entries"]}},{name:"simplify_ai_key_points_from_curve",description:"Extract adaptive key points from the current curve (prefers loaded .quad) and apply them to a channel.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel to simplify",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},maxErrorPercent:{type:"number",description:"Max allowed deviation in % (0.05â€“5). Default 1.0",minimum:.05,maximum:5},maxPoints:{type:"integer",description:"Upper bound on points (2â€“20). Default 16",minimum:2,maximum:20}},required:["channelName"]}},{name:"simplify_smart_key_points_from_curve",description:"Extract adaptive Smart key points from the current curve (prefers loaded .quad) and apply them to a channel.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel to simplify",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},maxErrorPercent:{type:"number",description:"Max allowed deviation in % (0.05â€“5). Default 1.0",minimum:.05,maximum:5},maxPoints:{type:"integer",description:"Upper bound on points (2â€“20). Default 16",minimum:2,maximum:20}},required:["channelName"]}},{name:"adjust_ai_key_point_by_index",description:"Adjust a single AI key point by ordinal (1â€‘based, endpoints included). If channelName is omitted, uses the first enabled channel. If no AI key points exist yet, quadGEN will silently create them from the current curve/data and then apply the edit.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},ordinal:{type:"integer",description:"1-based index of the key point (including endpoints)",minimum:1},inputPercent:{type:"number",description:"Absolute new input (X) in % (0-100)",minimum:0,maximum:100},outputPercent:{type:"number",description:"Absolute new output (Y) in % (0-100)",minimum:0,maximum:100},deltaInput:{type:"number",description:"Delta to add to input (X) in percentage points"},deltaOutput:{type:"number",description:"Delta to add to output (Y) in percentage points"}},required:["ordinal"]}},{name:"adjust_smart_key_point_by_index",description:"Adjust a single Smart key point by ordinal (1â€‘based, endpoints included). If channelName is omitted, uses the first enabled channel. If no Smart key points exist yet, quadGEN will create them from the current curve/data and then apply the edit.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},ordinal:{type:"integer",description:"1-based index of the key point (including endpoints)",minimum:1},inputPercent:{type:"number",description:"Absolute new input (X) in % (0-100)",minimum:0,maximum:100},outputPercent:{type:"number",description:"Absolute new output (Y) in % (0-100)",minimum:0,maximum:100},deltaInput:{type:"number",description:"Delta to add to input (X) in percentage points"},deltaOutput:{type:"number",description:"Delta to add to output (Y) in percentage points"}},required:["ordinal"]}},{name:"insert_ai_key_point_at",description:"Insert a new AI key point at a given input (X). If output is omitted, sample current Smart Curve at X. If no AI key points exist yet, they will be created from the current curve/data.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},inputPercent:{type:"number",description:"Input position (X) in % (0-100)",minimum:0,maximum:100},outputPercent:{type:"number",description:"Optional output (Y) in % (0-100) â€” if omitted, sampled from current Smart Curve",minimum:0,maximum:100}},required:["inputPercent"]}},{name:"insert_smart_key_point_at",description:"Insert a new Smart key point at a given input (X). If output is omitted, sample current Smart curve at X. If no Smart key points exist yet, they will be created from the current curve/data.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},inputPercent:{type:"number",description:"Input position (X) in % (0-100)",minimum:0,maximum:100},outputPercent:{type:"number",description:"Optional output (Y) in % (0-100) â€” if omitted, sampled from current Smart curve",minimum:0,maximum:100}},required:["inputPercent"]}},{name:"insert_ai_key_point_between",description:"Insert a new AI key point between two adjacent ordinals. If output is omitted, sample at the midpoint. If no AI key points exist yet, they will be created from the current curve/data.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},leftOrdinal:{type:"integer",description:"Left ordinal (1-based)",minimum:1},rightOrdinal:{type:"integer",description:"Right ordinal (must be leftOrdinal+1)",minimum:2},outputPercent:{type:"number",description:"Optional output (Y) in % (0-100) â€” if omitted, sampled from current Smart Curve",minimum:0,maximum:100}},required:["leftOrdinal","rightOrdinal"]}},{name:"insert_smart_key_point_between",description:"Insert a new Smart key point between two adjacent ordinals. If output is omitted, sample at the midpoint. If no Smart key points exist yet, they will be created from the current curve/data.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},leftOrdinal:{type:"integer",description:"Left ordinal (1-based)",minimum:1},rightOrdinal:{type:"integer",description:"Right ordinal (must be leftOrdinal+1)",minimum:2},outputPercent:{type:"number",description:"Optional output (Y) in % (0-100) â€” if omitted, sampled from current Smart curve",minimum:0,maximum:100}},required:["leftOrdinal","rightOrdinal"]}},{name:"insert_ai_key_points_batch",description:"Insert multiple AI key points for a single channel in one batch (single undoable action).",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel to update",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},inserts:{type:"array",description:"List of points to insert",items:{type:"object",properties:{inputPercent:{type:"number",minimum:0,maximum:100},outputPercent:{type:"number",minimum:0,maximum:100}},required:["inputPercent"]},minItems:1}},required:["channelName","inserts"]}},{name:"insert_smart_key_points_batch",description:"Insert multiple Smart key points for a single channel in one batch (single undoable action).",parameters:{type:"object",properties:{channelName:{type:"string",description:"Channel to update",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},inserts:{type:"array",description:"List of points to insert",items:{type:"object",properties:{inputPercent:{type:"number",minimum:0,maximum:100},outputPercent:{type:"number",minimum:0,maximum:100}},required:["inputPercent"]},minItems:1}},required:["channelName","inserts"]}},{name:"delete_ai_key_point_by_index",description:"Delete a single AI key point by ordinal (1â€‘based). Endpoints blocked by default. If no AI key points exist yet, they will be created from the current curve/data first.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},ordinal:{type:"integer",description:"1-based index of the key point to delete",minimum:1},allowEndpoint:{type:"boolean",description:"Whether to allow deletion of endpoints (defaults to false)",default:!1}},required:["ordinal"]}},{name:"delete_smart_key_point_by_index",description:"Delete a single Smart key point by ordinal (1â€‘based). Endpoints blocked by default. If no Smart key points exist yet, they will be created from the current curve/data first.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},ordinal:{type:"integer",description:"1-based index of the key point to delete",minimum:1},allowEndpoint:{type:"boolean",description:"Whether to allow deletion of endpoints (defaults to false)",default:!1}},required:["ordinal"]}},{name:"delete_ai_key_point_near_input",description:"Delete the AI key point nearest to a given input % within a tolerance. Endpoints blocked by default. If no AI key points exist yet, they will be created from the current curve/data first.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},inputPercent:{type:"number",description:"Target input position (X) in % (0-100)",minimum:0,maximum:100},tolerance:{type:"number",description:"Maximum distance in % to consider a match (default 1.0)"},allowEndpoint:{type:"boolean",description:"Whether to allow deletion of endpoints (defaults to false)",default:!1}},required:["inputPercent"]}},{name:"delete_smart_key_point_near_input",description:"Delete the Smart key point nearest to a given input % within a tolerance. Endpoints blocked by default. If no Smart key points exist yet, they will be created from the current curve/data first.",parameters:{type:"object",properties:{channelName:{type:"string",description:"Optional channel name. If omitted, the first enabled channel is used.",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},inputPercent:{type:"number",description:"Target input position (X) in % (0-100)",minimum:0,maximum:100},tolerance:{type:"number",description:"Maximum distance in % to consider a match (default 1.0)"},allowEndpoint:{type:"boolean",description:"Whether to allow deletion of endpoints (defaults to false)",default:!1}},required:["inputPercent"]}},{name:"copy_curve_to_channel",description:"Copy a custom curve from one channel to another channel",parameters:{type:"object",properties:{sourceChannel:{type:"string",description:"Channel to copy the curve from",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},targetChannel:{type:"string",description:"Channel to copy the curve to",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]}},required:["sourceChannel","targetChannel"]}},{name:"generate_global_custom_curve",description:"Generate curves from explicit numerical key points for multiple channels simultaneously. Creates single batch undo action.",parameters:{type:"object",properties:{keyPoints:{type:"array",description:"Array of curve control points with input/output values (0-100 range)",items:{type:"object",properties:{input:{type:"number",description:"Input value (0-100)"},output:{type:"number",description:"Output value (0-100)"}},required:["input","output"]}},interpolationType:{type:"string",description:"Interpolation method between points",enum:["linear","smooth"],default:"smooth"},channelFilter:{oneOf:[{type:"string",enum:["all","enabled"],description:"Predefined channel filters"},{type:"array",items:{type:"string",enum:["K","C","M","Y","LC","LM","LK","LLK","V","MK"]},description:"Array of specific channel names"}],description:"Which channels to apply to: 'all' (all printer channels), 'enabled' (only enabled channels), or array of specific channels like ['LK', 'MK']",default:"enabled"}},required:["keyPoints"]}},{name:"get_current_state",description:"Get the current state of all channels and app settings",parameters:{type:"object",properties:{},required:[]}},{name:"undo_last_change",description:"Revert to the previous state (undo the last change made to curves or channel settings)",parameters:{type:"object",properties:{},required:[]}},{name:"get_history_summary",description:"Get a summary of recent changes and undo history for reference",parameters:{type:"object",properties:{},required:[]}},{name:"get_quad_file_content",description:"Return the current generated .quad file content as text (based on current settings)",parameters:{type:"object",properties:{},required:[]}}],_l=typeof globalThis<"u"?globalThis:{};class Um{constructor(){this.chatHistory=[],this.conversationHistory=[],this.isProcessing=!1,this._modelLogged=!1,this.quadGenActions=new eE}addMessage(t,n){try{if(!n||typeof n!="string"){console.warn("Invalid message provided to addMessage");return}this.chatHistory.push({role:t,message:n.trim(),timestamp:new Date().toISOString()}),this.updateChatUI(t,n),_l.DEBUG_AI&&console.log(`[CHAT] ${t}: ${n}`)}catch(r){console.error("Error adding chat message:",r)}}updateChatUI(t,n){try{xn.addChatMessage(t,n)}catch(r){console.error("Error updating chat UI:",r),console.log(`ðŸ“± Chat fallback: [${t}] ${n}`)}}async sendMessage(t){try{if(!t||typeof t!="string")throw new Error("Invalid message provided");if(this.isProcessing)throw new Error("Already processing a message");this.isProcessing=!0,this.addMessage("user",t),this.shouldShowStatus()&&this.addMessage("system","Assistant: processing requestâ€¦");const n=!!_l.DEBUG_AI,r=!!_l.DEBUG_LOGS;(n||r)&&console.log("ðŸ“¤ Sending message to AI:",t);const i=this.getSystemContext(),o=`You are Lab Tech, quadGEN's AI assistant for fine art printing and QuadToneRIP .quad file generation.

CURRENT APPLICATION STATE:
${i}

You are here to help with:
â€¢ quadGEN app functionality and usage
â€¢ Digital printing workflows and troubleshooting
â€¢ Alternative photographic processes (cyanotype, palladium, etc.)
â€¢ Historical printing methods and fine art techniques
â€¢ QuadToneRIP .quad file generation and editing
â€¢ Ink limit optimization and curve adjustment
â€¢ LAB measurement data analysis and linearization
â€¢ Channel management and smart curve generation

When the user asks for help with curve adjustments:
â€¢ Use get_current_state first to understand the current setup
â€¢ Ask clarifying questions if needed about desired tonal characteristics
â€¢ Make specific, targeted adjustments using the available functions
â€¢ Always explain what changes were made and why

For measurement data and linearization:
â€¢ Prefer LAB data over other formats when available
â€¢ Explain the difference between image-space and printer-space corrections
â€¢ Guide users through proper measurement workflow

IMPORTANT RESPONSE FORMAT:
â€¢ Keep responses concise and focused
â€¢ When making function calls, briefly explain what you're doing
â€¢ Include specific percentage or value changes when relevant
â€¢ Use technical terminology appropriately for the printing context
â€¢ Format numerical data clearly (percentages, curve points, etc.)

KEYâ€‘POINT EDITING DEFAULTS:
â€¢ "point N" ALWAYS refers to the AI keyâ€‘point ordinal N (1â€‘based, endpoints included) on the selected channel
â€¢ If channel is not specified, use the first enabled channel from the current state
â€¢ Silent conversion: If no AI key points exist yet, edit/insert/delete functions will autoâ€‘create them from any loaded data
â€¢ Disambiguation: If user mentions "point N ... %", interpret as keyâ€‘point change, not channel ink limit

CHANNEL SELECTION RULES:
â€¢ Use the first enabled channel (percentage > 0 OR endValue > 0 OR enabled = true) when channel not specified
â€¢ If NO channels enabled, ask which channel to use
â€¢ Standard ink limits: K/MK=100%, colors=30-45%, Light inks=60-80%

Only engage with requests about: app functionality, printing, photography, historical/alternative processes, digital negatives/positives. Politely decline unrelated topics.`,s=[{role:"user",content:`${i}

User request: ${t}`}],l=this.conversationHistory.slice(-10);s.splice(-1,0,...l);let u=await(async g=>{let b;g==="openai"||(b={provider:"anthropic",model:li.ANTHROPIC_MODEL,max_tokens:1e3,system:o,messages:s,tools:Mx.map(I=>({name:I.name,description:I.description,input_schema:I.parameters}))});const S=3;let E,y,v;for(let I=1;I<=S;I++){E=await fetch(li.WORKER_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(b)}),y=await E.text();try{v=JSON.parse(y)}catch{v={}}if(E.ok)break;const _=E.status,C=E.headers.get("Retry-After"),x=C?parseInt(C,10)*1e3:null,P=_===429||_===529||_>=500&&_<=504;if(I<S&&P){const F=x??I*600;(n||r)&&console.warn(`Transient AI error ${_}; retrying in ${F}ms (attempt ${I}/${S-1})`),await new Promise(U=>setTimeout(U,F));continue}const k=v?.error?.message||v?.error||E.statusText||"Unknown error",N=new Error(`API Error: ${_} - ${k}`);throw N.status=_,N.provider=g,N.data=v,N}if(!this._modelLogged){const I=v.model||(g==="openai"?li.OPENAI_MODEL:li.ANTHROPIC_MODEL),C=`AI connected â†’ provider: ${E.headers.get("X-Model-Provider")||g}, model: ${I}`;(n||r)&&console.log(C),this.shouldShowStatus()&&this.addMessage("system",C),this._modelLogged=!0}const A={};["x-ratelimit-limit","x-ratelimit-remaining","x-ratelimit-reset"].forEach(I=>{const _=E.headers.get(I);_&&(A[I]=_)});const w=[];let M="";if(g!=="openai"){for(const I of v.content||[])if(I.type==="text")M+=I.text;else if(I.type==="tool_use"){(n||r)&&console.log("ðŸ”§ Function call (Anthropic):",I.name,I.input);const _=await this.executeFunctionCall({name:I.name,parameters:I.input},t);w.push({function:I.name,parameters:I.input,result:_})}}return{assistantMessage:M,functionResults:w,rateLimitHeaders:A,provider:g}})(li.PROVIDER);const{assistantMessage:d,functionResults:p,rateLimitHeaders:f}=u;let h=d||"";try{const g=(p||[]).some(S=>S.function==="set_ai_key_points");if((!h||h.trim().length===0)&&g){const S=[];for(const E of p)if(E.function==="set_ai_key_points"){const v=(E.result||{}).message||"Applied AI key points.";S.push(`Action: ${v}`)}S.length>0&&(h=S.join(`

`))}const b=(p||[]).filter(S=>S.function==="get_ai_key_points");if(b.length>0){const S=[];for(const E of b){const y=E.result||{};if(y.success&&Array.isArray(y.keyPoints)){const v=y.channelName||E.parameters?.channelName||"channel",A=y.keyPoints.map(w=>`${Math.round(w.input)},${Math.round(w.output)}`).join(" ");S.push(`Key points (${v}): ${A}`)}else y.message&&S.push(y.message)}S.length>0&&(!h||h.trim().length===0?h=S.join(`
`):h+=`
${S.join(`
`)}`)}}catch(g){(n||r)&&console.warn("Failed to synthesize action summary:",g.message)}return(n||r)&&console.log("ðŸ“ Total function calls processed:",p.length),this.conversationHistory.push({role:"user",content:t},{role:"assistant",content:h||"I performed the requested actions."}),this.addMessage("assistant",h||"Actions completed successfully."),p&&p.length>0&&this.processFunctionResults(p),{success:!0,message:"Request processed successfully",response:h||"Actions completed successfully.",functionResults:p,actionsPerformed:p.length>0,rateLimitHeaders:f}}catch(n){console.error("AI API Error:",n);const r=`Error communicating with AI provider: ${n.message}`;return this.addMessage("system",r),{success:!1,message:r,response:`Sorry, I encountered an error: ${n.message}`}}finally{this.isProcessing=!1}}processFunctionResults(t){try{if(!Array.isArray(t))return;for(const n of t)n.function&&n.success&&(console.log(`ðŸ“‹ Function executed: ${n.function}`),(n.function.includes("set_ai_key_points")||n.function.includes("smart"))&&this.handleSmartCurveUpdate(n))}catch(n){console.error("Error processing function results:",n)}}handleSmartCurveUpdate(t){try{console.log("ðŸŽ¯ Smart Curve update:",t),Je()}catch(n){console.error("Error handling Smart Curve update:",n)}}clearHistory(){try{this.chatHistory=[],this.conversationHistory=[];const t=m.chatHistory||m.chatContainer;t&&(t.innerHTML=""),this.addMessage("system","Chat history cleared.")}catch(t){console.error("Error clearing chat history:",t)}}getSystemContext(){try{return"Current printer: P700/P900, Channels: K enabled (100%), C disabled, M disabled, Y disabled"}catch(t){return console.error("Error getting system context:",t),"Unable to get current application context"}}async executeFunctionCall(t,n){try{const{name:r,parameters:i}=t;switch(_l.DEBUG_AI&&console.log(`ðŸ”§ Executing function: ${r}`,i),r){case"set_channel_value":return this.quadGenActions.setChannelValue(i.channelName,i.percentage);case"set_channel_end_value":return this.quadGenActions.setChannelEndValue(i.channelName,i.endValue);case"apply_to_all_channels":return this.quadGenActions.applyToAllChannels(i.percentage);case"scale_channel_ends_by_percent":return await this.quadGenActions.scaleChannelEndsByPercent(i.scalePercent);case"enable_disable_channel":return this.quadGenActions.enableDisableChannel(i.channelName,i.enabled);case"load_lab_data_global":return this.quadGenActions.loadLabData(i.labData,!0);case"load_lab_data_per_channel":return this.quadGenActions.loadLabData(i.labData,!1,i.channelName);case"apply_manual_lstar_values":return this.quadGenActions.applyManualLstarValues(i.lValues,i.channelName,i.patchPercents);case"generate_and_download_quad_file":return this.quadGenActions.generateAndDownloadQuadFile();case"get_current_state":return this.quadGenActions.getCurrentState();case"revert_global_to_measurement":return this.quadGenActions.revertGlobalToMeasurement();case"revert_channel_to_measurement":return this.quadGenActions.revertChannelToMeasurement(i?.channelName);case"set_lab_spot_markers":return this.quadGenActions.setLabSpotMarkers(i.enabled);case"set_auto_raise_ink_limits":return this.quadGenActions.setAutoRaiseInkLimits(i.enabled);case"set_light_blocking_overlay":return this.quadGenActions.setLightBlockingOverlay(i.enabled);case"set_correction_method":return this.quadGenActions.setCorrectionMethod(i.method);case"set_correction_gain":return this.quadGenActions.setCorrectionGain(i.percent);case"get_correction_gain":return this.quadGenActions.getCorrectionGain();case"lock_channel":return this.quadGenActions.lockChannel(i.channelName,i.locked);case"get_channel_lock_status":return this.quadGenActions.getChannelLockStatus(i?.channelName);default:return console.warn(`Unknown function call: ${r}`),{success:!1,message:`Function '${r}' is not yet implemented in the modular version`}}}catch(r){return console.error("Error executing function call:",r),{success:!1,message:`Error executing function: ${r.message}`}}}getHistory(){return[...this.chatHistory]}shouldShowStatus(){return!0}async validateApiKey(t){try{if(!t||typeof t!="string")return{valid:!1,message:"Invalid API key format"};console.log("ðŸ”‘ Validating API key...");const n=t.length>10;return{valid:n,message:n?"API key appears valid":"API key too short"}}catch(n){return console.error("Error validating API key:",n),{valid:!1,message:`Validation error: ${n.message}`}}}async setApiKey(t,n=!0){try{if(n){const r=await this.validateApiKey(t);if(r.valid)this.addMessage("system",`âœ… ${r.message}. You can now chat with Lab Tech!`);else{this.addMessage("system",`âŒ ${r.message}`);return}}else this.addMessage("system","âš ï¸ API key set WITHOUT validation. Try sending a message to test if it works.");console.log("ðŸ”‘ API key set")}catch(r){console.error("Error setting API key:",r),this.addMessage("system",`âŒ Could not validate API key: ${r.message}`)}}clearApiKey(){try{console.log("ðŸ”‘ API key cleared"),this.addMessage("system","API key cleared. Please set a new API key to continue chatting.")}catch(t){console.error("Error clearing API key:",t)}}async testConnection(){try{console.log("ðŸ”— Testing API connection...");const t={success:!0,message:"Connection test successful (placeholder)"};return this.addMessage("system",`Connection test: ${t.message}`),t}catch(t){return console.error("Connection test failed:",t),this.addMessage("system",`Connection test failed: ${t.message}`),{success:!1,message:t.message}}}}let Fd=null;function ko(){return Fd||(Fd=new Um),Fd}function Lx(e,t){ko().addMessage(e,t)}async function kc(){console.log("ðŸ’¬ sendChatMessage() called!");try{const e=ko(),t=m.chatInput||m.messageInput||m.aiInputCompact;if(!t)throw new Error("No message input element found");const n=t.value?.trim();if(!n)throw new Error("Please enter a message");return t.value="",await e.sendMessage(n)}catch(e){throw console.error("Error in sendChatMessage:",e),ko().addMessage("system",`Error: ${e.message}`),e}}function tE(){return ko().shouldShowStatus()}function ff(){try{console.log("ðŸ’¬ Initializing chat interface..."),m.sendMessageBtnCompact?(console.log("ðŸ’¬ Setting up event listener for sendMessageBtnCompact"),m.sendMessageBtnCompact.addEventListener("click",kc),m.sendMessageBtnCompact.disabled=!1,console.log("ðŸ’¬ Enabled sendMessageBtnCompact button")):console.warn("ðŸ’¬ sendMessageBtnCompact element not found!"),(m.chatInput||m.messageInput||m.aiInputCompact)&&(m.chatInput||m.messageInput||m.aiInputCompact).addEventListener("keydown",t=>{t.key==="Enter"&&!t.shiftKey&&(t.preventDefault(),m.sendMessageBtnCompact?.disabled||kc())}),console.log("âœ… Chat interface initialized")}catch(e){console.error("Error initializing chat interface:",e)}}Xe("chatInterface",{ChatInterface:Um,getChatInterface:ko,addChatMessage:Lx,sendChatMessage:kc,shouldShowAssistantStatus:tE,initializeChatInterface:ff},{exposeOnWindow:typeof window<"u",windowAliases:["ChatInterface","getChatInterface","addChatMessage","sendChatMessage","shouldShowAssistantStatus","initializeChatInterface"]});const Ix=120,kx=520,ya=typeof globalThis<"u"?globalThis:{};function vb(e){return e?.ownerDocument?e.ownerDocument:ya.document?ya.document:null}function Dx(e){return e?.defaultView?e.defaultView:ya.window?ya.window:ya}class nE{constructor(){this.isInitialized=!1,this.chatContainer=null,this.messageInput=null,this.sendButton=null,this.resizerInitialized=!1}initialize(){this.isInitialized||(console.log("ðŸŽ¨ Initializing Chat UI..."),this.chatContainer=document.getElementById("chatHistory"),this.messageInput=document.getElementById("aiInputCompact"),this.sendButton=document.getElementById("sendMessageBtnCompact"),(!this.chatContainer||!this.messageInput||!this.sendButton)&&this.createChatUI(),this.updateElementsState(),this.setupInitialState(),this.initializeResizer(),this.isInitialized=!0,console.log("âœ… Chat UI initialized"))}createChatUI(){console.log("ðŸ—ï¸ Creating Chat UI elements...");let t=document.getElementById("labTechConsole");if(!t){t=document.createElement("div"),t.id="labTechConsole",t.className="border border-gray-200 rounded-xl p-4 mb-4";const r=document.querySelector("main")||document.querySelector("body");r&&r.insertBefore(t,r.firstChild)}this.chatContainer||(this.chatContainer=document.createElement("div"),this.chatContainer.id="chatHistory",this.chatContainer.className="overflow-y-auto text-xs leading-4 mb-2 min-h-[224px] max-h-[224px] p-2 border border-gray-300 rounded",this.chatContainer.innerHTML="\x3C!-- Lab Tech chat messages will appear here -->");const n=document.createElement("div");n.className="flex gap-2",this.messageInput||(this.messageInput=document.createElement("input"),this.messageInput.id="aiInputCompact",this.messageInput.type="text",this.messageInput.placeholder="Ask Lab Techâ€¦ (Enter to send)",this.messageInput.className="flex-1 px-2 py-1 text-xs border border-gray-300 rounded"),this.sendButton||(this.sendButton=document.createElement("button"),this.sendButton.id="sendMessageBtnCompact",this.sendButton.textContent="Send",this.sendButton.className="px-2 py-1 text-xs bg-green-600 hover:bg-green-700 text-white rounded font-bold",this.sendButton.disabled=!0),n.appendChild(this.messageInput),n.appendChild(this.sendButton),t.appendChild(this.chatContainer),t.appendChild(n),console.log("âœ¨ Chat UI elements created and injected into DOM")}updateElementsState(){m&&(m.chatHistory=this.chatContainer,m.chatContainer=this.chatContainer,m.aiInputCompact=this.messageInput,m.chatInput=this.messageInput,m.messageInput=this.messageInput,m.sendMessageBtnCompact=this.sendButton,console.log("ðŸ”„ Updated elements state with chat UI references"))}initializeResizer(){if(this.resizerInitialized)return;const t=vb(null),n=vb(this.chatContainer)||t,r=n?.getElementById?.("labTechResizer"),i=this.chatContainer||n?.getElementById?.("chatHistory");if(!r||!i){console.warn("Lab Tech resizer elements not found");return}const a=Dx(n);let o=!1,s=0,l=0;const c=()=>{const E=a&&typeof a.getComputedStyle=="function"?a:typeof ya.getComputedStyle=="function"?ya:null;if(E){const y=E.getComputedStyle(i)?.height,v=parseInt(y,10);if(Number.isFinite(v))return v}return i.clientHeight},u=E=>{const y=Math.max(Ix,Math.min(kx,E));i.style.height=`${y}px`},d=(E,y,v)=>{if(a&&typeof a.addEventListener=="function"){a.addEventListener(E,y,v);return}n&&typeof n.addEventListener=="function"&&n.addEventListener(E,y,v)},p=(E,y,v)=>{if(a&&typeof a.removeEventListener=="function"){a.removeEventListener(E,y,v);return}n&&typeof n.removeEventListener=="function"&&n.removeEventListener(E,y,v)},f=()=>{o&&(o=!1,n?.body?.classList&&n.body.classList.remove("select-none"),p("mousemove",h),p("mouseup",f),p("touchmove",b),p("touchend",f))},h=E=>{if(!o)return;const y=E.clientY-s;u(l+y)},g=E=>{o=!0,s=E.clientY,l=c(),n?.body?.classList&&n.body.classList.add("select-none"),d("mousemove",h),d("mouseup",f),E.preventDefault()},b=E=>{if(!o||E.touches.length!==1)return;const v=E.touches[0].clientY-s;u(l+v),E.preventDefault()},S=E=>{E.touches.length===1&&(o=!0,s=E.touches[0].clientY,l=c(),n?.body?.classList&&n.body.classList.add("select-none"),d("touchmove",b,{passive:!1}),d("touchend",f),E.preventDefault())};r.addEventListener("mousedown",g),r.addEventListener("touchstart",S,{passive:!1}),this.resizerInitialized=!0}setupInitialState(){this.chatContainer&&this.chatContainer.innerHTML.trim()==="\x3C!-- Lab Tech chat messages will appear here -->"&&this.addWelcomeMessage(),this.sendButton&&console.log("ðŸ”˜ Send button initialized (disabled state)")}addWelcomeMessage(){const t=document.createElement("div");t.className="chat-line system",t.textContent="ðŸ’¬ Lab Tech AI Assistant Ready";const n=document.createElement("div");n.className="chat-line system",n.style.fontStyle="normal",n.style.fontSize="11px",n.textContent="Type a message and press Enter or click Send to chat with your AI assistant.",this.chatContainer.appendChild(t),this.chatContainer.appendChild(n),console.log("ðŸ‘‹ Added welcome message to chat")}scrollToBottom(){this.chatContainer&&(this.chatContainer.scrollTop=this.chatContainer.scrollHeight)}clearMessages(){this.chatContainer&&(this.chatContainer.innerHTML="",this.addWelcomeMessage())}getInputValue(){return this.messageInput?this.messageInput.value:""}clearInput(){this.messageInput&&(this.messageInput.value="")}setSendButtonEnabled(t){this.sendButton&&(this.sendButton.disabled=!t)}focusInput(){this.messageInput&&this.messageInput.focus()}}const Ps=new nE;typeof document<"u"&&(document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>{Ps.initialize()}):Ps.initialize());Xe("chatUI",{chatUI:Ps},{exposeOnWindow:!0,windowAliases:["chatUI"]});const Kl=typeof globalThis<"u"?globalThis:{};class Px{constructor(){this.listeners=new Map,this.isInitialized=!1,this.cleanupCallbacks=[]}on(t,n){return this.listeners.has(t)||this.listeners.set(t,new Set),this.listeners.get(t).add(n),()=>{const r=this.listeners.get(t);r&&(r.delete(n),r.size===0&&this.listeners.delete(t))}}emit(t,...n){const r=this.listeners.get(t);r&&r.forEach(i=>{try{i(...n)}catch(a){console.warn(`Error in state event handler for '${t}':`,a)}})}removeAllListeners(t){this.listeners.delete(t)}clear(){this.cleanupCallbacks.forEach(t=>{try{t()}catch(n){console.warn("Error during state watcher cleanup",n)}}),this.cleanupCallbacks=[],this.listeners.clear()}initialize(){this.isInitialized||(this.setupStateWatchers(),this.setupDOMEventListeners(),this.isInitialized=!0,console.log("ðŸ”„ State synchronization system initialized"))}setupStateWatchers(){this.watchGlobalProperty("loadedQuadData",(n,r)=>{this.emit("quadDataChanged",n,r)}),this.watchGlobalProperty("linearizationApplied",(n,r)=>{this.emit("linearizationStateChanged",n,r)}),this.watchGlobalProperty("linearizationData",(n,r)=>{this.emit("linearizationDataChanged",n,r)}),this.watchGlobalProperty("keyPointsState",(n,r)=>{this.emit("keyPointsChanged",n,r)});const t=Zf((n,r)=>{this.emit("autoLimitStateChanged",n,r)});this.cleanupCallbacks.push(t)}setupDOMEventListeners(){typeof document>"u"||!document?.addEventListener||(document.addEventListener("input",t=>{if(t.target.matches(".percent-input, .end-input")){const n=t.target.closest("[data-channel]")?.dataset.channel;n&&this.emit("channelValueChanged",n,t.target)}}),document.addEventListener("change",t=>{t.target.id==="autoWhiteLimitToggle"?this.emit("autoWhiteLimitChanged",t.target.checked):t.target.id==="autoBlackLimitToggle"&&this.emit("autoBlackLimitChanged",t.target.checked)}))}watchGlobalProperty(t,n){const r=Kl;let i=r[t];Object.defineProperty(r,t,{get(){return i},set(a){const o=i;i=a,n(a,o)},configurable:!0,enumerable:!0})}}const Lr=new Px;function rE(){Lr.initialize(),xx(),Bx(),Tx(),Ox(),_x(),console.log("âœ… State synchronization configured")}function xx(){Lr.on("quadDataChanged",(e,t)=>{Je(),Li(),po(),console.log("ðŸ“Š Quad data synchronized")})}function Bx(){Lr.on("linearizationStateChanged",(e,t)=>{Je(),po(),console.log("ðŸ“ˆ Linearization state synchronized")}),Lr.on("linearizationDataChanged",(e,t)=>{Je(),po(),console.log("ðŸ“ˆ Linearization data synchronized")})}function Tx(){Lr.on("keyPointsChanged",(e,t)=>{Je(),po(),console.log("ðŸŽ¯ Key points synchronized")})}function Ox(){Lr.on("autoLimitStateChanged",(e,t)=>{Je()}),Lr.on("autoWhiteLimitChanged",e=>{Je(),console.log(`ðŸŽšï¸ Auto white limit ${e?"enabled":"disabled"}`)}),Lr.on("autoBlackLimitChanged",e=>{Je(),console.log(`ðŸŽšï¸ Auto black limit ${e?"enabled":"disabled"}`)})}function _x(){Lr.on("channelValueChanged",(e,t)=>{Kl._chartUpdateTimeout&&clearTimeout(Kl._chartUpdateTimeout),Kl._chartUpdateTimeout=setTimeout(()=>{Je(),Ur(),Pn()},100)})}function Nx(e,...t){Lr.emit(e,...t)}function Fx(e,t){return Lr.on(e,t)}Xe("eventSync",{stateEvents:Lr,setupStateSynchronization:rE,triggerStateSync:Nx,onStateSync:Fx},{exposeOnWindow:typeof window<"u",windowAliases:["stateEvents","setupStateSynchronization","triggerStateSync","onStateSync"]});const Or=mf(),Eb=typeof Or?.updatePreview=="function"?Or.updatePreview.bind(Or):null;console.log(`quadGEN ${Sa} - Modular build system initialized`);function Gx(){console.log(`ðŸš€ Initializing quadGEN ${Cb}`),document.title=`quadGEN ${Sa}`;const e=document.getElementById("appVersion");e&&(e.textContent=Sa),KE(),JP(),mx(),Kv(),eb(),tb(),Bm(),QD(),Lv();const t=document.getElementById("channelBuilderBtn");t&&t.addEventListener("click",Iv),HP(),cS(),Dh(),Ov(),rE(),B1(),fi(),setTimeout(()=>{if(console.log("ðŸ” Debug chart initialization:"),console.log("  elements.inkChart =",!!m.inkChart),console.log("  elements.rows =",!!m.rows),console.log("  elements.rows.children.length =",m.rows?.children?.length||0),m.rows?.children?.length>0){console.log("  Sample row data-channel =",m.rows.children[0].getAttribute("data-channel"));const P=m.rows.children[0],k=P.querySelector(".percent-input"),N=P.querySelector(".end-input");console.log("  First row percent =",k?.value),console.log("  First row end =",N?.value)}Be(),console.log("ðŸ“Š Chart update called")},0);const n=Cx(),r=Ax();console.log(`ðŸ¤– AI Provider: ${r.provider} (${r.model})`),ff(),i1(),Jv(),s1(),console.log("ðŸŽ¨ Initializing Chat UI components..."),Ps.initialize();const i=lt();console.log(`ðŸ–¨ï¸ Printer: ${i.name} (${i.channels.length} channels)`);const a=(P={})=>{try{Eb?Eb(P):nn(P),typeof yt=="function"&&yt(),_r?.updateSessionStatus&&_r.updateSessionStatus()}catch(k){console.error("Preview update error:",k),Zd("Error updating preview")}},o=()=>{typeof yt=="function"&&yt()},s=P=>{typeof un=="function"&&un(P)},l=()=>{const P=$o().editMode||{};console.log("=== EDIT MODE DEBUG ==="),console.log("isEditModeEnabled exists:",typeof P.isEditModeEnabled),console.log("Edit mode enabled:",P.isEditModeEnabled?P.isEditModeEnabled():"N/A"),console.log("EDIT state:",P.EDIT),console.log("Selected channel:",P.EDIT?.selectedChannel),console.log("Selected ordinal:",P.EDIT?.selectedOrdinal)},c=()=>{console.log("ðŸ”§ Activating edit mode..."),ys(!0);const P=$o().editMode;P?.EDIT&&(P.EDIT.selectedChannel="MK",P.EDIT.selectedOrdinal=1,console.log("âœ… MK channel selected for editing")),Be(),console.log("âœ… Chart updated")},u=()=>{console.log("ðŸ”„ Testing recompute...");const k=$o().editMode?.EDIT?.selectedChannel;if(k){console.log(`Recomputing for channel: ${k}`);const N=Fi(k,{allowMeasurementResimplify:!0});console.log("Recompute result:",N),Be(),console.log("âœ… Chart updated")}else console.error("âŒ Recompute not available or no selected channel")},d=()=>{console.log("ðŸ§ª Setting up MK channel for testing...");const P=Array.from(m?.rows?.children||[]).find(N=>N.getAttribute("data-channel")==="MK");if(P){const N=P.querySelector(".percent-input"),F=P.querySelector(".end-input");N&&(N.value="100",N.dispatchEvent(new Event("input",{bubbles:!0})),console.log("âœ… MK percent set to 100")),F&&(F.value="65535",F.dispatchEvent(new Event("input",{bubbles:!0})),console.log("âœ… MK end set to 65535"))}else console.warn("MK channel row not found");ys(!0);const k=$o().editMode;k?.EDIT&&(k.EDIT.selectedChannel="MK",k.EDIT.selectedOrdinal=1,console.log("âœ… MK selected as editing channel")),Be(),console.log("âœ… Chart updated"),console.log("ðŸ§ª MK test setup complete! Try: __quadDebug.compat.testRecompute()")},p={downloadFile:To,generateFilename:ws,updateFilename:wo,getIntentFilenameTag:qp,getPresetDefaults:Hp,generateAndDownloadQuadFile:vk,downloadSampleLabData:GS,downloadSampleCubeFile:RS,SAMPLE_DATA:fu},f={QuadGenStateManager:kf,getStateManager:at,getState:Df,setState:Pf,batchUpdateState:xf,subscribeToState:Bf},h={HistoryManager:lm,getHistoryManager:Ft,recordChannelAction:yp,recordUIAction:Sp,recordBatchAction:vp,captureState:hs,undo:Ap,redo:Mp,clearHistory:Lp},g={initializeEventHandlers:eb,initializeAutoLimitHandlers:tb,removeEventHandlers:_D},b={applyGlobalScale:N0,scaleChannelEndsByPercent:Ys,reapplyCurrentGlobalScale:ic,updateScaleBaselineForChannel:gi,resetGlobalScale:F0,getCurrentScale:Ut,setScalingStateEnabled:es},C={quadGenActions:n,aiConfig:r,PRINTERS:dn,INK_COLORS:ni,InputValidator:q,elements:m,fileOperations:p,generateFilename:ws,updateFilename:wo,getIntentFilenameTag:qp,getPresetDefaults:Hp,stateManager:f,historyManager:h,scalingCoordinator:tr,scalingUtils:b,eventHandlers:g,chartManager:{initializeChart:Dh,updateInkChart:Be,getChartZoomPercent:Bo,setChartZoomPercent:I0,stepChartZoom:pp,getChartCoordinates:WA,setChartZoomIndex:eu,getChartZoomIndex:Ws,applyCorrectionGainPercent:om,applyCorrectionGainNormalized:w0},CHART_ZOOM_LEVELS:Dn,processingUtils:{CURVE_RESOLUTION:Ie,AUTO_LIMIT_CONFIG:Bc,DataSpace:ft,lerp:Af,clamp:Rr,createLinearRamp:Mf,scaleValues:Ub,normalizeToMax:rw,resampleArray:iw,validateCurveData:Lf,createEmptyCurve:If},smartCurves:{KP_SIMPLIFY:vn,ControlPolicy:Sn,ControlPoints:Te,isSmartCurve:Ni,isSmartCurveSourceTag:lu,generateCurveFromKeyPoints:IL,extractAdaptiveKeyPointsFromValues:Ar,rescaleSmartCurveForInkLimit:tl,validateKeyPoints:fS,createDefaultKeyPoints:nl,normalizeSmartSourcesInLoadedData:DL,simplifySmartKeyPointsFromCurve:Fi},linearizationUtils:{LinearizationState:D,normalizeLinearizationEntry:Rn,applyLinearizationExtras:cw,ensurePrinterSpaceData:Aa,getGlobalLinearizationInterpolationType:uw,createLinearizationData:dw,validateLinearizationData:pw,markLinearizationEdited:Hb,getEditedDisplayName:ur,getBasePointCountLabel:Pt,cloneLinearizationData:Nf},processingPipeline:{PROCESSING_CONSTANTS:ok,AutoEndpointRolloff:Hl,buildBaseCurve:Sm,applyPerChannelLinearizationStep:vm,applyGlobalLinearizationStep:Em,applyAutoEndpointAdjustments:PS,make256:Yt,apply1DLUT:pu,buildFile:Cm},fileParsers:{parseQuadFile:Am,parseACVFile:fc,parseCube1D:Mm,parseCube3D:mu,parseCgatsNumber:ln,parseCGATS17:il,parseLabData:uo,parseLinearizationFile:hu,parseManualLstarData:gu,parseIntentPaste:zS,validateFileFormat:US,validateQuadFile:$S},chatInterface:{ChatInterface:Um,getChatInterface:ko,sendChatMessage:kc,shouldShowAssistantStatus:tE,initializeChatInterface:ff},chatUI:{ChatUI:nE,chatUI:Ps},statusMessages:{StatusMessages:Iy,statusMessages:xn,addChatMessage:ky,addStatusMessage:pn,addErrorMessage:Zd,addSuccessMessage:Dy,addWarningMessage:Py,addProcessingMessage:xy,addConnectionMessage:By,addApiKeyStatus:Ty,addChannelOperationMessage:Oy,clearChatMessages:_y},graphStatus:_r,updatePreview:a,updateSessionStatus:o,updateProcessingDetail:s,updateProcessingDetailForce:s,debugEditMode:l,testEditMode:c,testRecompute:u,testMK:d},x=Object.keys(C);if(Xe("compat",C,{exposeOnWindow:!0,windowAliases:x}),Or){const P=Or.__quadDebug=Or.__quadDebug||{},k=typeof P.compat=="object"&&P.compat!==null?P.compat:{},N={...b,...k.scalingUtils||{}};N.setScalingStateEnabled=es,P.compat={...C,...k,scalingUtils:N},typeof Or.setScalingStateEnabled!="function"&&(Or.setScalingStateEnabled=es)}Or&&!Object.getOwnPropertyDescriptor(Or,"chartZoomIndex")&&Object.defineProperty(Or,"chartZoomIndex",{configurable:!0,get:()=>gt().chartZoomIndex,set:P=>nt({chartZoomIndex:P})}),console.log("âœ… quadGEN modular initialization complete"),console.log("ðŸ”§ Legacy helpers available via __quadDebug.compat.*"),console.log("  __quadDebug.compat.debugEditMode() - Show current edit mode state"),console.log("  __quadDebug.compat.testEditMode() - Activate edit mode"),console.log("  __quadDebug.compat.testRecompute() - Recompute Smart key points"),console.log("  __quadDebug.compat.testMK() - Prime MK channel for testing"),pn(`Switched to ${i.name}`)}document.addEventListener("DOMContentLoaded",Gx);</script>
  <style rel="stylesheet" crossorigin>:root{color-scheme:light;--bg: #f9fafb;--bg-elevated: #ffffff;--text: #111827;--muted: #374151;--border: #e5e7eb;--link: #374151;--link-hover: #111827;--code-bg: #f3f4f6;--code-text: #111827;--accent: #374151;--accent-contrast: #ffffff;--tooltip-bg: #111111;--tooltip-text: #ffffff;--scrollbar-track: var(--bg-elevated);--scrollbar-thumb-border: var(--bg-elevated);--console-bg: #0a0a0a;--console-text: #f5f5f5;--console-border: #262626;--console-resizer: rgba(115,115,115,.35);--console-resizer-hover: rgba(163,163,163,.55);--console-grip: rgba(163,163,163,.8);--console-input-bg: #0a0a0a;--console-input-border: #404040;--chart-grid: #e5e7eb;--chart-axis: #374151;--chart-text: #000000;--chart-helper-border: #9ca3af;--chart-bg: transparent}[data-theme=dark]{color-scheme:dark;--bg: #0a0a0a;--bg-subtle: #111111;--bg-elevated: #171717;--bg-elevated-hover: #1f1f1f;--text: #e5e5e5;--muted: #9ca3af;--muted-subtle: #6b7280;--border: #262626;--border-subtle: #1f1f1f;--border-emphasis: #374151;--link: #60a5fa;--link-hover: #93c5fd;--link-visited: #a78bfa;--code-bg: #0b1220;--code-text: #e5e7eb;--accent: #60a5fa;--accent-contrast: #1e293b;--accent-secondary: #8b5cf6;--interactive-hover: #1f2937;--interactive-pressed: #111827;--focus-ring: #60a5fa;--success: #10b981;--warning: #f59e0b;--error: #ef4444;--tooltip-bg: #111111;--tooltip-text: #ffffff;--scrollbar-track: var(--bg-elevated);--scrollbar-thumb-border: var(--bg-elevated);--console-bg: #111111;--console-text: #e5e5e5;--console-border: #262626;--console-resizer: rgba(115,115,115,.35);--console-resizer-hover: rgba(163,163,163,.55);--console-grip: rgba(163,163,163,.8);--console-input-bg: #0a0a0a;--console-input-border: #404040;--chart-grid: #404040;--chart-axis: #e5e5e5;--chart-text: #e5e5e5;--chart-helper-border: #525252;--chart-bg: rgba(255,255,255,.1)}#downloadBtn{background:linear-gradient(135deg,#2563eb,#8b5cf6);color:#fff;border:1px solid rgba(17,24,39,.08);box-shadow:0 0 0 2px #2563eb26,0 8px 14px #0000001f;text-shadow:0 1px 0 rgba(0,0,0,.15)}#downloadBtn:hover{filter:brightness(1.05);box-shadow:0 0 0 3px #2563eb40,0 10px 16px #00000029}#downloadBtn:active{transform:translateY(.5px);filter:brightness(.98)}#downloadBtn:focus-visible{outline:none;box-shadow:0 0 0 4px #2563eb59,0 10px 18px #0000002e}[data-theme=dark] #downloadBtn{background:linear-gradient(135deg,var(--accent),var(--accent-secondary));color:#fff;border:1px solid var(--border-emphasis);box-shadow:0 0 0 2px #60a5fa59,0 8px 16px #00000073;text-shadow:0 1px 0 rgba(0,0,0,.25)}[data-theme=dark] #downloadBtn:hover{filter:brightness(1.06);box-shadow:0 0 0 3px #60a5fa73,0 10px 18px #0000008c}[data-theme=dark] #downloadBtn:active{transform:translateY(.5px);filter:brightness(.98)}[data-theme=dark] #downloadBtn:focus-visible{outline:none;box-shadow:0 0 0 4px #60a5fa8c,0 10px 18px #0000008c}[data-theme=dark] #helpBtn,[data-theme=dark] #loadQuadBtn{background-color:#475569!important;color:#fff!important;border:1px solid transparent!important}[data-theme=dark] #helpBtn:hover,[data-theme=dark] #loadQuadBtn:hover{background-color:#374151!important}:root:not([data-theme=dark]) #labTechConsole,:root:not([data-theme=dark]) #previewConsole{background-color:#f7f7f9;color:var(--text)!important;border-color:#e5e7eb!important}:root:not([data-theme=dark]) #chatHistory{color:var(--muted)!important}:root:not([data-theme=dark]) #aiInputCompact,:root:not([data-theme=dark]) #userNotes,:root:not([data-theme=dark]) #previewFull{background-color:#fbfbfc;color:var(--text)!important;border-color:#d1d5db!important}:root:not([data-theme=dark]) #aiInputCompact:focus,:root:not([data-theme=dark]) #userNotes:focus{outline:none;box-shadow:0 0 0 3px #2563eb40;border-color:#93c5fd!important}:root:not([data-theme=dark]) #aiInputCompact::-moz-placeholder,:root:not([data-theme=dark]) #userNotes::-moz-placeholder{color:color-mix(in srgb,var(--muted) 60%,var(--bg-elevated))}:root:not([data-theme=dark]) #aiInputCompact::placeholder,:root:not([data-theme=dark]) #userNotes::placeholder{color:color-mix(in srgb,var(--muted) 60%,var(--bg-elevated))}:root:not([data-theme=dark]) #labTechResizer{background-color:#e5e7eb!important}:root:not([data-theme=dark]) #labTechResizer:hover{background-color:#d1d5db!important}:root:not([data-theme=dark]) .console-header{background:linear-gradient(to bottom,#fafafa,#f3f4f6);color:#374151!important;border-bottom:1px solid #e5e7eb}.chart-zoom-controls{position:absolute;bottom:.3rem;left:-9px;display:inline-flex;align-items:center;border-radius:.75rem;border:1px solid rgba(17,24,39,.12);background:#ffffffeb;z-index:12;padding:0 2px}.chart-zoom-btn{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;background:transparent;color:var(--text);font-size:1rem;font-weight:600;line-height:1;padding:.35rem .55rem;cursor:pointer;border-radius:.6rem;transition:background-color .15s ease,color .15s ease}.chart-zoom-btn:hover:not(:disabled){background:#2563eb14}.chart-zoom-btn:active:not(:disabled){background:#2563eb24}.chart-zoom-btn:focus-visible{outline:2px solid var(--focus-ring, #2563eb);outline-offset:2px}.chart-zoom-btn:disabled{cursor:not-allowed;opacity:.45}.chart-zoom-divider{width:1px;height:22px;background:#1118271f}[data-theme=dark] .chart-zoom-controls{background:#111827c7;border-color:#94a3b847;box-shadow:0 8px 16px #00000073}[data-theme=dark] .chart-zoom-btn{color:var(--text)}[data-theme=dark] .chart-zoom-btn:hover:not(:disabled){background:#94a3b829}[data-theme=dark] .chart-zoom-divider{background:#e5e7eb38}[data-theme=dark] #labTechConsole,[data-theme=dark] #previewConsole{background-color:var(--console-bg)!important;color:var(--console-text)!important;border-color:var(--console-border)!important}[data-theme=dark] #aiInputCompact:focus,[data-theme=dark] #userNotes:focus{outline:none;box-shadow:0 0 0 3px #60a5fa59;border-color:var(--console-input-border)!important}.quad-meta{color:var(--link);font-weight:600}.quad-comment{color:#047857}[data-theme=dark] .quad-comment{color:#34d399}.quad-number{color:var(--text)}.quad-error{color:#dc2626;font-weight:700}.quad-emph{font-weight:700}#previewFull{position:relative;counter-reset:quadline;--lnw: 3.2em;--lngap: .6em}#previewFull .quad-line{display:block;position:relative;padding-left:calc(var(--lnw) + var(--lngap))}#previewFull .quad-line:before{counter-increment:quadline;content:counter(quadline) " â”‚ ";position:absolute;left:0;top:0;bottom:0;width:var(--lnw);text-align:right;color:var(--ln-fg, color-mix(in srgb, var(--muted) 35%, var(--bg)));background:var(--ln-bg, transparent);-moz-user-select:none;user-select:none;-webkit-user-select:none;pointer-events:none;opacity:.55;font-weight:400}#previewFull .quad-line[data-ch]:before{opacity:1}[data-theme=dark] #previewFull .quad-line:before{color:var(--ln-fg, color-mix(in srgb, var(--muted) 45%, var(--bg)));opacity:.5}[data-theme=dark] #previewFull .quad-line[data-ch]:before{opacity:1!important}:root:not([data-theme=dark]) .labtech-sample{background-color:#f3f4f6;border:1px solid #e5e7eb;color:#374151!important}:root:not([data-theme=dark]) .labtech-sample strong{color:#111827}[data-theme=dark] .labtech-sample{background-color:#171717;border:1px solid #262626;color:#e5e5e5!important}[data-theme=dark] .labtech-sample strong{color:#fff}:root:not([data-theme=dark]) #previewFull::-webkit-scrollbar-track,:root:not([data-theme=dark]) #chatHistory::-webkit-scrollbar-track,:root:not([data-theme=dark]) #helpContent::-webkit-scrollbar-track{background:#f7f7f7}:root:not([data-theme=dark]) #previewFull::-webkit-scrollbar-thumb,:root:not([data-theme=dark]) #chatHistory::-webkit-scrollbar-thumb,:root:not([data-theme=dark]) #helpContent::-webkit-scrollbar-thumb{background:#c7c7c7;border-color:#fff}:root:not([data-theme=dark]) #previewFull,:root:not([data-theme=dark]) #chatHistory,:root:not([data-theme=dark]) #helpContent{scrollbar-color:#c7c7c7 #f7f7f7;scrollbar-width:auto}[data-theme=dark] #previewFull,[data-theme=dark] #chatHistory,[data-theme=dark] #helpContent{scrollbar-color:#4b5563 #111111;scrollbar-width:auto}body{background-color:var(--bg);color:var(--text)}.bg-white{background-color:var(--bg-elevated)!important}.bg-gray-50{background-color:var(--bg)!important}.bg-gray-100{background-color:color-mix(in srgb,var(--bg-elevated) 92%,var(--text))!important}[data-theme=dark] .bg-gray-100{background-color:var(--console-border)!important;color:var(--console-text)!important}[data-theme=dark] .border.border-gray-200.rounded-xl{background-color:var(--console-bg)!important;border-color:var(--console-border)!important}.border-gray-200,.border-gray-300{border-color:var(--border)!important}.text-gray-700,.text-gray-600{color:var(--muted)!important}.text-gray-500{color:color-mix(in srgb,var(--muted) 80%,var(--bg))!important}.text-gray-400{color:color-mix(in srgb,var(--muted) 65%,var(--bg))!important}.bg-blue-600{background-color:var(--accent)!important;color:var(--accent-contrast)!important}.hover\:bg-blue-700:hover{background-color:color-mix(in srgb,var(--accent) 85%,black)!important}.app-shell{background-color:var(--bg)!important;border:none}.space-y-4>*+*{margin-top:1rem}.space-y-3>*+*{margin-top:.75rem}.space-y-2>*+*{margin-top:.5rem}.flex{display:flex}.items-center{align-items:center}.gap-2{gap:.5rem}.gap-3{gap:.75rem}.gap-6{gap:1.5rem}.rounded-xl{border-radius:.75rem}.rounded-lg{border-radius:.5rem}.px-4{padding-left:1rem;padding-right:1rem}.py-4{padding-top:1rem;padding-bottom:1rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.mb-4{margin-bottom:1rem}.mb-2{margin-bottom:.5rem}.mt-4{margin-top:1rem}.w-full{width:100%}.main-container{width:100%;max-width:none;margin:0;padding:.5rem .75rem 0}.mx-auto{margin-left:auto;margin-right:auto}.grid{display:grid}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.gap-4{gap:1rem}.chart-canvas-wrapper{width:100%;position:relative;display:block;padding-bottom:.75rem}.chart-canvas-wrapper[data-chart-responsive=true]{height:var(--chart-dynamic-height, 515px)}.chart-canvas-wrapper[data-chart-responsive=false]{height:var(--chart-fixed-height, 515px)}.chart-canvas-wrapper canvas{width:100%;height:100%;display:block}#helpContent h2{font-size:1.125rem;line-height:1.5rem;font-weight:600;margin-top:.75rem;margin-bottom:.5rem;color:var(--text)}#helpContent h3{font-size:1rem;line-height:1.5rem;font-weight:600;margin-top:.5rem;margin-bottom:.25rem;color:var(--text)}#helpContent p{margin:.25rem 0 .5rem;color:var(--muted)}#helpContent hr{border:0;border-top:1px solid var(--border);margin:.75rem 0}#helpContent ul,#helpContent ol{margin:.25rem 0 .5rem 1.25rem;color:var(--muted)}#helpContent ul{list-style:disc;list-style-position:inside}#helpContent ol{list-style:decimal;list-style-position:inside}#helpContent li{margin:.125rem 0}#helpContent dl{margin:.25rem 0 .75rem}#helpContent dt{font-weight:700;margin-top:.75rem;color:var(--text)}#helpContent dd{margin:.15rem 0 .5rem .75rem;color:var(--muted)}#helpContent code{background:var(--code-bg);color:var(--code-text);padding:0 .25rem;border-radius:.25rem;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}#helpContent a{color:var(--link);text-decoration:underline}#helpContent a:hover{color:var(--link-hover)}[data-theme=dark] #helpTabs button{color:var(--muted)!important;border-bottom-color:transparent!important}[data-theme=dark] #helpTabs button.text-gray-800{color:#e5e7eb!important}[data-theme=dark] #helpTabs button.border-slate-700{border-bottom-color:#e5e7eb!important}#helpContent::-webkit-scrollbar{width:24px}#helpContent::-webkit-scrollbar-track{background:var(--scrollbar-track);border-radius:10px}#helpContent::-webkit-scrollbar-thumb{background:#c7c7c7;border-radius:10px;border:3px solid var(--scrollbar-thumb-border);min-height:60px}#helpContent::-webkit-scrollbar-thumb:hover{background:#b3b3b3}#helpContent::-webkit-scrollbar-thumb:active{background:#9a9a9a}[data-theme=dark] #helpContent::-webkit-scrollbar-thumb{background:#4b5563;border-color:var(--console-bg)}[data-theme=dark] #helpContent::-webkit-scrollbar-thumb:hover{background:#6b7280}[data-theme=dark] #helpContent::-webkit-scrollbar-track{background:var(--console-bg)}[data-theme=dark] #helpPopup>div{background-color:var(--bg-elevated)!important;border:1px solid var(--border-emphasis)!important;box-shadow:0 16px 48px #0009}[data-theme=dark] #helpPopup,[data-theme=dark] #globalCorrectionHelpPopup,[data-theme=dark] #intentHelpPopup{background-color:#00000080!important}[data-theme=dark] #helpPopup svg [stroke="#1A1A1A"]{stroke:#e5e7eb!important}[data-theme=dark] #helpPopup svg [fill="#1A1A1A"]{fill:#e5e5e5!important}[data-theme=dark] #intentHelpPopup>div{background-color:var(--bg-elevated)!important;border:1px solid var(--border-emphasis)!important;box-shadow:0 16px 48px #0009}.help-callout{background-color:#f9fafb;border:1px solid #e5e7eb;border-radius:.75rem;padding:.75rem}[data-theme=dark] .help-callout{background-color:#1f2937;border-color:#374151;color:#e5e7eb}.help-badge{display:inline-block;padding:2px 8px;border-radius:9999px;font-size:.75rem;border:1px solid #e5e7eb;background:#f3f4f6;color:#374151}[data-theme=dark] .help-badge{border-color:#374151;background:#111827;color:#e5e7eb}[data-theme=dark] #intentModal>div{background-color:var(--bg-elevated)!important;border:1px solid var(--border-emphasis)!important;box-shadow:0 16px 48px #0009}[data-theme=dark] #intentModal{background-color:#00000080!important}#intentContent::-webkit-scrollbar{width:24px}#intentContent::-webkit-scrollbar-track{background:var(--scrollbar-track);border-radius:10px}#intentContent::-webkit-scrollbar-thumb{background:#c7c7c7;border-radius:10px;border:3px solid var(--scrollbar-thumb-border);min-height:60px}#intentContent::-webkit-scrollbar-thumb:hover{background:#b3b3b3}#intentContent::-webkit-scrollbar-thumb:active{background:#9a9a9a}[data-theme=dark] #intentContent::-webkit-scrollbar-thumb{background:#4b5563;border-color:var(--console-bg)}[data-theme=dark] #intentContent::-webkit-scrollbar-thumb:hover{background:#6b7280}[data-theme=dark] #intentContent::-webkit-scrollbar-track{background:var(--console-bg)}[data-theme=dark] #intentPasteNote{background-color:#1f2937!important;color:#e5e7eb!important;border-color:#374151!important}[data-theme=dark] #intentPasteValidation.text-green-700{color:#34d399!important}[data-theme=dark] .border-gray-800{border-color:var(--border-subtle)!important}[data-theme=dark] #clearChatBtn{background-color:#475569!important;color:#fff!important;border:1px solid transparent!important}[data-theme=dark] #clearChatBtn:hover{background-color:#374151!important}[data-theme=dark] .bg-black{background-color:var(--bg-elevated)!important;color:var(--text)!important}[data-theme=dark] #quadgenLogo [stroke="#1A1A1A"]{stroke:#e5e7eb!important}[data-theme=dark] #quadgenLogo [fill="#1A1A1A"]{fill:#e5e7eb!important}input[type=number]::-webkit-outer-spin-button,input[type=number]::-webkit-inner-spin-button{-webkit-appearance:inner-spin-button!important;opacity:1!important}input[type=number]{-moz-appearance:number-input}.main-actions-bar .toolbar-button,.main-actions-bar #filenameInput{padding-top:.35rem;padding-bottom:.35rem}.slider-toggle{position:relative;display:inline-block;width:40px;height:20px}.slider-toggle input{opacity:0;width:0;height:0}.slider{position:absolute;cursor:pointer;inset:0;background-color:#ccc;transition:.4s;border-radius:20px}.slider:before{position:absolute;content:"";height:16px;width:16px;left:2px;bottom:2px;background-color:#fff;transition:.4s;border-radius:50%}input:checked+.slider{background-color:#10b981}input:focus+.slider{box-shadow:0 0 1px #10b981}input:checked+.slider:before{transform:translate(20px)}input:disabled+.slider{background-color:#e5e5e5;cursor:not-allowed}input:disabled+.slider:before{background-color:#f5f5f5}[data-theme=dark] .slider{background-color:var(--border)!important}[data-theme=dark] input:checked+.slider{background-color:var(--accent)!important}[data-theme=dark] input:focus+.slider{box-shadow:0 0 0 2px #525252!important}[data-theme=dark] .slider:before{background-color:#e5e5e5!important}[data-theme=dark] input:disabled+.slider{background-color:#1f1f1f!important}[data-theme=dark] input:disabled+.slider:before{background-color:#3a3a3a!important}#previewFull::-webkit-scrollbar{width:24px}#previewFull::-webkit-scrollbar-track{background:var(--scrollbar-track);border-radius:10px}#previewFull::-webkit-scrollbar-thumb{background:#c7c7c7;border-radius:10px;border:3px solid var(--scrollbar-thumb-border);min-height:60px}#previewFull::-webkit-scrollbar-thumb:hover{background:#b3b3b3}#previewFull::-webkit-scrollbar-thumb:active{background:#9a9a9a}#chatHistory::-webkit-scrollbar{width:24px}#chatHistory::-webkit-scrollbar-track{background:var(--scrollbar-track);border-radius:10px}#chatHistory::-webkit-scrollbar-thumb{background:#c7c7c7;border-radius:10px;border:3px solid var(--scrollbar-thumb-border);min-height:60px}#chatHistory::-webkit-scrollbar-thumb:hover{background:#b3b3b3}#chatHistory::-webkit-scrollbar-thumb:active{background:#9a9a9a}[data-theme=dark] #previewFull::-webkit-scrollbar-thumb,[data-theme=dark] #chatHistory::-webkit-scrollbar-thumb{background:#4b5563;border-color:var(--console-bg)}[data-theme=dark] #previewFull::-webkit-scrollbar-thumb:hover,[data-theme=dark] #chatHistory::-webkit-scrollbar-thumb:hover{background:#6b7280}[data-theme=dark] #previewFull::-webkit-scrollbar-track,[data-theme=dark] #chatHistory::-webkit-scrollbar-track{background:var(--console-bg)}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}.tooltip-trigger{position:relative;cursor:help}.floating-tooltip{position:fixed;z-index:4000;background-color:var(--tooltip-bg);color:var(--tooltip-text);padding:6px 10px;border-radius:6px;font-size:12px;line-height:1.4;box-shadow:0 8px 16px #0000002e;pointer-events:none;max-width:320px;word-wrap:break-word;opacity:1;transition:opacity .12s ease-in-out}.floating-tooltip.hidden{opacity:0;visibility:hidden}.per-channel-btn,#globalLinearizationBtn{position:relative}.per-channel-btn:hover:after,#globalLinearizationBtn:hover:after{content:attr(data-tooltip);position:absolute;bottom:calc(100% + 6px);left:50%;transform:translate(-50%);background-color:var(--tooltip-bg);color:var(--tooltip-text);padding:4px 8px;border-radius:4px;font-size:12px;line-height:1.3;white-space:normal;max-width:220px;z-index:1000;margin-bottom:4px;pointer-events:none;box-shadow:0 6px 12px #00000026}.per-channel-btn:hover:before,#globalLinearizationBtn:hover:before{content:"";position:absolute;bottom:100%;left:50%;transform:translate(-50%);width:0;height:0;border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid var(--tooltip-bg);z-index:1000;pointer-events:none}.lstar-input::-webkit-outer-spin-button,.lstar-input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}.lstar-input[type=number]{-moz-appearance:textfield}.standard-dropdown{width:100%;padding:.125rem .5rem;border:1px solid #d1d5db;border-radius:.375rem;font-size:.8125rem;line-height:1.25;height:28px;box-sizing:border-box;background-color:#fff;color:#374151}#editPanelBody.edit-panel-disabled{opacity:.6;pointer-events:none;filter:grayscale(10%)}.standard-dropdown:disabled{background-color:#f9fafb;color:#9ca3af;cursor:not-allowed}.standard-dropdown option{font-size:.8125rem;line-height:1.25;color:#374151}#intentTab-custom input[type=range]{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:100%;height:8px;border-radius:9999px;background:#e5e7eb;outline:none;transition:filter .12s ease}[data-theme=dark] #intentTab-custom input[type=range]{background:var(--console-input-bg)}#intentTab-custom input[type=range]:hover{filter:brightness(1.02)}#intentTab-custom input[type=range]:focus{box-shadow:0 0 0 3px #3b82f640}#intentTab-custom input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:#fff;border:1px solid #cbd5e1;border-radius:9999px;box-shadow:0 1px 2px #0000001f;margin-top:-4px}#intentTab-custom input[type=range]::-moz-range-track{height:8px;border-radius:9999px;background:#e5e7eb}#intentTab-custom input[type=range]::-moz-range-progress{height:8px;border-radius:9999px;background:transparent}#intentTab-custom input[type=range]::-moz-range-thumb{width:16px;height:16px;background:#fff;border:1px solid #cbd5e1;border-radius:9999px;box-shadow:0 1px 2px #0000001f}input[type=checkbox]{accent-color:#ffffff}.nudge-btn{background-color:#475569;color:#fff;transition:transform .05s ease,background-color .1s ease;-webkit-user-select:none;-moz-user-select:none;user-select:none}#editPanelBody button:disabled,#editPanelBody .nudge-btn:disabled{background-color:#475569;color:#fff;opacity:.5;cursor:not-allowed}#editPanelBody #editPointIndex.is-disabled{background-color:#475569;color:#fff;opacity:.5}.nudge-btn:hover{background-color:#374151}.nudge-btn:active{background-color:#000;transform:translateY(2px)}button{transition:transform .05s ease}button:active{transform:translateY(2px)}.channel-row{transition:all .2s ease-in-out}.channel-row[data-compact=true]{display:none}#generateFromLstar:disabled{background-color:#9ca3af;cursor:not-allowed;opacity:.7}.disabled-channels-compact{background-color:var(--bg-elevated);border:1px solid var(--border);border-radius:8px;padding:4px 6px;margin:8px 0;display:none}.disabled-channels-compact.show{display:block}.disabled-channels-compact .compact-label{font-size:11px;font-weight:600;color:var(--muted);text-transform:uppercase;letter-spacing:.05em;margin-bottom:6px;display:block}.disabled-channels-row{display:flex;flex-wrap:wrap;gap:6px;align-items:center}.disabled-channel-chip{display:inline-flex;align-items:center;gap:4px;background-color:var(--bg-elevated);border-radius:6px;padding:3px 8px;font-size:12px;color:var(--muted);cursor:pointer;transition:all .15s ease-in-out;-webkit-user-select:none;-moz-user-select:none;user-select:none}.disabled-channel-chip:hover{background-color:color-mix(in srgb,var(--bg-elevated) 85%,var(--text));transform:translateY(-1px);box-shadow:0 2px 4px #0000001a}.disabled-channel-chip.active{background-color:color-mix(in srgb,var(--accent) 15%,var(--bg-elevated));color:var(--accent)}.disabled-channel-chip .channel-color{width:12px;height:12px;border-radius:2px;border:1px solid color-mix(in srgb,var(--border) 80%,var(--text));flex-shrink:0;display:inline-block}.disabled-channel-chip .channel-checkbox{width:12px;height:12px;margin:0;cursor:pointer;accent-color:#ffffff}.disabled-channel-chip .channel-name{font-weight:600;min-width:20px;color:var(--muted);font-size:12px}.disabled-channels-compact .compact-label:after{content:":";margin-left:2px}.disabled-channels-compact{transition:all .3s ease-in-out;transform-origin:top}.disabled-channels-compact:not(.show){max-height:0;opacity:0;margin:0;padding:0;border:none;overflow:hidden}#chatHistory .chat-line{display:block;margin:0 0 2px;white-space:pre-wrap}:root:not([data-theme=dark]) #chatHistory .chat-line.assistant{color:#111827}:root:not([data-theme=dark]) #chatHistory .chat-line.user{color:#065f46;font-weight:600}:root:not([data-theme=dark]) #chatHistory .chat-line.system{color:#6b7280;font-style:italic}[data-theme=dark] #chatHistory .chat-line.assistant{color:#e5e5e5}[data-theme=dark] #chatHistory .chat-line.user{color:#34d399;font-weight:600}[data-theme=dark] #chatHistory .chat-line.system{color:#9ca3af;font-style:italic}#chatHistory a{color:var(--link);text-decoration:underline;font-weight:600}#chatHistory a:hover{color:var(--link-hover);text-decoration:underline}#chatHistory a[target=_blank]:after{content:" â†—";font-weight:600;color:var(--muted)}:root:not([data-theme=dark]) #chatHistory .chat-line.user a{color:#15803d}:root:not([data-theme=dark]) #chatHistory .chat-line.user a:hover{color:#16a34a}:root:not([data-theme=dark]) #labTechConsole{--onl-bg: #fafafa;--onl-fg: #383a42;--onl-muted: #a0a1a7;--onl-blue: #4078f2;--onl-cyan: #0184bc;--onl-green: #50a14f;--onl-orange: #c18401;--onl-pink: #a626a4;--onl-red: #e45649;--onl-yellow: #986801;background-color:var(--onl-bg)!important;color:var(--onl-fg)!important;border-color:#e6e6e6!important}:root:not([data-theme=dark]) #labTechConsole #chatHistory .chat-line{color:var(--onl-fg)}:root:not([data-theme=dark]) #labTechConsole #chatHistory .chat-line.user{color:var(--onl-green);font-weight:600}:root:not([data-theme=dark]) #labTechConsole #chatHistory .chat-line.assistant{color:var(--onl-fg)}:root:not([data-theme=dark]) #labTechConsole #chatHistory .chat-line.system{color:var(--onl-muted);font-style:italic}:root:not([data-theme=dark]) #labTechConsole #chatHistory .chat-line.system.error{color:var(--onl-red);font-style:normal}:root:not([data-theme=dark]) #labTechConsole #chatHistory .chat-line.system.info{color:var(--onl-cyan);font-style:normal}:root:not([data-theme=dark]) #labTechConsole #chatHistory a{color:var(--onl-blue);text-decoration:underline;font-weight:600}:root:not([data-theme=dark]) #labTechConsole #chatHistory a:hover{color:#6ea1ff}:root:not([data-theme=dark]) #labTechConsole #aiInputCompact{background:var(--onl-bg)!important;color:var(--onl-fg)!important;border-color:#d0d0d0!important}:root:not([data-theme=dark]) #labTechConsole #aiInputCompact::-moz-placeholder{color:var(--onl-muted)}:root:not([data-theme=dark]) #labTechConsole #aiInputCompact::placeholder{color:var(--onl-muted)}:root:not([data-theme=dark]) #labTechConsole #aiInputCompact:focus{outline:none!important;box-shadow:0 0 0 2px #4078f240!important;border-color:#4078f2!important}:root:not([data-theme=dark]) #labTechConsole #clearChatBtn{background:#efefef!important;color:var(--onl-fg)!important;border:1px solid #e2e2e2!important}:root:not([data-theme=dark]) #labTechConsole #clearChatBtn:hover{background:#e7e7e7!important}[data-theme=dark] #chatHistory,[data-theme=dark] #previewFull,[data-theme=dark] #userNotes,[data-theme=dark] #aiInputCompact{background-color:var(--console-bg)!important;color:var(--console-text)!important;border-color:var(--console-input-border)!important}[data-theme=dark] #previewFull{background-color:var(--bg-elevated-hover)!important}[data-theme=dark] #labTechResizer{background-color:var(--console-resizer)!important}[data-theme=dark] #labTechResizer:hover{background-color:var(--console-resizer-hover)!important}[data-theme=dark] #labTechResizer span,[data-theme=dark] #previewResizer span{background-color:var(--console-grip)!important}[data-theme=dark] #previewResizer{background-color:var(--console-resizer)!important}[data-theme=dark] #previewResizer:hover{background-color:var(--console-resizer-hover)!important}[data-theme=dark] #userNotes::-moz-placeholder,[data-theme=dark] #aiInputCompact::-moz-placeholder{color:#9a9a9a}[data-theme=dark] #userNotes::placeholder,[data-theme=dark] #aiInputCompact::placeholder{color:#9a9a9a}[data-theme=dark] #userNotes{border-color:var(--console-input-border)!important}[data-theme=dark] .percent-input,[data-theme=dark] .end-input,[data-theme=dark] #scaleAllInput{background-color:var(--console-input-bg)!important;color:var(--text)!important;border-color:var(--console-input-border)!important}[data-theme=dark] .percent-input::-moz-placeholder,[data-theme=dark] .end-input::-moz-placeholder,[data-theme=dark] #scaleAllInput::-moz-placeholder{color:#9a9a9a}[data-theme=dark] .percent-input::placeholder,[data-theme=dark] .end-input::placeholder,[data-theme=dark] #scaleAllInput::placeholder{color:#9a9a9a}[data-theme=dark] .percent-input:focus,[data-theme=dark] .end-input:focus,[data-theme=dark] #scaleAllInput:focus{outline:2px solid #737373;outline-offset:0;box-shadow:none!important;border-color:#737373!important}[data-theme=dark] #filenameInput,[data-theme=dark] .standard-dropdown,[data-theme=dark] .lstar-input,[data-theme=dark] #editXYInput,[data-theme=dark] #aiInput,[data-theme=dark] #editMaxError,[data-theme=dark] #editMaxPoints,[data-theme=dark] #perChannelDeltaSelect{background-color:var(--console-input-bg)!important;color:var(--text)!important;border-color:var(--console-input-border)!important}[data-theme=dark] #filenameInput::-moz-placeholder,[data-theme=dark] .lstar-input::-moz-placeholder,[data-theme=dark] #editXYInput::-moz-placeholder,[data-theme=dark] #aiInput::-moz-placeholder{color:#9a9a9a}[data-theme=dark] #filenameInput::placeholder,[data-theme=dark] .lstar-input::placeholder,[data-theme=dark] #editXYInput::placeholder,[data-theme=dark] #aiInput::placeholder{color:#9a9a9a}[data-theme=dark] #filenameInput:focus,[data-theme=dark] .standard-dropdown:focus,[data-theme=dark] .lstar-input:focus,[data-theme=dark] #editXYInput:focus,[data-theme=dark] #aiInput:focus,[data-theme=dark] #editMaxError:focus,[data-theme=dark] #editMaxPoints:focus,[data-theme=dark] #perChannelDeltaSelect:focus{outline:2px solid #737373;outline-offset:0;box-shadow:none!important;border-color:#737373!important}@media (min-width: 1024px){.lg\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.lg\:col-span-2{grid-column:span 2 / span 2}}#chartContainer{height:var(--chart-height, 60vh);min-height:320px;max-height:80vh;display:flex;flex-direction:column}#chartContainer .chart-canvas-wrapper{height:100%!important;flex:1}.chart-divider{height:10px;background:linear-gradient(to bottom,var(--border),var(--bg));border-top:1px solid var(--border);border-bottom:1px solid var(--border);cursor:row-resize;display:flex;align-items:center;justify-content:center;transition:background-color .15s ease;position:relative;z-index:10}.chart-divider:hover{background:linear-gradient(to bottom,color-mix(in srgb,var(--accent) 15%,var(--border)),color-mix(in srgb,var(--accent) 8%,var(--bg)))}.chart-divider:active{background:linear-gradient(to bottom,color-mix(in srgb,var(--accent) 25%,var(--border)),color-mix(in srgb,var(--accent) 15%,var(--bg)))}.chart-divider-grip{width:40px;height:3px;background:var(--muted);border-radius:2px;opacity:.4;transition:opacity .15s ease}.chart-divider:hover .chart-divider-grip{opacity:.7}.app-layout{display:flex;gap:0;min-height:600px;position:relative}.main-content-area{flex:1 1 auto;min-width:450px;display:flex;flex-direction:column;gap:0}.chart-panel{flex:0 0 auto;display:flex;flex-direction:column}.right-panel{flex:0 0 256px;min-width:256px;max-width:50%;display:flex;flex-direction:column;background:var(--bg-elevated);border-left:1px solid var(--border)}.panel-divider{width:10px;background:linear-gradient(to right,var(--border),var(--bg));border-left:1px solid var(--border);border-right:1px solid var(--border);cursor:col-resize;display:flex;align-items:center;justify-content:center;transition:background-color .15s ease;position:relative;z-index:10;flex-shrink:0}.panel-divider:hover{background:linear-gradient(to right,color-mix(in srgb,var(--accent) 15%,var(--border)),color-mix(in srgb,var(--accent) 8%,var(--bg)))}.panel-divider:active,.panel-divider.dragging{background:linear-gradient(to right,color-mix(in srgb,var(--accent) 25%,var(--border)),color-mix(in srgb,var(--accent) 15%,var(--bg)))}.panel-divider-grip{height:40px;width:3px;background:var(--muted);border-radius:2px;opacity:.4;transition:opacity .15s ease}.panel-divider:hover .panel-divider-grip{opacity:.7}.vertical-tab-nav{display:flex;flex-direction:column;gap:0;background:color-mix(in srgb,var(--bg-elevated) 95%,var(--text));border-bottom:2px solid var(--border);padding:0;flex-shrink:0}.tab-btn-vertical-row{display:flex;align-items:stretch;border-bottom:1px solid var(--border)}.tab-btn-vertical-row:last-child{border-bottom:none}.tab-btn-vertical-row .tab-btn-vertical{flex:1;border-radius:0;border-right:1px solid var(--border)}.tab-btn-vertical-help{display:flex;align-items:center;justify-content:center;padding:.5rem .75rem;font-size:.875rem;font-weight:600;color:var(--muted);background:transparent;border:none;cursor:pointer;transition:all .15s ease}.tab-btn-vertical-help:hover{color:var(--text);background:color-mix(in srgb,var(--bg-elevated) 85%,var(--text))}.tab-btn-vertical-help:focus-visible{outline:2px solid var(--focus-ring, #2563eb);outline-offset:-2px}.tab-btn-vertical{padding:.5rem 1rem;font-size:.875rem;font-weight:600;color:var(--muted);background:transparent;border:none;border-left:3px solid transparent;cursor:pointer;transition:all .15s ease;display:flex;align-items:center;gap:.75rem;text-align:left}.tab-btn-vertical .tab-icon{font-size:1rem;flex-shrink:0}.tab-btn-vertical .tab-label{flex:1}.tab-btn-vertical:hover{color:var(--text);background:color-mix(in srgb,var(--bg-elevated) 85%,var(--text))}.tab-btn-vertical.active{color:var(--accent);background:var(--bg-elevated);border-left-color:var(--accent)}.tab-btn-vertical:focus-visible{outline:2px solid var(--focus-ring, #2563eb);outline-offset:-2px}.tab-content-wrapper-vertical{flex:1;overflow-y:auto;overflow-x:hidden;padding:0}.tab-content-wrapper-vertical .tab-content{padding:0}@media (max-width: 830px){.app-layout{flex-direction:column}.main-content-area,.chart-panel{min-width:100%;width:100%}.right-panel{min-width:100%;width:100%;max-width:100%;border-left:none;border-top:1px solid var(--border)}.panel-divider{display:none}}.tool-tabs-container{display:flex;flex-direction:column;border:1px solid var(--border);border-radius:.75rem;overflow:visible;background:var(--bg-elevated)}.tab-nav{display:flex;gap:0;background:color-mix(in srgb,var(--bg-elevated) 95%,var(--text));border-bottom:2px solid var(--border);padding:0;flex-shrink:0}.tab-btn{flex:1;padding:.35rem .75rem;font-size:.875rem;font-weight:600;color:var(--muted);background:transparent;border:none;border-bottom:3px solid transparent;cursor:pointer;transition:all .15s ease;position:relative;display:flex;align-items:center;justify-content:center;gap:.375rem}.tab-title{font-family:Segoe UI Semibold,Segoe UI,Helvetica Neue,Helvetica,Arial,sans-serif;font-weight:600;letter-spacing:.03em;text-transform:uppercase;font-size:.92em;display:inline-block}.tab-icon{font-size:1rem;line-height:1}.tab-btn:hover{color:var(--text);background:color-mix(in srgb,var(--bg-elevated) 85%,var(--text))}.tab-btn:active{transform:translateY(1px)}.tab-btn.active{color:var(--accent);background:var(--bg-elevated);border-bottom-color:var(--accent)}.tab-btn:focus-visible{outline:2px solid var(--focus-ring, var(--accent));outline-offset:-2px;z-index:1}.tab-content-wrapper{overflow:visible;background:var(--bg-elevated)}.tab-content{display:none;padding:.3rem 1rem 1rem;animation:tabFadeIn .2s ease-in}.tab-content.active{display:block}@keyframes tabFadeIn{0%{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}.tab-content-wrapper::-webkit-scrollbar{width:12px}.tab-content-wrapper::-webkit-scrollbar-track{background:var(--bg)}.tab-content-wrapper::-webkit-scrollbar-thumb{background:var(--border);border-radius:6px;border:2px solid var(--bg)}.tab-content-wrapper::-webkit-scrollbar-thumb:hover{background:var(--muted)}[data-theme=dark] .chart-divider{background:linear-gradient(to bottom,var(--border-emphasis),var(--bg-subtle))}[data-theme=dark] .chart-divider:hover{background:linear-gradient(to bottom,color-mix(in srgb,var(--accent) 20%,var(--border-emphasis)),color-mix(in srgb,var(--accent) 12%,var(--bg-subtle)))}[data-theme=dark] .chart-divider-grip{background:var(--text);opacity:.3}[data-theme=dark] .chart-divider:hover .chart-divider-grip{opacity:.5}[data-theme=dark] .panel-divider{background:linear-gradient(to right,var(--border-emphasis),var(--bg-subtle))}[data-theme=dark] .panel-divider:hover{background:linear-gradient(to right,color-mix(in srgb,var(--accent) 20%,var(--border-emphasis)),color-mix(in srgb,var(--accent) 12%,var(--bg-subtle)))}[data-theme=dark] .panel-divider-grip{background:var(--text);opacity:.3}[data-theme=dark] .panel-divider:hover .panel-divider-grip{opacity:.5}[data-theme=dark] .vertical-tab-nav{background:var(--bg-subtle);border-bottom-color:var(--border-emphasis)}[data-theme=dark] .tab-btn-vertical-row{border-bottom-color:var(--border-emphasis)}[data-theme=dark] .tab-btn-vertical-row:last-child{border-bottom:none}[data-theme=dark] .tab-btn-vertical-row .tab-btn-vertical{border-right-color:var(--border-emphasis)}[data-theme=dark] .tab-btn-vertical:hover{background:var(--bg-elevated-hover)}[data-theme=dark] .tab-btn-vertical.active{background:var(--bg-elevated)}[data-theme=dark] .tab-btn-vertical-help{color:var(--muted)}[data-theme=dark] .tab-btn-vertical-help:hover{color:var(--text);background:var(--bg-elevated-hover)}[data-theme=dark] .tab-nav{background:var(--bg-subtle);border-bottom-color:var(--border-emphasis)}[data-theme=dark] .tab-btn:hover{background:color-mix(in srgb,var(--bg-elevated) 90%,var(--text))}</style>
</head>
<body class="min-h-screen bg-gray-50">
<main class="main-container">
<section class="app-shell bg-white">
<header class="mb-1">
<div class="grid grid-cols-1 lg:grid-cols-3 gap-6 items-center mb-1">
<div class="flex items-center gap-4 lg:col-span-3">
<a aria-label="Open quadGEN source on GitHub" class="flex-shrink-0" href="https://github.com/David-Marsh-Photo/quadGEN" rel="noopener" target="_blank">
<svg aria-labelledby="quadgenTitle quadgenDesc" height="56" id="quadgenLogo" role="img" viewbox="0 0 160 160" width="56" xmlns="http://www.w3.org/2000/svg">
<title id="quadgenTitle">quadGEN icon (CMYK)</title>
<desc id="quadgenDesc">Four CMYK bars with a rising Bezier-style curve and nodes, flat design.</desc>
<!-- baseline -->
<path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-linecap="round" stroke-width="8"></path>
<!-- CMYK bars -->
<rect fill="#00B5E2" height="40" id="cyanBar" rx="6" ry="6" width="20" x="20" y="90"></rect>
<rect fill="#FF2A8A" height="60" id="magentaBar" rx="6" ry="6" width="20" x="52" y="70"></rect>
<rect fill="#FFD400" height="80" id="yellowBar" rx="6" ry="6" width="20" x="84" y="50"></rect>
<rect fill="#1A1A1A" height="110" id="blackBar" rx="6" ry="6" width="20" x="116" y="22"></rect>
<!-- Bezier-like curve -->
<path d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18" fill="none" id="logoPath" stroke="#1A1A1A" stroke-linecap="round" stroke-linejoin="round" stroke-width="8"></path>
<!-- curve nodes -->
<circle cx="30" cy="88" fill="white" id="node1" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
<circle cx="62" cy="68" fill="white" id="node2" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
<circle cx="94" cy="48" fill="white" id="node3" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
<circle cx="126" cy="18" fill="white" id="node4" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
</svg>
</a>
<div>
<h1 class="text-2xl md:text-3xl font-semibold tracking-tight">
<a class="text-inherit no-underline hover:text-gray-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-slate-500" href="https://github.com/David-Marsh-Photo/quadGEN" rel="noopener" target="_blank">
                  quadGEN
                </a>
<span class="text-gray-400 text-lg" id="appVersion"></span>
</h1>
<p class="text-gray-400 text-sm -mt-1">by <a class="hover:text-gray-600 underline" href="https://www.davidmarshprints.com/" rel="noopener noreferrer" target="_blank">David Marsh</a></p>
</div>
<!-- Compact printer selector -->
<div class="flex items-center gap-2 bg-gray-50 rounded-lg border border-gray-200 px-3 py-2 flex-1 ml-4">
<label class="text-sm font-medium text-gray-700" for="printerSelect">Printer:</label>
<select class="standard-dropdown" id="printerSelect" style="width: 120px;">
<option selected="" value="P700P900">P700-P900</option>
<option value="P5-7-9000">P5-7-9000</option>
<option value="P800">P600-P800</option>
<option value="P400">P400</option>
<option value="x900">x900</option>
<option value="3880-7880">3880-7880</option>
<option value="x800-x890">x800-x890</option>
<option value="P4-6-8000">P4-6-8000</option>
</select>
<p class="flex-1 text-xs text-gray-600 ml-1" id="channelInfo"></p>
<button class="text-sm bg-gray-100 hover:bg-gray-200 text-gray-800 rounded px-3 py-1 transition-colors ml-auto font-bold" id="optionsBtn" title="Application options">
                âš™ï¸ Options
              </button>
<button class="text-sm bg-emerald-600 hover:bg-emerald-700 text-white rounded px-3 py-1 transition-colors font-bold" id="channelBuilderBtn" title="Build multi-ink quad from L* measurements">
                ðŸ”§ Channel Builder
              </button>
<button class="text-sm bg-blue-600 hover:bg-blue-700 text-white rounded px-3 py-1 transition-colors font-bold" id="helpBtn" title="Help and quick start">
                ðŸ“– Help
              </button>
<button aria-pressed="false" class="ml-2 text-sm rounded px-2 py-1 font-bold border border-gray-300 bg-white hover:bg-gray-50 transition-colors" id="themeToggle" title="Toggle dark mode">ðŸŒ™</button>
</div>
</div>
</div>
<p class="text-gray-600 mt-1" id="printerDescription"></p>
</header>
<!-- Main Actions -->
<div class="mb-3">
<div class="flex items-center gap-2 bg-white border border-gray-200 rounded-xl p-2 main-actions-bar">
<input accept=".quad" class="hidden" id="quadFile" type="file"/>
<button class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-700 rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed toolbar-button" disabled="" id="undoBtn" title="No changes to undo">
            â†º Undo
          </button>
<button class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-700 rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed toolbar-button" disabled="" id="redoBtn" title="No changes to redo">
            â†» Redo
          </button>
<button class="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors font-bold toolbar-button" id="loadQuadBtn">
            â†’ Load .quad
          </button>
<button class="px-4 py-2 text-sm bg-black text-white hover:bg-black/90 rounded transition-colors font-bold toolbar-button" id="downloadBtn">
            â†“ Download .quad
          </button>
<input class="flex-1 ml-3 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" id="filenameInput" placeholder="P900_K33_C33_M33..." type="text"/>
<span class="text-sm text-gray-500">.quad</span>
</div>
</div>
<!-- App Layout: Main Content + Right Panel -->
<div class="app-layout">
<!-- Main Content Area: Chart + Bottom Tabs -->
<div class="main-content-area">
<!-- Chart Area -->
<div class="chart-panel" id="chartPanel">
<div id="chartContainer">
<div class="chart-canvas-wrapper relative" data-chart-wrapper="" style="padding-top: 1.25rem; padding-bottom: 0.75rem">
<canvas id="inkChart"></canvas>
<div class="pointer-events-none absolute inset-0 hidden" id="snapshotFlagOverlay"></div>
<!-- X-axis title (positioned below canvas) -->
<div class="absolute left-0 right-0 text-center text-xs text-gray-700" style="top: calc(100% - 1.3rem); margin-top: 0;">
<span id="xAxisTitle">Input Level %</span>
</div>
<!-- Y-axis title (positioned left of canvas, rotated) -->
<div class="absolute text-xs text-gray-700" style="left: -45px; top: 50%; transform: translateY(-50%) rotate(-90deg); transform-origin: center; white-space: nowrap;">
<span id="yAxisTitle">Output Ink Level %</span>
</div>
<!-- Chart zoom controls -->
<div aria-label="Adjust chart zoom" class="chart-zoom-controls">
<button class="chart-zoom-btn" id="chartZoomOutBtn" title="Zoom out (show more ink range)" type="button">âˆ’</button>
<div aria-hidden="true" class="chart-zoom-divider"></div>
<button class="chart-zoom-btn" id="chartZoomInBtn" title="Zoom in (magnify ink range)" type="button">+</button>
</div>
<div id="statusContainer" class="absolute top-1 right-4 z-10 max-w-xs" style="display: none;" data-status-container>
  <div class="bg-gray-50 rounded-lg px-3 py-2 text-center flex items-center justify-center" style="min-height: 2.5rem;">
    <span id="status" class="text-xs text-gray-600 font-medium transition-opacity duration-500 ease-in-out">&nbsp;</span>
  </div>
</div>
<div class="absolute top-1 left-4 z-10">
  <span id="sessionStatus" class="text-xs text-gray-500">&nbsp;</span>
</div>
</div>
<!-- Cursor tooltip for X,Y coordinates over the graph -->
<div class="hidden absolute z-20 px-1.5 py-0.5 text-xs rounded bg-black text-white pointer-events-none shadow-md" id="chartCursorTooltip"></div>
</div> <!-- Close chartContainer -->
<!-- Draggable Horizontal Divider (chart height) -->
<div aria-label="Resize chart height" aria-orientation="horizontal" class="chart-divider" id="chartDivider" role="separator" title="Drag to resize chart">
<div class="chart-divider-grip"></div>
</div>
</div> <!-- Close chartPanel -->
<!-- Tabbed Tool Area (Bottom: Channels, Lab Tech, Preview) -->
<div class="tool-tabs-container" id="toolTabs">
<!-- Tab Navigation -->
<div class="tab-nav" role="tablist">
<button aria-selected="true" class="tab-btn active" data-tab="channels" role="tab"><span class="tab-icon">ðŸŽ›ï¸</span><span class="tab-title">CHANNELS</span></button>
<button aria-selected="false" class="tab-btn" data-tab="lab" role="tab"><span class="tab-icon">ðŸ’¬</span><span class="tab-title">LAB TECH</span></button>
<button aria-selected="false" class="tab-btn" data-tab="preview" role="tab"><span class="tab-icon">ðŸ“„</span><span class="tab-title">.QUAD PREVIEW</span></button>
</div>
<!-- Tab Content Areas -->
<div class="tab-content-wrapper">
<!-- Channels Tab -->
<div class="tab-content active" data-tab-content="channels" role="tabpanel">
<!-- Quick Enable Chips -->
<div class="disabled-channels-compact mb-3" id="disabledChannelsCompact">
<div class="flex flex-wrap items-center justify-between gap-3">
<div class="disabled-channels-row flex-1 min-w-0" id="disabledChannelsRow">
<!-- Channel chips will be inserted here -->
</div>
<div class="flex items-center gap-2 shrink-0" title="Multiply every channel's End by this factor (100% = no change)">
<label class="text-xs font-medium text-gray-700" for="scaleAllInput">Scale:</label>
<div class="flex items-center gap-1">
<input aria-label="Scale all channels percent" autocomplete="off" class="w-16 m-0 rounded-lg border border-gray-300 px-2 py-1 text-xs text-right focus:outline-none focus:ring-2 focus:ring-blue-500" id="scaleAllInput" max="1000" min="1" step="1" type="number" value="100"/>
<span class="text-xs text-gray-500">%</span>
</div>
</div>
</div>
</div>
<!-- Channel table -->
<div class="overflow-auto">
<table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden border-collapse">
<thead>
<tr class="bg-gray-50 text-gray-700 text-xs">
<th class="text-center p-0" style="width:0;"></th>
<th class="text-left px-1 py-2" style="width: 100px;">Channel</th>
<th class="text-center px-1 py-2" style="width: 250px;">Correction</th>
<th class="text-left px-1 py-2">Status</th>
<th class="text-right pr-0 py-2" style="width:120px;">
                    Percent <span class="font-normal text-gray-500">(0â€“100)</span>
</th>
<th class="text-right pl-0 py-2" style="width:120px;">
                    End <span class="font-normal text-gray-500">(0â€“65,535)</span>
</th>
<th class="text-right pl-0 pr-2 py-2" style="width:150px;">
                    Density <span class="font-normal text-gray-500">(0â€“1)</span>
</th>
</tr>
</thead>
<tbody id="rows">
</tbody>
</table>
</div>
</div>
<!-- Lab Tech Tab -->
<div class="tab-content" data-tab-content="lab" hidden="" role="tabpanel">
<div class="border border-gray-200 rounded-xl overflow-hidden">
<div class="console-header bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700 flex items-center justify-between">
<span><span class="mr-1" id="labTechIcon">ðŸ’¬</span>Lab Tech</span>
<div class="flex items-center gap-3">
<label class="flex items-center gap-1 text-xs text-gray-700 hidden" title="Show assistant status messages in chat">
<input checked="" class="rounded border-gray-300" id="aiShowStatusToggle" type="checkbox"/>
<span>Show assistant status</span>
</label>
<button class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 rounded px-2 py-0.5 font-bold focus:outline-none focus:ring-0" id="clearChatBtn">Clear</button>
</div>
</div>
<div class="font-mono p-2" id="labTechConsole">
<!-- Chat History -->
<div class="overflow-y-auto text-xs leading-4 mb-2" id="chatHistory" style="height:224px;">
<div class="labtech-sample px-2 py-1 rounded mb-2">
<strong>Try this:</strong> "Reduce all ink limits by 20%"<br/>
<strong>or:</strong> "generate a curve with points 0,0 25,20 75,85 100,100"<br/>
<strong>or:</strong> "apply a midtone lift"<br/>
<strong>or:</strong> "delete the key point near 25%"<br/>
<strong>or:</strong> "delete key point 2"
                </div>
</div>
<!-- Resizer for Lab Tech console -->
<div aria-orientation="horizontal" class="h-4 bg-gray-800/40 hover:bg-gray-700/60 cursor-row-resize mb-2 rounded relative" id="labTechResizer" role="separator" title="Drag to resize">
<div class="absolute inset-0 flex items-center justify-center pointer-events-none">
<span class="inline-block w-10 h-[2px] bg-gray-400/80 rounded"></span>
<span class="inline-block w-10 h-[2px] bg-gray-400/80 rounded ml-1"></span>
</div>
</div>
<!-- Bottom input area -->
<div class="flex items-center gap-2">
<input class="flex-1 min-w-0 rounded border px-3 py-1 text-xs focus:outline-none focus:ring-2 placeholder-gray-400" id="aiInputCompact" placeholder="Ask Lab Techâ€¦ (Enter to send)" type="text"/>
<button class="px-2 py-1 text-xs bg-green-600 hover:bg-green-700 text-white rounded font-bold focus:outline-none focus:ring-0" disabled="" id="sendMessageBtnCompact">Send</button>
</div>
</div>
</div>
</div>
<!-- Preview Tab -->
<div class="tab-content" data-tab-content="preview" hidden="" role="tabpanel">
<div class="border border-gray-200 rounded-xl overflow-hidden">
<div class="console-header bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700">ðŸ“ .quad File Preview</div>
<!-- Attached notes input styled like preview -->
<div class="font-mono p-2 border-t" id="previewConsole">
<textarea class="w-full font-mono text-xs p-2 outline-none resize-y border rounded-sm placeholder-gray-400" id="userNotes" placeholder="Notes (saved as # comments in the .quad file)" rows="3"></textarea>
</div>
<pre class="p-2 text-xs leading-none overflow-auto font-mono" id="previewFull" style="max-height:224px;">â€“</pre>
<div aria-orientation="horizontal" class="h-4 bg-gray-200 hover:bg-gray-300 cursor-row-resize relative" id="previewResizer" role="separator" title="Drag to resize">
<div class="absolute inset-0 flex items-center justify-center pointer-events-none">
<span class="inline-block w-10 h-[2px] bg-gray-400 rounded"></span>
<span class="inline-block w-10 h-[2px] bg-gray-400 rounded ml-1"></span>
</div>
</div>
</div>
</div>
</div>
</div> <!-- Close tool-tabs-container -->
</div> <!-- Close main-content-area -->
<!-- Vertical Panel Divider (panel width) -->
<div aria-label="Resize panels" aria-orientation="vertical" class="panel-divider" id="panelDivider" role="separator" title="Drag to resize panels">
<div class="panel-divider-grip"></div>
</div>
<!-- Right Panel: Vertical Tabs (Edit Curve + Global Correction) -->
<div class="right-panel" id="rightPanel">
<!-- Vertical Tab Navigation -->
<div class="vertical-tab-nav" role="tablist">
<div class="tab-btn-vertical-row">
<button aria-selected="true" class="tab-btn-vertical active" data-tab="edit" role="tab">
<span class="tab-icon">âœï¸</span>
<span class="tab-label tab-title flex-1">EDIT CURVE</span>
</button>
<button aria-label="Edit Mode Help" class="tab-btn-vertical-help" id="editModeHelpBtn" title="Edit Mode Help" type="button">?</button>
</div>
<div class="tab-btn-vertical-row">
<button aria-selected="false" class="tab-btn-vertical" data-tab="global" role="tab">
<span class="tab-icon">ðŸŒ</span>
<span class="tab-label tab-title flex-1">GLOBAL CORRECTION</span>
</button>
<button aria-label="Correction vs. Intent" class="tab-btn-vertical-help" id="intentHelpBtn" title="Correction vs. Intent" type="button">?</button>
</div>
</div>
<!-- Vertical Tab Content Area -->
<div class="tab-content-wrapper-vertical">
<!-- Edit Mode Tab (moved from bottom tabs) -->
<div class="tab-content active" data-tab-content="edit" role="tabpanel">
<!-- Edit Mode Toggle + Plot Smoothing (inline) -->
<div class="flex flex-col gap-2 mb-2">
<!-- Edit Mode Toggle -->
<button aria-checked="false" aria-pressed="false" class="text-sm font-bold px-3 py-2 rounded cursor-pointer text-white bg-slate-600 hover:bg-slate-700 border-0" id="editModeToggleBtn" role="switch" title="Toggle edit mode" type="button">
<span id="editModeLabel">âŸ Edit Mode: OFF</span>
</button>
<!-- Plot Smoothing -->
<div class="bg-white border border-gray-200 rounded-xl p-2 flex flex-col gap-2">
<div class="flex items-center gap-2">
<button aria-label="What does plot smoothing change?" class="tooltip-trigger inline-flex h-5 w-5 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Apply a gentle smoothing pass to the computed correction curves. Adjusts both the plotted curve and exported .quad data." type="button">
<span aria-hidden="true">?</span>
</button>
<span class="text-xs font-medium text-gray-800 flex items-center gap-1" id="plotSmoothingPercentLabel">
                    Plot smoothing:
                    <span class="text-xs font-semibold text-gray-900" id="plotSmoothingPercentValue">0% (Ã—1.00)</span>
</span>
</div>
<input aria-describedby="plotSmoothingPercentHelp" aria-labelledby="plotSmoothingPercentLabel" class="w-full accent-blue-600" id="plotSmoothingPercentSlider" max="600" min="0" step="1" type="range" value="0"/>
<span class="sr-only" id="plotSmoothingPercentHelp">Applies a gentle smoothing pass to the correction curve for both chart and export. Higher values broaden the smoothing window.</span>
</div>
</div>
<!-- Edit Curves Panel -->
<div class="bg-white border border-transparent rounded-xl p-0">
<div id="editPanelBody">
<!-- Workflow-based layout (grid for narrow panel) -->
<div class="flex flex-col gap-2">
<!-- WORKFLOW ROW 1: Select Channel + Calculate -->
<div class="grid grid-cols-5 gap-2">
<!-- SELECT CHANNEL (2/5 width) -->
<div class="col-span-2 border border-gray-200 rounded-lg p-2.5">
<span class="text-xs text-gray-700 font-bold block mb-1.5">Select Channel</span>
<div class="flex items-center justify-center">
<button aria-label="Previous channel" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" id="editChannelPrev" title="Previous channel">â—€</button>
<select class="standard-dropdown text-center" id="editChannelSelect" style="width:56px; padding-left:0.25rem; padding-right:0.25rem;"></select>
<button aria-label="Next channel" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" id="editChannelNext" title="Next channel">â–¶</button>
</div>
<span class="text-xs text-gray-500 text-center block mt-2" id="editChannelState"></span>
</div>
<!-- CALCULATE POINTS (3/5 width) -->
<div class="col-span-3 border border-gray-200 rounded-lg p-2.5">
<span class="text-xs text-gray-700 font-bold block mb-1.5 flex items-center gap-1.5">
  <button type="button" class="tooltip-trigger inline-flex h-4 w-4 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-[10px] font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Sets the simplifierâ€™s target error (%) and maximum Smart key points before generating editable points from the current curve.">?</button>
  <span>Calculate</span>
</span>
<label class="text-xs text-gray-700 flex items-center gap-1 mb-2">
<span class="whitespace-nowrap">Error %</span>
<input class="w-full px-2 py-1 text-xs border border-gray-300 rounded" id="editMaxError" max="5" min="0.05" step="0.05" type="number" value="0.15"/>
</label>
<label class="text-xs text-gray-700 flex items-center gap-1 mb-2">
<span class="whitespace-nowrap">Points</span>
<input class="w-full px-2 py-1 text-xs border border-gray-300 rounded" id="editMaxPoints" max="21" min="2" step="1" type="number" value="21"/>
</label>
<button class="w-full px-3 py-1.5 text-xs bg-green-600 hover:bg-green-700 text-white rounded transition-colors font-bold" id="editRecomputeBtn">â†» Recompute</button>
</div>
</div>
<!-- WORKFLOW ROW 2: Select Point + Nudge Point -->
<div class="grid grid-cols-5 gap-2">
<!-- SELECT POINT (2/5 width) -->
<div class="col-span-2 border border-gray-200 rounded-lg p-2.5">
<span class="text-xs text-gray-700 font-bold block mb-1.5">Select Point</span>
<div class="flex items-center justify-center mb-2">
<button class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" id="editPointLeft" title="Previous Key Point">â—€</button>
<span class="text-sm font-bold text-white bg-black min-w-[1.5rem] text-center px-2 py-0.5 rounded is-disabled" id="editPointIndex">â€“</span>
<button class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" id="editPointRight" title="Next Key Point">â–¶</button>
</div>
<input class="w-full text-center px-2 py-1.5 text-xs border border-gray-300 rounded mb-2" id="editXYInput" placeholder="X,Y" title="Edit key point as 'X,Y' percent"/>
<button class="w-full px-3 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded font-bold" id="editDeleteBtn" title="Delete selected key point">âœ–ï¸Ž Delete</button>
</div>
<!-- NUDGE POINT (3/5 width - D-pad layout) -->
<div class="col-span-3 border border-gray-200 rounded-lg p-2.5 relative">
<span class="text-xs text-gray-700 font-bold block mb-1.5">Nudge Point</span>
<div class="flex items-center justify-center">
<!-- D-pad layout -->
<div class="grid grid-cols-3 items-center justify-items-center" style="gap:0;">
<!-- Top row - Y up -->
<div></div>
<button class="px-3 py-1.5 text-sm rounded font-bold nudge-btn" id="editNudgeYUp" title="Nudge Y up">â–³</button>
<div></div>
<!-- Middle row - X left, center space, X right -->
<button class="px-3 py-1.5 text-sm rounded font-bold nudge-btn" id="editNudgeXNeg" title="Nudge X left">â—</button>
<div class="w-8 h-8"></div>
<button class="px-3 py-1.5 text-sm rounded font-bold nudge-btn" id="editNudgeXPos" title="Nudge X right">â–·</button>
<!-- Bottom row - Y down -->
<div></div>
<button class="px-3 py-1.5 text-sm rounded font-bold nudge-btn" id="editNudgeYDown" title="Nudge Y down">â–½</button>
<div></div>
 </div>
 </div>
 <div class="text-xs text-gray-500 text-center mt-2 hidden" id="editDisabledHint">Channel is disabled (End=0). Enable in Channels to edit.</div>
 </div>
 </div>

 <!-- WORKFLOW ROW 3: Bell Apex Shift -->
 <div class="border border-gray-200 rounded-lg p-2.5 hidden" id="editBellShiftContainer">
   <div class="flex items-center justify-between gap-3">
     <div class="flex items-center gap-1.5">
       <button type="button" class="tooltip-trigger inline-flex h-4 w-4 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-[10px] font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Shift bell-shaped channels horizontally without reordering Smart points. Use the Â± buttons or type an input percent.">?</button>
       <span class="text-xs text-gray-700 font-bold uppercase tracking-wide">Bell Apex</span>
     </div>
     <div class="flex items-center gap-2">
       <button type="button" class="px-3 py-1 text-xs font-semibold border border-gray-300 rounded bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" data-bell-shift-nudge="dec" id="editBellShiftDec" aria-label="Shift bell apex left">âˆ’</button>
       <input type="number" step="0.1" min="0" max="100" value="" class="w-20 rounded border border-gray-300 px-2 py-1 text-right text-xs font-semibold focus:border-blue-500 focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" id="editBellShiftInput" aria-label="Bell apex input percent">
       <button type="button" class="px-3 py-1 text-xs font-semibold border border-gray-300 rounded bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" data-bell-shift-nudge="inc" id="editBellShiftInc" aria-label="Shift bell apex right">+</button>
     </div>
   </div>
 </div>

  <div class="border border-gray-200 rounded-lg p-2.5 hidden" id="editBellWidthContainer">
    <div class="flex items-center justify-between gap-3">
      <div class="flex items-center gap-1.5">
        <button type="button" class="tooltip-trigger inline-flex h-4 w-4 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-[10px] font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Adjust left/right width to widen or tighten the bell without moving its apex. Values are percents of the original span; linked mode nudges both sides together.">?</button>
        <span class="text-xs text-gray-700 font-bold uppercase tracking-wide">Bell Width</span>
      </div>
      <div class="flex items-center gap-2">
        <button type="button" class="px-2 py-0.5 text-[11px] font-semibold rounded border border-gray-300 bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 text-gray-600 flex items-center gap-1 disabled:opacity-40 disabled:cursor-not-allowed" id="bellWidthLinkToggle" aria-pressed="true" data-tooltip="Link or unlink left/right width edits.">
          <span class="text-base leading-none" aria-hidden="true">â›“</span>
          <span>Linked</span>
        </button>
        <button type="button" class="px-2 py-0.5 text-[11px] font-semibold text-gray-600 border border-gray-300 rounded bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" id="bellWidthResetBtn">Reset</button>
      </div>
    </div>
    <div class="mt-2 flex flex-col gap-2">
      <div class="flex items-center justify-between gap-2">
        <span class="text-[11px] font-semibold text-gray-600 uppercase tracking-wide">Left</span>
        <div class="flex items-center gap-1.5">
          <button type="button" class="px-2 py-0.5 text-xs font-semibold border border-gray-300 rounded bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" data-bell-width-nudge="left-dec" aria-label="Decrease left width" id="bellWidthLeftDec">âˆ’</button>
          <input type="text" inputmode="decimal" autocomplete="off" pattern="[0-9]*" value="100" class="w-20 rounded border border-gray-300 px-2 py-1 text-right text-xs font-semibold focus:border-blue-500 focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" id="bellWidthLeftInput" aria-label="Left bell width percent">
          <button type="button" class="px-2 py-0.5 text-xs font-semibold border border-gray-300 rounded bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" data-bell-width-nudge="left-inc" aria-label="Increase left width" id="bellWidthLeftInc">+</button>
        </div>
      </div>
      <div class="flex items-center justify-between gap-2">
        <span class="text-[11px] font-semibold text-gray-600 uppercase tracking-wide">Right</span>
        <div class="flex items-center gap-1.5">
          <button type="button" class="px-2 py-0.5 text-xs font-semibold border border-gray-300 rounded bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" data-bell-width-nudge="right-dec" aria-label="Decrease right width" id="bellWidthRightDec">âˆ’</button>
          <input type="text" inputmode="decimal" autocomplete="off" pattern="[0-9]*" value="100" class="w-20 rounded border border-gray-300 px-2 py-1 text-right text-xs font-semibold focus:border-blue-500 focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" id="bellWidthRightInput" aria-label="Right bell width percent">
          <button type="button" class="px-2 py-0.5 text-xs font-semibold border border-gray-300 rounded bg-white hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-40 disabled:cursor-not-allowed" data-bell-width-nudge="right-inc" aria-label="Increase right width" id="bellWidthRightInc">+</button>
        </div>
      </div>
    </div>
  </div>

 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
<!-- Global Correction Tab (moved from bottom tabs) -->
<div class="tab-content" data-tab-content="global" hidden="" role="tabpanel">
<div class="space-y-4" data-linearization-column="">
<!-- Global Linearization -->
<div class="bg-white border border-gray-200 rounded-xl p-2">
<div class="space-y-3">
<div class="flex items-center gap-2">
<span class="text-xs font-bold text-gray-700 uppercase tracking-wide">On / Off</span>
<label class="slider-toggle" title="Enable/disable global correction">
<input disabled="" id="globalLinearizationToggle" type="checkbox"/>
<span class="slider"></span>
</label>
</div>
        <div class="flex flex-col gap-2 items-center">
          <button class="px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold whitespace-nowrap inline-flex items-center justify-center cursor-pointer" id="globalLinearizationBtn" type="button" data-tooltip="Load LUT.cube, LABdata.txt, .ti3, or .acv curve files">Load Data File</button>
          <input accept=".cube,.txt,.cgats,.cgats17,.ti3,.acv" class="hidden" id="linearizationFile" type="file"/>
          <p class="text-[0.625rem] text-gray-500 text-center" id="globalLinearizationHint">LUT (.cube), LAB data (.txt), CGATS (.ti3), or curves (.acv)</p>
        </div>
<div class="flex flex-col gap-2">
<div class="flex gap-2">
<button class="flex-1 px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold whitespace-nowrap inline-flex items-center justify-center" id="manualLstarBtn">Enter L* Values</button>
<button class="flex-1 px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold whitespace-nowrap inline-flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed disabled:pointer-events-none" disabled="" id="revertGlobalToMeasurementBtn" title="Revert to measurement source (global)">â†º Revert</button>
</div>
</div>
<div class="text-xs text-gray-600 hidden" id="globalLinearizationInfo">
<span class="font-medium" id="globalLinearizationFilename"></span>
<span class="text-gray-500" id="globalLinearizationDetails"></span>
<span class="ml-2 inline-block hidden" id="deltaSummary"></span>
<span class="ml-3 inline-flex items-center gap-1 hidden">
<label class="text-gray-600" for="perChannelDeltaSelect">Channel change:</label>
<select class="text-xs border border-gray-300 rounded px-1 py-0.5" id="perChannelDeltaSelect"></select>
<span class="ml-1" id="perChannelDeltaSummary"></span>
</span>
</div>
<!-- Auto endpoint rolloff controls -->
<div aria-hidden="true" class="flex items-center gap-3 text-xs text-gray-600 hidden">
<span class="font-bold" title="Detect early plateau at the ends and apply a soft shoulder/toe so the curve reaches the ink limit exactly at 100% without flattening.">Auto limits</span>
<label class="inline-flex items-center gap-1" for="autoWhiteLimitToggle" title="Enable automatic white-shoulder rolloff near paper white.">
<input class="h-3 w-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="autoWhiteLimitToggle" type="checkbox"/>
<span>White</span>
</label>
<label class="inline-flex items-center gap-1" for="autoBlackLimitToggle" title="Enable automatic black-toe rolloff near maximum ink.">
<input class="h-3 w-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="autoBlackLimitToggle" type="checkbox"/>
<span>Black</span>
</label>
</div>
<div>
<label class="text-xs text-gray-600 font-bold block mb-1" for="contrastIntentSelect">Intent</label>
<select class="standard-dropdown text-xs w-full mb-2" id="contrastIntentSelect">
<!-- Preset options will be populated dynamically from CONTRAST_INTENT_PRESETS -->
<option value="custom">Custom (saved)</option>
<option value="enter_custom">Enter Customâ€¦</option>
</select>
<button class="w-full px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded transition-colors font-bold disabled:bg-gray-200 disabled:text-gray-400 disabled:opacity-60 disabled:cursor-not-allowed dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-100 dark:disabled:bg-slate-600 dark:disabled:text-slate-400 dark:disabled:opacity-60" disabled="" id="applyIntentToQuadBtn" title="Load a .quad (no LAB data) to enable intent remap">Apply Intent</button>
</div>
<!-- LAB Smoothing -->
<div class="bg-white border border-gray-200 rounded-xl p-2">
<div class="flex items-center gap-2 mb-2">
<button aria-label="What does LAB smoothing change?" class="tooltip-trigger inline-flex h-5 w-5 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Adjust the Gaussian kernel width when rebuilding LAB/manual measurements. Higher values smooth noisy data; lower values follow the raw curve." type="button">
<span aria-hidden="true">?</span>
</button>
<span class="text-xs font-medium text-gray-800 flex items-center gap-1" id="labSmoothingPercentLabel">
                        LAB smoothing:
                        <span class="text-xs font-semibold text-gray-900" id="labSmoothingPercentValue">0% (Ã—1.00)</span>
</span>
</div>
<input aria-describedby="labSmoothingPercentHelp" aria-labelledby="labSmoothingPercentLabel" class="w-full accent-blue-600 mb-2" id="labSmoothingPercentSlider" max="600" min="0" step="1" type="range" value="0"/>
<span class="sr-only" id="labSmoothingPercentHelp">Applies a Gaussian-widened smoothing pass from 0 to 300 percent. The default 0 percent keeps measured data untouched; increase only when you need extra noise reduction.</span>
</div>
<!-- Correction Gain -->
<div class="bg-white border border-gray-200 rounded-xl p-2">
<div class="flex items-center gap-2 mb-2">
<button aria-label="What does correction gain control?" class="tooltip-trigger inline-flex h-5 w-5 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Blend between the uncorrected identity curve (0%) and the full measured correction (100%). All previews and exports respect the current mix." type="button">
<span aria-hidden="true">?</span>
</button>
<span class="text-xs font-medium text-gray-800 flex items-center gap-1" id="correctionGainLabel">
                        Correction gain:
                        <input aria-label="Correction gain percent" class="w-16 rounded border border-gray-300 px-2 py-1 text-xs text-gray-900 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 text-right" id="correctionGainInput" max="100" min="0" step="1" type="number" value="100"/>
<span class="text-xs font-semibold text-gray-500">%</span>
</span>
</div>
<input aria-describedby="correctionGainHelp" aria-labelledby="correctionGainLabel" class="w-full accent-blue-600 mb-2" id="correctionGainSlider" max="100" min="0" step="1" type="range" value="100"/>
<span class="sr-only" id="correctionGainHelp">Blend between no correction (0 percent) and the full measured correction (100 percent). The chart, spot markers, and exported files all follow the current setting.</span>
</div>
<!-- LAB Density Mode -->
<div class="flex items-start gap-2">
<button aria-label="What does log-density normalization do?" class="tooltip-trigger mt-0.5 inline-flex h-5 w-5 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Convert LAB measurements to optical density before computing corrections. Recommended for negatives or through-light workflows." type="button">
<span aria-hidden="true">?</span>
</button>
<label aria-describedby="labDensityModeHelp" class="flex items-center gap-2 text-xs font-medium text-gray-800" for="labDensityModeToggle">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="labDensityModeToggle" type="checkbox"/>
<span>Use log-density for LAB / Manual</span>
</label>
</div>
<span class="sr-only" id="labDensityModeHelp">Converts LAB measurements to optical density before computing corrections; recommended for negatives or through-light workflows. Leave unchecked for direct positive prints.</span>
<!-- Auto-raise Ink Limits -->
<div class="flex items-start gap-2">
<button aria-label="What does the auto-raise ink limit toggle do?" class="tooltip-trigger mt-0.5 inline-flex h-5 w-5 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Automatically raise a channel's ink limit when an imported correction needs more headroom. Locked channels stay capped and are logged in the composite debug summary." type="button">
<span aria-hidden="true">?</span>
</button>
<label aria-describedby="autoRaiseInkHelp" class="flex items-center gap-2 text-xs font-medium text-gray-800" for="autoRaiseInkToggle">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="autoRaiseInkToggle" type="checkbox"/>
<span>Auto-raise ink limits after import</span>
</label>
</div>
<span class="sr-only" id="autoRaiseInkHelp">When enabled, quadGEN lifts channel ink limits automatically if a loaded correction exceeds the current ceiling and notes any locked channels that prevent the raise.</span>
</div>
</div>

<div id="lstarModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
  <div class="bg-white rounded-lg max-w-3xl w-full mx-4 max-h-[90vh] flex flex-col">
    <div class="p-6 pb-4 flex-shrink-0">
      <div class="flex justify-between items-center mb-2">
        <h3 class="text-lg font-semibold">Manual Luminosity (L*) Entry</h3>
        <button id="closeLstarModal" class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
      </div>
      <div class="hidden text-xs italic text-gray-700 mb-3 p-2 px-3 bg-gray-50 border border-gray-200 rounded">The L* component of the Lab color system represents perceived lightness, ranging from 0 (black) to 100 (white). Equal steps in L* correspond approximately to equal perceptual differences in lightâ€“dark appearance.</div>
      <div class="hidden mb-4 text-sm text-gray-600">
        <ul class="list-disc list-inside space-y-1">
          <li>Measure and enter L* values for each patch (e.g., using a device like the <a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a> or <a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Nix Spectro L</a>).</li>
          <li>If your chart uses even steps (0, 5, 10 â€¦ 100%), leave <span class="font-medium">Patch %</span> as-is.</li>
          <li>Edit <span class="font-medium">Patch %</span> for irregular spacing (more steps in the highlights / shadows).</li>
          <li>Target result is linear (L* 100 â†’ 0) and linked to Patch %.</li>
          <li>Inspired by & compatible with data from the <a href="https://clayharmonblog.com/wedgie.html" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">Wedgie tool</a> by Clay Harmon.</li>
          <li>A good resource for target images is <a href="https://clayharmonblog.com/downloads" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">clayharmonblog.com/downloads</a>.</li>
        </ul>
      </div>
      <div class="hidden flex items-center justify-center gap-6 mb-4 p-3 bg-gray-50 rounded border">
        <div class="flex gap-2">
          <button id="addLstarInputHeader" class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded font-bold">+ Add</button>
          <button id="removeLstarInputHeader" class="px-3 py-1 text-sm bg-red-100 hover:bg-red-200 text-red-700 rounded font-bold">- Remove</button>
        </div>
        <div class="flex items-center gap-2">
          <label class="text-sm text-gray-600">Patches:</label>
          <input type="number" id="lstarCountInputHeader" min="5" max="50" value="5" class="w-16 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500">
        </div>
      </div>
    </div>
    <div class="flex-1 overflow-y-auto overflow-x-auto px-6">
      <div class="text-xs italic text-gray-700 mb-3 p-2 px-3 bg-gray-50 border border-gray-200 rounded">The L* component of the Lab color system represents perceived lightness, ranging from 0 (black) to 100 (white). Equal steps in L* correspond approximately to equal perceptual differences in lightâ€“dark appearance.</div>
      <div class="mb-4 text-sm text-gray-600">
        <ul class="list-disc list-inside space-y-1">
          <li>Measure and enter L* values for each patch (e.g., using a device like the <a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a> or <a href="https://amzn.to/4msSLOv" target="_blank" rel="noopener">Nix Spectro L</a>).</li>
          <li>If your chart uses even steps (0, 5, 10 â€¦ 100%), leave <span class="font-medium">Patch %</span> as-is.</li>
          <li>Edit <span class="font-medium">Patch %</span> for irregular spacing (more steps in the highlights / shadows).</li>
          <li>Target result is linear (L* 100 â†’ 0) and linked to Patch %.</li>
          <li>Inspired by & compatible with data from the <a href="https://clayharmonblog.com/wedgie.html" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">Wedgie tool</a> by Clay Harmon.</li>
          <li>A good resource for target images is <a href="https://clayharmonblog.com/downloads" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">clayharmonblog.com/downloads</a>.</li>
        </ul>
      </div>
      <div class="flex items-center justify-center gap-6 mb-4 p-3 bg-gray-50 rounded border">
        <div class="flex gap-2">
          <button id="addLstarInput" class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded font-bold">+ Add</button>
          <button id="removeLstarInput" class="px-3 py-1 text-sm bg-red-100 hover:bg-red-200 text-red-700 rounded font-bold">- Remove</button>
        </div>
        <div class="flex items-center gap-2">
          <label class="text-sm text-gray-600">Patches:</label>
          <input type="number" id="lstarCountInput" min="5" max="50" value="5" class="w-16 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500">
        </div>
      </div>
      <table class="w-auto mx-auto text-sm border border-gray-200 rounded overflow-hidden">
        <thead class="bg-gray-50 sticky top-0 z-10">
          <tr>
            <th class="px-2 py-2 w-8 text-center">#</th>
            <th class="px-2 py-2 w-24 text-center">Patch %</th>
            <th class="px-2 py-2 w-24 text-center">Target / Measured</th>
            <th class="px-2 py-2 w-24 text-center">L* (0â€“100)</th>
          </tr>
        </thead>
        <tbody id="lstarInputs" class="align-middle"></tbody>
      </table>
      <div id="lstarValidation" class="text-sm text-red-600 mt-3 hidden"></div>
    </div>
    <div class="p-6 pt-4 flex-shrink-0 border-t border-gray-200">
      <div class="flex justify-end gap-3">
        <button id="saveLstarTxt" class="px-4 py-2 bg-slate-600 hover:bg-slate-700 text-white rounded" title="Download entered Patch % and L* as a .txt file">Save as .txt</button>
        <button id="cancelLstar" class="px-4 py-2 text-gray-600 hover:text-gray-800 bg-gray-100 hover:bg-gray-200 rounded font-bold">Cancel</button>
        <button id="generateFromLstar" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded">Generate Correction</button>
      </div>
    </div>
  </div>
</div>
</div>
</div>
</div>
</div>
</div> <!-- Close app-layout -->
<!-- Help Popup -->
<div class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4" id="helpPopup">
<div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
<button aria-label="Close" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" id="closeHelpBtn">
<svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24">
<path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</button>
<div class="flex items-center gap-3 mb-2">
<svg aria-hidden="true" height="32" role="img" viewbox="0 0 160 160" width="32" xmlns="http://www.w3.org/2000/svg">
<path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-linecap="round" stroke-width="8"></path>
<rect fill="#00B5E2" height="40" rx="6" ry="6" width="20" x="20" y="90"></rect>
<rect fill="#FF2A8A" height="60" rx="6" ry="6" width="20" x="52" y="70"></rect>
<rect fill="#FFD400" height="80" rx="6" ry="6" width="20" x="84" y="50"></rect>
<rect fill="#1A1A1A" height="110" rx="6" ry="6" width="20" x="116" y="22"></rect>
<path d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18" fill="none" stroke="#1A1A1A" stroke-linecap="round" stroke-linejoin="round" stroke-width="8"></path>
<circle cx="30" cy="88" fill="white" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
<circle cx="62" cy="68" fill="white" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
<circle cx="94" cy="48" fill="white" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
<circle cx="126" cy="18" fill="white" r="6" stroke="#1A1A1A" stroke-width="2"></circle>
</svg>
<h2 class="text-xl font-bold">quadGEN <span class="text-gray-400 text-base" id="helpAppVersion"></span></h2>
</div>
<div class="mb-2 border-b border-gray-200 flex items-center gap-2" id="helpTabs">
<button class="px-3 py-1 text-sm font-bold text-gray-800 border-b-2 border-slate-700" id="helpTabReadme">README</button>
<button class="px-3 py-1 text-sm font-bold text-gray-500 hover:text-gray-700 border-b-2 border-transparent" id="helpTabGlossary">GLOSSARY</button>
<button class="px-3 py-1 text-sm font-bold text-gray-500 hover:text-gray-700 border-b-2 border-transparent" id="helpTabWorkflow">DETAILED WORKFLOW</button>
<button class="px-3 py-1 text-sm font-bold text-gray-500 hover:text-gray-700 border-b-2 border-transparent ml-auto" id="helpTabHistory">VERSION HISTORY</button>
</div>
<div class="text-sm text-gray-700 space-y-4 max-h-[70vh] overflow-y-auto" id="helpContent"></div>
</div>
</div>
<!-- Options Modal -->
<div aria-labelledby="optionsModalTitle" aria-modal="true" class="fixed inset-0 bg-black bg-opacity-30 hidden z-50 flex items-start justify-center md:justify-end px-4 py-8 md:py-16" id="optionsModal" role="dialog">
<div class="bg-white border border-gray-200 rounded-xl shadow-2xl w-full max-w-[420px] max-h-[90vh] flex flex-col" data-options-panel="">
<div class="px-4 py-3 border-b border-gray-200 flex items-center gap-3">
<h2 class="text-sm font-semibold flex items-center gap-2 text-gray-900" id="optionsModalTitle">
<span aria-hidden="true">âš™ï¸</span>
<span>Options</span>
</h2>
</div>
<div class="flex-1 overflow-y-auto px-4 py-3 text-sm text-gray-700 space-y-3" id="optionsContent">
<div class="border border-gray-200 rounded-lg p-3 bg-gray-50 space-y-3">
<div class="flex items-start gap-3 pt-1">
<button aria-label="What does curve point dragging change?" class="tooltip-trigger mt-0.5 inline-flex h-6 w-6 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Let Edit Mode Smart key points be dragged directly on the chart. Requires seeded Smart curves." type="button">
<span aria-hidden="true">?</span>
</button>
<label aria-describedby="smartPointDragHelp" class="flex items-center gap-2 text-sm font-medium text-gray-800" for="smartPointDragToggle">
<input checked="" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="smartPointDragToggle" type="checkbox"/>
<span>Enable curve point dragging</span>
</label>
</div>
<span class="sr-only" id="smartPointDragHelp">Enable to drag Smart key points directly on the Edit Mode chart. Experimental: only affects channels with Smart curves and may be disabled for troubleshooting.</span>
<div class="flex items-start gap-3 pt-1">
<button aria-label="What does the correction overlay do?" class="tooltip-trigger mt-0.5 inline-flex h-6 w-6 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Show the dashed global correction target overlay on the chart for quick visual comparisons." type="button">
<span aria-hidden="true">?</span>
</button>
<label aria-describedby="correctionOverlayHelp" class="flex items-center gap-2 text-sm font-medium text-gray-800" for="correctionOverlayToggle">
<input checked="" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="correctionOverlayToggle" type="checkbox"/>
<span>Show correction target overlay</span>
</label>
</div>
<span class="sr-only" id="correctionOverlayHelp">Displays the dashed global correction target overlay on the chart when a correction dataset is loaded.</span>
<div class="flex items-start gap-3 pt-1">
<button aria-label="What do measurement spot markers show?" class="tooltip-trigger mt-0.5 inline-flex h-6 w-6 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Mark each LAB measurement directly on the chart. Green checks show patches within tolerance; arrows call out where to darken or lighten." type="button">
<span aria-hidden="true">?</span>
</button>
<label aria-describedby="labSpotMarkersHelp" class="flex items-center gap-2 text-sm font-medium text-gray-800" for="labSpotMarkersToggle">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" disabled="" id="labSpotMarkersToggle" type="checkbox"/>
<span>Show measurement spot markers</span>
</label>
</div>
<span class="sr-only" id="labSpotMarkersHelp">Displays an overlay of LAB measurement points with pass/fail markers once LAB data is loaded. Toggle is enabled after a measurement dataset is active.</span>
<div class="flex items-start gap-3 pt-1">
<button aria-label="What does the light blocking overlay do?" class="tooltip-trigger mt-0.5 inline-flex h-6 w-6 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Show the combined density-weighted blocking curve so you can gauge where the print transitions to the next ink set." type="button">
<span aria-hidden="true">?</span>
</button>
<label aria-describedby="lightBlockingOverlayHelp" class="flex items-center gap-2 text-sm font-medium text-gray-800" for="lightBlockingOverlayToggle">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="lightBlockingOverlayToggle" type="checkbox"/>
<span>Show light blocking overlay</span>
</label>
</div>
<span class="sr-only" id="lightBlockingOverlayHelp">Displays the density-weighted blocking curve on the chart, updating as channels change to illustrate light-blocking coverage.</span>
<!-- Reference .quad Loader -->
<div class="mt-3 ml-8">
<input accept=".quad" class="hidden" id="referenceQuadFile" type="file"/>
<button aria-label="Load a reference .quad file (non-editable overlay)." class="px-3 py-1.5 text-xs bg-violet-600 hover:bg-violet-700 text-white rounded transition-colors font-bold" data-default-label="â†’ Load Reference" id="loadReferenceQuadBtn" title="Load a reference .quad file (non-editable overlay).">
              â†’ Load Reference
            </button>
</div>
<div class="flex items-start gap-3 pt-3">
<button aria-label="What does the ink load overlay show?" class="tooltip-trigger mt-0.5 inline-flex h-6 w-6 flex-shrink-0 items-center justify-center rounded-full border border-gray-200 text-xs font-semibold text-gray-400 hover:text-gray-600 hover:border-gray-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500" data-tooltip="Plot the summed ink percentage across every enabled channel. Helps spot input levels where total coverage exceeds your warning threshold." type="button">
<span aria-hidden="true">?</span>
</button>
<div aria-describedby="inkLoadOverlayHelp" class="flex flex-col gap-2">
<label class="flex items-center gap-2 text-sm font-medium text-gray-800" for="inkLoadOverlayToggle">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="inkLoadOverlayToggle" type="checkbox"/>
<span>Show cumulative ink load overlay</span>
</label>
<div class="flex items-center gap-2 ml-7 text-xs text-gray-600">
<label class="font-medium text-gray-700" for="inkLoadThresholdInput">Warning threshold (%)</label>
<input class="h-7 w-20 rounded border border-gray-300 px-2 text-sm focus:ring-blue-500 focus:border-blue-500" id="inkLoadThresholdInput" max="400" min="10" step="1" type="number" value="25"/>
</div>
</div>
</div>
<span class="sr-only" id="inkLoadOverlayHelp">Displays a combined ink-percentage curve for all enabled channels and flags values above the configured warning threshold.</span>
</div>
</div>
<div class="px-4 py-3 border-t border-gray-200 flex justify-end">
<button class="px-3 py-1.5 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" id="closeOptionsBtn">Close</button>
</div>
</div>
</div>
<!-- Global Correction Help Popup -->
<div id="globalCorrectionHelpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
<div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
<button aria-label="Close" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" id="closeGlobalCorrectionHelpBtn">
<svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24">
<path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</button>
<h2 class="text-xl font-bold mb-4">Global Correction Help</h2>
<div class="text-sm text-gray-700 space-y-6 max-h-[70vh] overflow-y-auto">
<div>
<p class="font-medium text-lg mb-2">Overview</p>
<p class="text-sm text-gray-600">Global corrections can be applied in two ways: directly via a curve/LUT file, or by computing a linearization from L* measurements. Both approaches update all channels uniformly.</p>
</div>
<div>
<p class="font-medium text-lg mb-2">Working Assumptions</p>
<ul class="list-disc list-inside text-sm text-gray-600">
<li>Positive space: X=0% is white â†’ X=100% is black; Y=0% = no ink (white), Y=100% = max ink (black).</li>
<li>Endpoints anchored: Keep 0â†’0 and 100â†’100 fixed unless you have a specific reason to change them.</li>
<li>Monotonic, smooth curves: Avoid kinks or flat spots, especially near endpoints.</li>
<li>Digital negatives: Work in positive space; invert your image in the editor when making a digital negative.</li>
</ul>
</div>
<div>
<p class="text-xs text-gray-700 font-semibold">Applies Directly â†’</p>
<ul class="list-disc list-inside text-xs text-gray-600 mb-1">
<li>Photoshop Curves (.acv): Curve presets.</li>
<li>LUT (.cube): 1D or 3D LUT.</li>
</ul>
</div>
<div>
<p class="text-xs text-gray-700 font-semibold">Calculates Linearization â†•</p>
<ul class="list-disc list-inside text-xs text-gray-600 mb-1">
<li>LAB Data (.txt): L* measurements.</li>
<li>Manual L* Entry: L* measurements.</li>
</ul>
</div>
<div>
<p class="font-medium text-lg mb-2">Tonal Zones</p>
<ul class="list-disc list-inside text-sm text-gray-600">
<li><span class="font-medium">Highlights</span>: 0â€“25% (X)</li>
<li><span class="font-medium">Midtones</span>: 25â€“75% (X)</li>
<li><span class="font-medium">Shadows</span>: 75â€“100% (X)</li>
</ul>
<div class="text-xs text-gray-600 mt-2">Examples: Lighten shadows â†’ reduce output in 75â€“95% and taper to 0 change by 100%. Lighten highlights â†’ reduce output in 5â€“25% and taper to 0 by 0%.</div>
</div>
<div>
<p class="font-medium text-lg mb-2">Workflow Summary</p>
<ol class="list-decimal list-inside space-y-1 ml-2 text-sm">
<li>Choose your printer and set ink limits for each channel.</li>
<li>Export a test .quad and print a 0â€“100% step wedge.</li>
<li>Measure the positive result (inkjet print or altâ€‘process print).</li>
<li>Load data into quadGEN: LAB (.txt), EDN LUT (.cube/.acv), or Manual L*.</li>
<li>Review the graph and adjust channel limits if needed.</li>
<li>Export the corrected .quad and reprint to verify.</li>
</ol>
<div class="text-xs text-gray-600 ml-2 mt-2">Tip for digital negatives: work in positive space, then invert your image in your editor before printing the negative.</div>
</div>
<div>
<p class="font-medium text-lg mb-2">Auto endpoint rolloff</p>
<p class="text-sm text-gray-600 mb-1">Temporarily disabled while we retune the shoulder/toe detector. Existing projects keep previously baked knees, but quadGEN will not generate new auto rolloff adjustments until the retune ships.</p>
<div class="text-xs text-gray-600 mt-2">Historical behavior (for reference only): the black limit added a soft shoulder near End, and the white limit added a soft toe near 0. Those localized knees will return once the detector is dialed back in.</div>
</div>
<div>
<p class="font-medium text-lg mb-2">Sample Data</p>
<div class="flex gap-2">
<div class="flex-1">
<button class="w-full px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded transition-colors font-bold" id="helpLoadSampleLab">Load LAB-Data-sample.txt</button>
<a class="block text-center text-xs text-blue-600 hover:text-blue-800 mt-1" href="#" id="helpDownloadSampleLab">â†“ Download LAB-Data-sample.txt</a>
</div>
<div class="flex-1">
<button class="w-full px-2 py-1 text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 rounded transition-colors font-bold" id="helpLoadSampleCube">Load Sample LUT.cube</button>
<a class="block text-center text-xs text-purple-600 hover:text-purple-800 mt-1" href="#" id="helpDownloadSampleCube">â†“ Download LUT_sample.cube</a>
</div>
</div>
</div>
</div>
</div>
</div>
<!-- Intent Help Popup (Correction vs Intent) -->
<div class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4" id="intentHelpPopup">
<div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
<button aria-label="Close" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" id="closeIntentHelpBtn">
<svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24">
<path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</button>
<h2 class="text-xl font-bold mb-4">Global Correction &amp; Intent</h2>
<div class="text-sm text-gray-700 space-y-6 max-h-[70vh] overflow-y-auto" id="intentHelpContent"></div>
</div>
</div>
<!-- Channel Builder Modal -->
<div id="channelBuilderModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50 p-4">
  <div class="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] flex flex-col">
    <!-- Header -->
    <div class="p-4 border-b border-gray-200 flex-shrink-0">
      <div class="flex justify-between items-center">
        <h3 class="text-lg font-semibold">Channel Builder</h3>
        <button id="closeChannelBuilderModal" class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
      </div>
      <p class="text-sm text-gray-500 mt-1">Build multi-ink quad files by measuring secondary channel L* contributions</p>
    </div>
    <!-- Tabs -->
    <div class="border-b border-gray-200 flex-shrink-0 px-4">
      <div class="flex gap-1">
        <button id="channelBuilderTabK" class="px-3 py-2 text-sm font-medium border-b-2 border-green-600 text-gray-800">1. Reference K</button>
        <button id="channelBuilderTabAdd" class="px-3 py-2 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700">2. Add Channels</button>
        <button id="channelBuilderTabPreview" class="px-3 py-2 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700">3. Preview</button>
        <button id="channelBuilderTabApply" class="px-3 py-2 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700">4. Apply</button>
      </div>
    </div>
    <!-- Content -->
    <div class="flex-1 overflow-y-auto p-4">
      <!-- Panel 1: Reference K -->
      <div id="channelBuilderPanelK" class="space-y-4">
        <div class="text-sm text-gray-600 mb-4">
          Set up your reference K channel. Print a linear ramp at your chosen ink limit, measure L* values, then enter them below. This is the baseline for computing secondary channel positions.
        </div>
        <div id="cbKStatus"></div>
        <div class="space-y-3">
          <!-- K Ink Limit -->
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">K Ink Limit Used (%)</label>
            <input type="number" id="cbKInkLimit" value="33" min="1" max="100" class="w-32 px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500">
            <span class="text-xs text-gray-500 ml-2">Ink limit used for your K test print</span>
          </div>
          <div class="text-sm text-gray-500">Enter K channel L* measurements:</div>

          <!-- Entry mode toggle -->
          <div class="flex gap-1 border-b border-gray-200 pb-2">
            <button id="cbKEntryModePaste" class="px-3 py-1 text-xs font-medium rounded-t border-b-2 border-green-600 text-gray-800 bg-white">Paste</button>
            <button id="cbKEntryModeManual" class="px-3 py-1 text-xs font-medium rounded-t border-b-2 border-transparent text-gray-500 hover:text-gray-700">Row Entry</button>
          </div>

          <!-- Paste mode (default) -->
          <div id="cbKEntryPaste">
            <textarea id="cbKMeasurementsInput" class="w-full h-32 px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500" placeholder="Enter L* measurements (one per line):
0, 95.2
10, 87.3
20, 78.5
...
100, 12.1"></textarea>
          </div>

          <!-- Row entry mode (hidden by default) -->
          <div id="cbKEntryManual" class="hidden">
            <div class="flex items-center gap-2 mb-2">
              <button id="cbKRemoveRow" class="w-6 h-6 flex items-center justify-center bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-sm font-bold">-</button>
              <span class="text-xs text-gray-600"><span id="cbKRowCount">7</span> points</span>
              <button id="cbKAddRow" class="w-6 h-6 flex items-center justify-center bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-sm font-bold">+</button>
            </div>
            <div class="max-h-48 overflow-y-auto border border-gray-200 rounded">
              <table class="w-full text-sm">
                <thead class="bg-gray-50 sticky top-0">
                  <tr>
                    <th class="px-1 py-1 w-8 text-left text-xs font-medium text-gray-500">#</th>
                    <th class="px-1 py-1 text-left text-xs font-medium text-gray-500">Patch %</th>
                    <th class="px-1 py-1 text-center text-xs font-medium text-gray-500">Preview</th>
                    <th class="px-1 py-1 text-left text-xs font-medium text-gray-500">L*</th>
                  </tr>
                </thead>
                <tbody id="cbKEntryRows"></tbody>
              </table>
            </div>
            <div id="cbKValidation" class="text-xs text-red-600 mt-2 hidden"></div>
          </div>

          <button id="cbParseKMeasurements" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded text-sm">
            Set Reference K
          </button>
          <div class="pt-3 border-t border-gray-200">
            <div class="text-xs text-gray-500 mb-2">Or import from existing quad:</div>
            <button id="cbLoadKFromQuad" class="px-3 py-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-xs">
              Import K from Current Quad
            </button>
          </div>
        </div>
      </div>
      <!-- Panel 2: Add Channels -->
      <div id="channelBuilderPanelAdd" class="hidden space-y-4">
        <div class="text-sm text-gray-600 mb-4">
          Add secondary channels by entering their L* measurements.
        </div>
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Channel</label>
            <select id="cbChannelSelect" class="w-full px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500">
              <option value="C">C</option>
              <option value="LK">LK</option>
              <option value="LLK">LLK</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Ink Limit Used (%)</label>
            <input type="number" id="cbInkLimit" value="70" min="10" max="100" class="w-full px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500">
          </div>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">L* Measurements</label>

          <!-- Entry mode toggle -->
          <div class="flex gap-1 border-b border-gray-200 pb-2 mb-2">
            <button id="cbChEntryModePaste" class="px-3 py-1 text-xs font-medium rounded-t border-b-2 border-green-600 text-gray-800 bg-white">Paste</button>
            <button id="cbChEntryModeManual" class="px-3 py-1 text-xs font-medium rounded-t border-b-2 border-transparent text-gray-500 hover:text-gray-700">Row Entry</button>
          </div>

          <!-- Paste mode (default) -->
          <div id="cbChEntryPaste">
            <textarea id="cbChannelMeasurementsInput" class="w-full h-32 px-3 py-2 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500" placeholder="Enter L* measurements (input%, L*):
0, 95.5
10, 89.2
..."></textarea>
          </div>

          <!-- Row entry mode (hidden by default) -->
          <div id="cbChEntryManual" class="hidden">
            <div class="flex items-center gap-2 mb-2">
              <button id="cbChRemoveRow" class="w-6 h-6 flex items-center justify-center bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-sm font-bold">-</button>
              <span class="text-xs text-gray-600"><span id="cbChRowCount">7</span> points</span>
              <button id="cbChAddRow" class="w-6 h-6 flex items-center justify-center bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-sm font-bold">+</button>
            </div>
            <div class="max-h-48 overflow-y-auto border border-gray-200 rounded">
              <table class="w-full text-sm">
                <thead class="bg-gray-50 sticky top-0">
                  <tr>
                    <th class="px-1 py-1 w-8 text-left text-xs font-medium text-gray-500">#</th>
                    <th class="px-1 py-1 text-left text-xs font-medium text-gray-500">Patch %</th>
                    <th class="px-1 py-1 text-center text-xs font-medium text-gray-500">Preview</th>
                    <th class="px-1 py-1 text-left text-xs font-medium text-gray-500">L*</th>
                  </tr>
                </thead>
                <tbody id="cbChEntryRows"></tbody>
              </table>
            </div>
            <div id="cbChValidation" class="text-xs text-red-600 mt-2 hidden"></div>
          </div>
        </div>
        <button id="cbAddChannelBtn" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded text-sm">
          Add Channel
        </button>
        <div class="border-t border-gray-200 pt-4 mt-4">
          <div class="text-sm font-medium text-gray-700 mb-2">Added Channels</div>
          <div id="cbChannelList" class="space-y-2">
            <div class="text-gray-500 text-sm">No channels added yet</div>
          </div>
        </div>
      </div>
      <!-- Panel 3: Preview -->
      <div id="channelBuilderPanelPreview" class="hidden">
        <div class="text-sm text-gray-600 mb-4">
          Review computed bell positions and K carve-out before applying.
        </div>
        <div id="cbPreviewContent"></div>
      </div>
      <!-- Panel 4: Apply -->
      <div id="channelBuilderPanelApply" class="hidden">
        <div class="text-sm text-gray-600 mb-4">
          Confirm and apply changes to the current quad.
        </div>
        <div id="cbApplyContent"></div>
      </div>
    </div>
    <!-- Footer -->
    <div class="p-4 border-t border-gray-200 flex-shrink-0 flex justify-between">
      <button id="channelBuilderClearBtn" class="px-4 py-2 text-red-600 hover:text-red-800 text-sm">
        Clear Session
      </button>
      <div class="flex gap-2">
        <button id="channelBuilderPrevBtn" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded text-sm opacity-50" disabled>
          Previous
        </button>
        <button id="channelBuilderNextBtn" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded text-sm">
          Next
        </button>
      </div>
    </div>
  </div>
</div>
<!-- Embedded README fallback for Help popup (used if fetch fails) -->
</section></main></body>
</html>
